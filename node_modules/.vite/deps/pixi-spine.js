import {
  ALPHA_MODES,
  BLEND_MODES,
  Container,
  DRAW_MODES,
  Graphics,
  Loader,
  LoaderResource,
  MIPMAP_MODES,
  Matrix,
  Polygon,
  Rectangle,
  SCALE_MODES,
  SimpleMesh,
  Sprite,
  Texture,
  Transform,
  __export,
  hex2rgb,
  rgb2hex
} from "./chunk-JLVGEARW.js";

// node_modules/@pixi-spine/base/lib/base.es.js
var AttachmentType;
(function(AttachmentType2) {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
})(AttachmentType || (AttachmentType = {}));
var BinaryInput = (
  /** @class */
  function() {
    function BinaryInput2(data, strings, index, buffer) {
      if (strings === void 0) {
        strings = new Array();
      }
      if (index === void 0) {
        index = 0;
      }
      if (buffer === void 0) {
        buffer = new DataView(data.buffer);
      }
      this.strings = strings;
      this.index = index;
      this.buffer = buffer;
    }
    BinaryInput2.prototype.readByte = function() {
      return this.buffer.getInt8(this.index++);
    };
    BinaryInput2.prototype.readUnsignedByte = function() {
      return this.buffer.getUint8(this.index++);
    };
    BinaryInput2.prototype.readShort = function() {
      var value = this.buffer.getInt16(this.index);
      this.index += 2;
      return value;
    };
    BinaryInput2.prototype.readInt32 = function() {
      var value = this.buffer.getInt32(this.index);
      this.index += 4;
      return value;
    };
    BinaryInput2.prototype.readInt = function(optimizePositive) {
      var b = this.readByte();
      var result = b & 127;
      if ((b & 128) != 0) {
        b = this.readByte();
        result |= (b & 127) << 7;
        if ((b & 128) != 0) {
          b = this.readByte();
          result |= (b & 127) << 14;
          if ((b & 128) != 0) {
            b = this.readByte();
            result |= (b & 127) << 21;
            if ((b & 128) != 0) {
              b = this.readByte();
              result |= (b & 127) << 28;
            }
          }
        }
      }
      return optimizePositive ? result : result >>> 1 ^ -(result & 1);
    };
    BinaryInput2.prototype.readStringRef = function() {
      var index = this.readInt(true);
      return index == 0 ? null : this.strings[index - 1];
    };
    BinaryInput2.prototype.readString = function() {
      var byteCount = this.readInt(true);
      switch (byteCount) {
        case 0:
          return null;
        case 1:
          return "";
      }
      byteCount--;
      var chars = "";
      for (var i = 0; i < byteCount; ) {
        var b = this.readUnsignedByte();
        switch (b >> 4) {
          case 12:
          case 13:
            chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);
            i += 2;
            break;
          case 14:
            chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
            i += 3;
            break;
          default:
            chars += String.fromCharCode(b);
            i++;
        }
      }
      return chars;
    };
    BinaryInput2.prototype.readFloat = function() {
      var value = this.buffer.getFloat32(this.index);
      this.index += 4;
      return value;
    };
    BinaryInput2.prototype.readBoolean = function() {
      return this.readByte() != 0;
    };
    return BinaryInput2;
  }()
);
var MixBlend;
(function(MixBlend2) {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
})(MixBlend || (MixBlend = {}));
var MixDirection;
(function(MixDirection2) {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
})(MixDirection || (MixDirection = {}));
var PositionMode;
(function(PositionMode2) {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
})(PositionMode || (PositionMode = {}));
var RotateMode;
(function(RotateMode2) {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
})(RotateMode || (RotateMode = {}));
var TransformMode;
(function(TransformMode2) {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
})(TransformMode || (TransformMode = {}));
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function filterFromString(text) {
  switch (text.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error("Unknown texture filter " + text);
  }
}
function wrapFromString(text) {
  switch (text.toLowerCase()) {
    case "mirroredtepeat":
      return TextureWrap.MirroredRepeat;
    case "clamptoedge":
      return TextureWrap.ClampToEdge;
    case "repeat":
      return TextureWrap.Repeat;
    default:
      throw new Error("Unknown texture wrap " + text);
  }
}
var TextureFilter;
(function(TextureFilter2) {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
})(TextureFilter || (TextureFilter = {}));
var TextureWrap;
(function(TextureWrap2) {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
})(TextureWrap || (TextureWrap = {}));
var TextureRegion = (
  /** @class */
  function() {
    function TextureRegion2() {
      this.size = null;
      this.names = null;
      this.values = null;
      this.renderObject = null;
    }
    Object.defineProperty(TextureRegion2.prototype, "width", {
      get: function() {
        var tex = this.texture;
        if (tex.trim) {
          return tex.trim.width;
        }
        return tex.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "height", {
      get: function() {
        var tex = this.texture;
        if (tex.trim) {
          return tex.trim.height;
        }
        return tex.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "u", {
      get: function() {
        return this.texture._uvs.x0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "v", {
      get: function() {
        return this.texture._uvs.y0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "u2", {
      get: function() {
        return this.texture._uvs.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "v2", {
      get: function() {
        return this.texture._uvs.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "offsetX", {
      get: function() {
        var tex = this.texture;
        return tex.trim ? tex.trim.x : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "offsetY", {
      get: function() {
        return this.spineOffsetY;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "pixiOffsetY", {
      get: function() {
        var tex = this.texture;
        return tex.trim ? tex.trim.y : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "spineOffsetY", {
      get: function() {
        var tex = this.texture;
        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "originalWidth", {
      get: function() {
        return this.texture.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "originalHeight", {
      get: function() {
        return this.texture.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "x", {
      get: function() {
        return this.texture.frame.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "y", {
      get: function() {
        return this.texture.frame.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "rotate", {
      get: function() {
        return this.texture.rotate !== 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "degrees", {
      get: function() {
        return (360 - this.texture.rotate * 45) % 360;
      },
      enumerable: false,
      configurable: true
    });
    return TextureRegion2;
  }()
);
var RegionFields = (
  /** @class */
  /* @__PURE__ */ function() {
    function RegionFields2() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.originalWidth = 0;
      this.originalHeight = 0;
      this.rotate = 0;
      this.index = 0;
    }
    return RegionFields2;
  }()
);
var TextureAtlas = (
  /** @class */
  function() {
    function TextureAtlas2(atlasText, textureLoader, callback) {
      this.pages = new Array();
      this.regions = new Array();
      if (atlasText) {
        this.addSpineAtlas(atlasText, textureLoader, callback);
      }
    }
    TextureAtlas2.prototype.addTexture = function(name, texture) {
      var pages = this.pages;
      var page = null;
      for (var i = 0; i < pages.length; i++) {
        if (pages[i].baseTexture === texture.baseTexture) {
          page = pages[i];
          break;
        }
      }
      if (page === null) {
        page = new TextureAtlasPage();
        page.name = "texturePage";
        var baseTexture = texture.baseTexture;
        page.width = baseTexture.realWidth;
        page.height = baseTexture.realHeight;
        page.baseTexture = baseTexture;
        page.minFilter = page.magFilter = TextureFilter.Nearest;
        page.uWrap = TextureWrap.ClampToEdge;
        page.vWrap = TextureWrap.ClampToEdge;
        pages.push(page);
      }
      var region = new TextureAtlasRegion();
      region.name = name;
      region.page = page;
      region.texture = texture;
      region.index = -1;
      this.regions.push(region);
      return region;
    };
    TextureAtlas2.prototype.addTextureHash = function(textures, stripExtension) {
      for (var key in textures) {
        if (textures.hasOwnProperty(key)) {
          this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
        }
      }
    };
    TextureAtlas2.prototype.addSpineAtlas = function(atlasText, textureLoader, callback) {
      return this.load(atlasText, textureLoader, callback);
    };
    TextureAtlas2.prototype.load = function(atlasText, textureLoader, callback) {
      var _this = this;
      if (textureLoader == null)
        throw new Error("textureLoader cannot be null.");
      var reader = new TextureAtlasReader(atlasText);
      var entry = new Array(4);
      var page = null;
      var pageFields = {};
      var region = null;
      pageFields["size"] = function() {
        page.width = parseInt(entry[1]);
        page.height = parseInt(entry[2]);
      };
      pageFields["format"] = function() {
      };
      pageFields["filter"] = function() {
        page.minFilter = filterFromString(entry[1]);
        page.magFilter = filterFromString(entry[2]);
      };
      pageFields["repeat"] = function() {
        if (entry[1].indexOf("x") != -1)
          page.uWrap = TextureWrap.Repeat;
        if (entry[1].indexOf("y") != -1)
          page.vWrap = TextureWrap.Repeat;
      };
      pageFields["pma"] = function() {
        page.pma = entry[1] == "true";
      };
      var regionFields = {};
      regionFields["xy"] = function() {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
      };
      regionFields["size"] = function() {
        region.width = parseInt(entry[1]);
        region.height = parseInt(entry[2]);
      };
      regionFields["bounds"] = function() {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
        region.width = parseInt(entry[3]);
        region.height = parseInt(entry[4]);
      };
      regionFields["offset"] = function() {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
      };
      regionFields["orig"] = function() {
        region.originalWidth = parseInt(entry[1]);
        region.originalHeight = parseInt(entry[2]);
      };
      regionFields["offsets"] = function() {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
        region.originalWidth = parseInt(entry[3]);
        region.originalHeight = parseInt(entry[4]);
      };
      regionFields["rotate"] = function() {
        var rotateValue = entry[1];
        var rotate = 0;
        if (rotateValue.toLocaleLowerCase() == "true") {
          rotate = 6;
        } else if (rotateValue.toLocaleLowerCase() == "false") {
          rotate = 0;
        } else {
          rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
        }
        region.rotate = rotate;
      };
      regionFields["index"] = function() {
        region.index = parseInt(entry[1]);
      };
      var line = reader.readLine();
      while (line != null && line.trim().length == 0)
        line = reader.readLine();
      while (true) {
        if (line == null || line.trim().length == 0)
          break;
        if (reader.readEntry(entry, line) == 0)
          break;
        line = reader.readLine();
      }
      var iterateParser = function() {
        while (true) {
          if (line == null) {
            return callback && callback(_this);
          }
          if (line.trim().length == 0) {
            page = null;
            line = reader.readLine();
          } else if (page === null) {
            page = new TextureAtlasPage();
            page.name = line.trim();
            while (true) {
              if (reader.readEntry(entry, line = reader.readLine()) == 0)
                break;
              var field = pageFields[entry[0]];
              if (field)
                field();
            }
            _this.pages.push(page);
            textureLoader(page.name, function(texture) {
              if (texture === null) {
                _this.pages.splice(_this.pages.indexOf(page), 1);
                return callback && callback(null);
              }
              page.baseTexture = texture;
              if (page.pma) {
                texture.alphaMode = ALPHA_MODES.PMA;
              }
              if (!texture.valid) {
                texture.setSize(page.width, page.height);
              }
              page.setFilters();
              if (!page.width || !page.height) {
                page.width = texture.realWidth;
                page.height = texture.realHeight;
                if (!page.width || !page.height) {
                  console.log("ERROR spine atlas page " + page.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)");
                }
              }
              iterateParser();
            });
            break;
          } else {
            region = new RegionFields();
            var atlasRegion = new TextureAtlasRegion();
            atlasRegion.name = line;
            atlasRegion.page = page;
            var names = null;
            var values = null;
            while (true) {
              var count = reader.readEntry(entry, line = reader.readLine());
              if (count == 0)
                break;
              var field = regionFields[entry[0]];
              if (field)
                field();
              else {
                if (names == null) {
                  names = [];
                  values = [];
                }
                names.push(entry[0]);
                var entryValues = [];
                for (var i = 0; i < count; i++)
                  entryValues.push(parseInt(entry[i + 1]));
                values.push(entryValues);
              }
            }
            if (region.originalWidth == 0 && region.originalHeight == 0) {
              region.originalWidth = region.width;
              region.originalHeight = region.height;
            }
            var resolution = page.baseTexture.resolution;
            region.x /= resolution;
            region.y /= resolution;
            region.width /= resolution;
            region.height /= resolution;
            region.originalWidth /= resolution;
            region.originalHeight /= resolution;
            region.offsetX /= resolution;
            region.offsetY /= resolution;
            var swapWH = region.rotate % 4 !== 0;
            var frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
            var orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);
            var trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
            atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);
            atlasRegion.index = region.index;
            atlasRegion.texture.updateUvs();
            _this.regions.push(atlasRegion);
          }
        }
      };
      iterateParser();
    };
    TextureAtlas2.prototype.findRegion = function(name) {
      for (var i = 0; i < this.regions.length; i++) {
        if (this.regions[i].name == name) {
          return this.regions[i];
        }
      }
      return null;
    };
    TextureAtlas2.prototype.dispose = function() {
      for (var i = 0; i < this.pages.length; i++) {
        this.pages[i].baseTexture.dispose();
      }
    };
    return TextureAtlas2;
  }()
);
var TextureAtlasReader = (
  /** @class */
  function() {
    function TextureAtlasReader2(text) {
      this.index = 0;
      this.lines = text.split(/\r\n|\r|\n/);
    }
    TextureAtlasReader2.prototype.readLine = function() {
      if (this.index >= this.lines.length)
        return null;
      return this.lines[this.index++];
    };
    TextureAtlasReader2.prototype.readEntry = function(entry, line) {
      if (line == null)
        return 0;
      line = line.trim();
      if (line.length == 0)
        return 0;
      var colon = line.indexOf(":");
      if (colon == -1)
        return 0;
      entry[0] = line.substr(0, colon).trim();
      for (var i = 1, lastMatch = colon + 1; ; i++) {
        var comma = line.indexOf(",", lastMatch);
        if (comma == -1) {
          entry[i] = line.substr(lastMatch).trim();
          return i;
        }
        entry[i] = line.substr(lastMatch, comma - lastMatch).trim();
        lastMatch = comma + 1;
        if (i == 4)
          return 4;
      }
    };
    return TextureAtlasReader2;
  }()
);
var TextureAtlasPage = (
  /** @class */
  function() {
    function TextureAtlasPage2() {
      this.minFilter = TextureFilter.Nearest;
      this.magFilter = TextureFilter.Nearest;
      this.uWrap = TextureWrap.ClampToEdge;
      this.vWrap = TextureWrap.ClampToEdge;
    }
    TextureAtlasPage2.prototype.setFilters = function() {
      var tex = this.baseTexture;
      var filter = this.minFilter;
      if (filter == TextureFilter.Linear) {
        tex.scaleMode = SCALE_MODES.LINEAR;
      } else if (this.minFilter == TextureFilter.Nearest) {
        tex.scaleMode = SCALE_MODES.NEAREST;
      } else {
        tex.mipmap = MIPMAP_MODES.POW2;
        if (filter == TextureFilter.MipMapNearestNearest) {
          tex.scaleMode = SCALE_MODES.NEAREST;
        } else {
          tex.scaleMode = SCALE_MODES.LINEAR;
        }
      }
    };
    return TextureAtlasPage2;
  }()
);
var TextureAtlasRegion = (
  /** @class */
  function(_super) {
    __extends(TextureAtlasRegion2, _super);
    function TextureAtlasRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextureAtlasRegion2;
  }(TextureRegion)
);
var fround_polyfill = /* @__PURE__ */ function(array) {
  return function(x) {
    return array[0] = x, array[0];
  };
}(new Float32Array(1));
var fround = Math.fround || fround_polyfill;
var IntSet = (
  /** @class */
  function() {
    function IntSet2() {
      this.array = new Array();
    }
    IntSet2.prototype.add = function(value) {
      var contains = this.contains(value);
      this.array[value | 0] = value | 0;
      return !contains;
    };
    IntSet2.prototype.contains = function(value) {
      return this.array[value | 0] != void 0;
    };
    IntSet2.prototype.remove = function(value) {
      this.array[value | 0] = void 0;
    };
    IntSet2.prototype.clear = function() {
      this.array.length = 0;
    };
    return IntSet2;
  }()
);
var StringSet = (
  /** @class */
  function() {
    function StringSet2() {
      this.entries = {};
      this.size = 0;
    }
    StringSet2.prototype.add = function(value) {
      var contains = this.entries[value];
      this.entries[value] = true;
      if (!contains) {
        this.size++;
        return true;
      }
      return false;
    };
    StringSet2.prototype.addAll = function(values) {
      var oldSize = this.size;
      for (var i = 0, n = values.length; i < n; i++)
        this.add(values[i]);
      return oldSize != this.size;
    };
    StringSet2.prototype.contains = function(value) {
      return this.entries[value];
    };
    StringSet2.prototype.clear = function() {
      this.entries = {};
      this.size = 0;
    };
    return StringSet2;
  }()
);
var Color = (
  /** @class */
  function() {
    function Color2(r, g, b, a) {
      if (r === void 0) {
        r = 0;
      }
      if (g === void 0) {
        g = 0;
      }
      if (b === void 0) {
        b = 0;
      }
      if (a === void 0) {
        a = 0;
      }
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    Color2.prototype.set = function(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      return this.clamp();
    };
    Color2.prototype.setFromColor = function(c) {
      this.r = c.r;
      this.g = c.g;
      this.b = c.b;
      this.a = c.a;
      return this;
    };
    Color2.prototype.setFromString = function(hex) {
      hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
      this.r = parseInt(hex.substr(0, 2), 16) / 255;
      this.g = parseInt(hex.substr(2, 2), 16) / 255;
      this.b = parseInt(hex.substr(4, 2), 16) / 255;
      this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
      return this;
    };
    Color2.prototype.add = function(r, g, b, a) {
      this.r += r;
      this.g += g;
      this.b += b;
      this.a += a;
      return this.clamp();
    };
    Color2.prototype.clamp = function() {
      if (this.r < 0)
        this.r = 0;
      else if (this.r > 1)
        this.r = 1;
      if (this.g < 0)
        this.g = 0;
      else if (this.g > 1)
        this.g = 1;
      if (this.b < 0)
        this.b = 0;
      else if (this.b > 1)
        this.b = 1;
      if (this.a < 0)
        this.a = 0;
      else if (this.a > 1)
        this.a = 1;
      return this;
    };
    Color2.rgba8888ToColor = function(color, value) {
      color.r = ((value & 4278190080) >>> 24) / 255;
      color.g = ((value & 16711680) >>> 16) / 255;
      color.b = ((value & 65280) >>> 8) / 255;
      color.a = (value & 255) / 255;
    };
    Color2.rgb888ToColor = function(color, value) {
      color.r = ((value & 16711680) >>> 16) / 255;
      color.g = ((value & 65280) >>> 8) / 255;
      color.b = (value & 255) / 255;
    };
    Color2.fromString = function(hex) {
      return new Color2().setFromString(hex);
    };
    Color2.WHITE = new Color2(1, 1, 1, 1);
    Color2.RED = new Color2(1, 0, 0, 1);
    Color2.GREEN = new Color2(0, 1, 0, 1);
    Color2.BLUE = new Color2(0, 0, 1, 1);
    Color2.MAGENTA = new Color2(1, 0, 1, 1);
    return Color2;
  }()
);
var MathUtils = (
  /** @class */
  function() {
    function MathUtils2() {
    }
    MathUtils2.clamp = function(value, min, max) {
      if (value < min)
        return min;
      if (value > max)
        return max;
      return value;
    };
    MathUtils2.cosDeg = function(degrees) {
      return Math.cos(degrees * MathUtils2.degRad);
    };
    MathUtils2.sinDeg = function(degrees) {
      return Math.sin(degrees * MathUtils2.degRad);
    };
    MathUtils2.signum = function(value) {
      return value > 0 ? 1 : value < 0 ? -1 : 0;
    };
    MathUtils2.toInt = function(x) {
      return x > 0 ? Math.floor(x) : Math.ceil(x);
    };
    MathUtils2.cbrt = function(x) {
      var y = Math.pow(Math.abs(x), 1 / 3);
      return x < 0 ? -y : y;
    };
    MathUtils2.randomTriangular = function(min, max) {
      return MathUtils2.randomTriangularWith(min, max, (min + max) * 0.5);
    };
    MathUtils2.randomTriangularWith = function(min, max, mode) {
      var u = Math.random();
      var d = max - min;
      if (u <= (mode - min) / d)
        return min + Math.sqrt(u * d * (mode - min));
      return max - Math.sqrt((1 - u) * d * (max - mode));
    };
    MathUtils2.isPowerOfTwo = function(value) {
      return value && (value & value - 1) === 0;
    };
    MathUtils2.PI = 3.1415927;
    MathUtils2.PI2 = MathUtils2.PI * 2;
    MathUtils2.radiansToDegrees = 180 / MathUtils2.PI;
    MathUtils2.radDeg = MathUtils2.radiansToDegrees;
    MathUtils2.degreesToRadians = MathUtils2.PI / 180;
    MathUtils2.degRad = MathUtils2.degreesToRadians;
    return MathUtils2;
  }()
);
var Interpolation = (
  /** @class */
  function() {
    function Interpolation2() {
    }
    Interpolation2.prototype.apply = function(start, end, a) {
      return start + (end - start) * this.applyInternal(a);
    };
    return Interpolation2;
  }()
);
var Pow = (
  /** @class */
  function(_super) {
    __extends(Pow2, _super);
    function Pow2(power) {
      var _this = _super.call(this) || this;
      _this.power = 2;
      _this.power = power;
      return _this;
    }
    Pow2.prototype.applyInternal = function(a) {
      if (a <= 0.5)
        return Math.pow(a * 2, this.power) / 2;
      return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
    };
    return Pow2;
  }(Interpolation)
);
var PowOut = (
  /** @class */
  function(_super) {
    __extends(PowOut2, _super);
    function PowOut2(power) {
      return _super.call(this, power) || this;
    }
    PowOut2.prototype.applyInternal = function(a) {
      return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
    };
    return PowOut2;
  }(Pow)
);
var Utils = (
  /** @class */
  function() {
    function Utils2() {
    }
    Utils2.arrayCopy = function(source, sourceStart, dest, destStart, numElements) {
      for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
        dest[j] = source[i];
      }
    };
    Utils2.arrayFill = function(array, fromIndex, toIndex, value) {
      for (var i = fromIndex; i < toIndex; i++)
        array[i] = value;
    };
    Utils2.setArraySize = function(array, size, value) {
      if (value === void 0) {
        value = 0;
      }
      var oldSize = array.length;
      if (oldSize == size)
        return array;
      array.length = size;
      if (oldSize < size) {
        for (var i = oldSize; i < size; i++)
          array[i] = value;
      }
      return array;
    };
    Utils2.ensureArrayCapacity = function(array, size, value) {
      if (value === void 0) {
        value = 0;
      }
      if (array.length >= size)
        return array;
      return Utils2.setArraySize(array, size, value);
    };
    Utils2.newArray = function(size, defaultValue) {
      var array = new Array(size);
      for (var i = 0; i < size; i++)
        array[i] = defaultValue;
      return array;
    };
    Utils2.newFloatArray = function(size) {
      if (Utils2.SUPPORTS_TYPED_ARRAYS)
        return new Float32Array(size);
      else {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++)
          array[i] = 0;
        return array;
      }
    };
    Utils2.newShortArray = function(size) {
      if (Utils2.SUPPORTS_TYPED_ARRAYS)
        return new Int16Array(size);
      else {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++)
          array[i] = 0;
        return array;
      }
    };
    Utils2.toFloatArray = function(array) {
      return Utils2.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
    };
    Utils2.toSinglePrecision = function(value) {
      return Utils2.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;
    };
    Utils2.webkit602BugfixHelper = function(alpha, blend) {
    };
    Utils2.contains = function(array, element, identity) {
      for (var i = 0; i < array.length; i++)
        if (array[i] == element)
          return true;
      return false;
    };
    Utils2.enumValue = function(type, name) {
      return type[name[0].toUpperCase() + name.slice(1)];
    };
    Utils2.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
    return Utils2;
  }()
);
var DebugUtils = (
  /** @class */
  function() {
    function DebugUtils2() {
    }
    DebugUtils2.logBones = function(skeleton) {
      for (var i = 0; i < skeleton.bones.length; i++) {
        var bone = skeleton.bones[i];
        var mat = bone.matrix;
        console.log(bone.data.name + ", " + mat.a + ", " + mat.b + ", " + mat.c + ", " + mat.d + ", " + mat.tx + ", " + mat.ty);
      }
    };
    return DebugUtils2;
  }()
);
var Pool = (
  /** @class */
  function() {
    function Pool2(instantiator) {
      this.items = new Array();
      this.instantiator = instantiator;
    }
    Pool2.prototype.obtain = function() {
      return this.items.length > 0 ? this.items.pop() : this.instantiator();
    };
    Pool2.prototype.free = function(item) {
      if (item.reset)
        item.reset();
      this.items.push(item);
    };
    Pool2.prototype.freeAll = function(items) {
      for (var i = 0; i < items.length; i++)
        this.free(items[i]);
    };
    Pool2.prototype.clear = function() {
      this.items.length = 0;
    };
    return Pool2;
  }()
);
var Vector2 = (
  /** @class */
  function() {
    function Vector22(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.x = x;
      this.y = y;
    }
    Vector22.prototype.set = function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    };
    Vector22.prototype.length = function() {
      var x = this.x;
      var y = this.y;
      return Math.sqrt(x * x + y * y);
    };
    Vector22.prototype.normalize = function() {
      var len = this.length();
      if (len != 0) {
        this.x /= len;
        this.y /= len;
      }
      return this;
    };
    return Vector22;
  }()
);
var TimeKeeper = (
  /** @class */
  function() {
    function TimeKeeper2() {
      this.maxDelta = 0.064;
      this.framesPerSecond = 0;
      this.delta = 0;
      this.totalTime = 0;
      this.lastTime = Date.now() / 1e3;
      this.frameCount = 0;
      this.frameTime = 0;
    }
    TimeKeeper2.prototype.update = function() {
      var now = Date.now() / 1e3;
      this.delta = now - this.lastTime;
      this.frameTime += this.delta;
      this.totalTime += this.delta;
      if (this.delta > this.maxDelta)
        this.delta = this.maxDelta;
      this.lastTime = now;
      this.frameCount++;
      if (this.frameTime > 1) {
        this.framesPerSecond = this.frameCount / this.frameTime;
        this.frameTime = 0;
        this.frameCount = 0;
      }
    };
    return TimeKeeper2;
  }()
);
var WindowedMean = (
  /** @class */
  function() {
    function WindowedMean2(windowSize) {
      if (windowSize === void 0) {
        windowSize = 32;
      }
      this.addedValues = 0;
      this.lastValue = 0;
      this.mean = 0;
      this.dirty = true;
      this.values = new Array(windowSize);
    }
    WindowedMean2.prototype.hasEnoughData = function() {
      return this.addedValues >= this.values.length;
    };
    WindowedMean2.prototype.addValue = function(value) {
      if (this.addedValues < this.values.length)
        this.addedValues++;
      this.values[this.lastValue++] = value;
      if (this.lastValue > this.values.length - 1)
        this.lastValue = 0;
      this.dirty = true;
    };
    WindowedMean2.prototype.getMean = function() {
      if (this.hasEnoughData()) {
        if (this.dirty) {
          var mean = 0;
          for (var i = 0; i < this.values.length; i++)
            mean += this.values[i];
          this.mean = mean / this.values.length;
          this.dirty = false;
        }
        return this.mean;
      }
      return 0;
    };
    return WindowedMean2;
  }()
);
var SkeletonBoundsBase = (
  /** @class */
  function() {
    function SkeletonBoundsBase2() {
      this.minX = 0;
      this.minY = 0;
      this.maxX = 0;
      this.maxY = 0;
      this.boundingBoxes = new Array();
      this.polygons = new Array();
      this.polygonPool = new Pool(function() {
        return Utils.newFloatArray(16);
      });
    }
    SkeletonBoundsBase2.prototype.update = function(skeleton, updateAabb) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      var boundingBoxes = this.boundingBoxes;
      var polygons = this.polygons;
      var polygonPool = this.polygonPool;
      var slots = skeleton.slots;
      var slotCount = slots.length;
      boundingBoxes.length = 0;
      polygonPool.freeAll(polygons);
      polygons.length = 0;
      for (var i = 0; i < slotCount; i++) {
        var slot = slots[i];
        if (!slot.bone.active)
          continue;
        var attachment = slot.getAttachment();
        if (attachment != null && attachment.type === AttachmentType.BoundingBox) {
          var boundingBox = attachment;
          boundingBoxes.push(boundingBox);
          var polygon = polygonPool.obtain();
          if (polygon.length != boundingBox.worldVerticesLength) {
            polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);
          }
          polygons.push(polygon);
          boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
        }
      }
      if (updateAabb) {
        this.aabbCompute();
      } else {
        this.minX = Number.POSITIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
      }
    };
    SkeletonBoundsBase2.prototype.aabbCompute = function() {
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      var polygons = this.polygons;
      for (var i = 0, n = polygons.length; i < n; i++) {
        var polygon = polygons[i];
        var vertices = polygon;
        for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
          var x = vertices[ii];
          var y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    SkeletonBoundsBase2.prototype.aabbContainsPoint = function(x, y) {
      return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
    };
    SkeletonBoundsBase2.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY)
        return false;
      var m = (y2 - y1) / (x2 - x1);
      var y = m * (minX - x1) + y1;
      if (y > minY && y < maxY)
        return true;
      y = m * (maxX - x1) + y1;
      if (y > minY && y < maxY)
        return true;
      var x = (minY - y1) / m + x1;
      if (x > minX && x < maxX)
        return true;
      x = (maxY - y1) / m + x1;
      if (x > minX && x < maxX)
        return true;
      return false;
    };
    SkeletonBoundsBase2.prototype.aabbIntersectsSkeleton = function(bounds) {
      return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
    };
    SkeletonBoundsBase2.prototype.containsPoint = function(x, y) {
      var polygons = this.polygons;
      for (var i = 0, n = polygons.length; i < n; i++)
        if (this.containsPointPolygon(polygons[i], x, y))
          return this.boundingBoxes[i];
      return null;
    };
    SkeletonBoundsBase2.prototype.containsPointPolygon = function(polygon, x, y) {
      var vertices = polygon;
      var nn = polygon.length;
      var prevIndex = nn - 2;
      var inside = false;
      for (var ii = 0; ii < nn; ii += 2) {
        var vertexY = vertices[ii + 1];
        var prevY = vertices[prevIndex + 1];
        if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
          var vertexX = vertices[ii];
          if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
            inside = !inside;
        }
        prevIndex = ii;
      }
      return inside;
    };
    SkeletonBoundsBase2.prototype.intersectsSegment = function(x1, y1, x2, y2) {
      var polygons = this.polygons;
      for (var i = 0, n = polygons.length; i < n; i++)
        if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
          return this.boundingBoxes[i];
      return null;
    };
    SkeletonBoundsBase2.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
      var vertices = polygon;
      var nn = polygon.length;
      var width12 = x1 - x2, height12 = y1 - y2;
      var det1 = x1 * y2 - y1 * x2;
      var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
      for (var ii = 0; ii < nn; ii += 2) {
        var x4 = vertices[ii], y4 = vertices[ii + 1];
        var det2 = x3 * y4 - y3 * x4;
        var width34 = x3 - x4, height34 = y3 - y4;
        var det3 = width12 * height34 - height12 * width34;
        var x = (det1 * width34 - width12 * det2) / det3;
        if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
          var y = (det1 * height34 - height12 * det2) / det3;
          if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))
            return true;
        }
        x3 = x4;
        y3 = y4;
      }
      return false;
    };
    SkeletonBoundsBase2.prototype.getPolygon = function(boundingBox) {
      if (!boundingBox)
        throw new Error("boundingBox cannot be null.");
      var index = this.boundingBoxes.indexOf(boundingBox);
      return index == -1 ? null : this.polygons[index];
    };
    SkeletonBoundsBase2.prototype.getWidth = function() {
      return this.maxX - this.minX;
    };
    SkeletonBoundsBase2.prototype.getHeight = function() {
      return this.maxY - this.minY;
    };
    return SkeletonBoundsBase2;
  }()
);
var settings = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0
};
var tempRgb = [0, 0, 0];
var SpineSprite = (
  /** @class */
  function(_super) {
    __extends(SpineSprite2, _super);
    function SpineSprite2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.region = null;
      _this.attachment = null;
      return _this;
    }
    return SpineSprite2;
  }(Sprite)
);
var SpineMesh = (
  /** @class */
  function(_super) {
    __extends(SpineMesh2, _super);
    function SpineMesh2(texture, vertices, uvs, indices, drawMode) {
      var _this = _super.call(this, texture, vertices, uvs, indices, drawMode) || this;
      _this.region = null;
      _this.attachment = null;
      return _this;
    }
    return SpineMesh2;
  }(SimpleMesh)
);
var SpineBase = (
  /** @class */
  function(_super) {
    __extends(SpineBase2, _super);
    function SpineBase2(spineData) {
      var _this = _super.call(this) || this;
      if (!spineData) {
        throw new Error("The spineData param is required.");
      }
      if (typeof spineData === "string") {
        throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
      }
      _this.spineData = spineData;
      _this.createSkeleton(spineData);
      _this.slotContainers = [];
      _this.tempClipContainers = [];
      for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {
        var slot = _this.skeleton.slots[i];
        var attachment = slot.getAttachment();
        var slotContainer = _this.newContainer();
        _this.slotContainers.push(slotContainer);
        _this.addChild(slotContainer);
        _this.tempClipContainers.push(null);
        if (!attachment) {
          continue;
        }
        if (attachment.type === AttachmentType.Region) {
          var spriteName = attachment.name;
          var sprite = _this.createSprite(slot, attachment, spriteName);
          slot.currentSprite = sprite;
          slot.currentSpriteName = spriteName;
          slotContainer.addChild(sprite);
        } else if (attachment.type === AttachmentType.Mesh) {
          var mesh = _this.createMesh(slot, attachment);
          slot.currentMesh = mesh;
          slot.currentMeshId = attachment.id;
          slot.currentMeshName = attachment.name;
          slotContainer.addChild(mesh);
        } else if (attachment.type === AttachmentType.Clipping) {
          _this.createGraphics(slot, attachment);
          slotContainer.addChild(slot.clippingContainer);
          slotContainer.addChild(slot.currentGraphics);
        }
      }
      _this.tintRgb = new Float32Array([1, 1, 1]);
      _this.autoUpdate = true;
      _this.visible = true;
      return _this;
    }
    Object.defineProperty(SpineBase2.prototype, "debug", {
      get: function() {
        return this._debug;
      },
      set: function(value) {
        var _a;
        if (value == this._debug) {
          return;
        }
        (_a = this._debug) === null || _a === void 0 ? void 0 : _a.unregisterSpine(this);
        value === null || value === void 0 ? void 0 : value.registerSpine(this);
        this._debug = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "autoUpdate", {
      /**
       * If this flag is set to true, the spine animation will be automatically updated every
       * time the object id drawn. The down side of this approach is that the delta time is
       * automatically calculated and you could miss out on cool effects like slow motion,
       * pause, skip ahead and the sorts. Most of these effects can be achieved even with
       * autoUpdate enabled but are harder to achieve.
       *
       * @member {boolean}
       * @memberof spine.Spine#
       * @default true
       */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this.updateTransform = value ? SpineBase2.prototype.autoUpdateTransform : Container.prototype.updateTransform;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "tint", {
      /**
       * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
       *
       * @member {number}
       * @memberof spine.Spine#
       * @default 0xFFFFFF
       */
      get: function() {
        return rgb2hex(this.tintRgb);
      },
      set: function(value) {
        this.tintRgb = hex2rgb(value, this.tintRgb);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "delayLimit", {
      /**
       * Limit value for the update dt with Spine.globalDelayLimit
       * that can be overridden with localDelayLimit
       * @return {number} - Maximum processed dt value for the update
       */
      get: function() {
        var limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;
        return limit || Number.MAX_VALUE;
      },
      enumerable: false,
      configurable: true
    });
    SpineBase2.prototype.update = function(dt) {
      var _a;
      var delayLimit = this.delayLimit;
      if (dt > delayLimit)
        dt = delayLimit;
      this.state.update(dt);
      this.state.apply(this.skeleton);
      if (!this.skeleton)
        return;
      this.skeleton.updateWorldTransform();
      var slots = this.skeleton.slots;
      var globalClr = this.color;
      var light = null, dark = null;
      if (globalClr) {
        light = globalClr.light;
        dark = globalClr.dark;
      } else {
        light = this.tintRgb;
      }
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        var attachment = slot.getAttachment();
        var slotContainer = this.slotContainers[i];
        if (!attachment) {
          slotContainer.visible = false;
          continue;
        }
        var spriteColor = null;
        if (attachment.sequence) {
          attachment.sequence.apply(slot, attachment);
        }
        var region = attachment.region;
        var attColor = attachment.color;
        switch (attachment != null && attachment.type) {
          case AttachmentType.Region:
            var transform = slotContainer.transform;
            transform.setFromMatrix(slot.bone.matrix);
            region = attachment.region;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
              slot.currentMesh = null;
              slot.currentMeshId = void 0;
              slot.currentMeshName = void 0;
            }
            if (!region) {
              if (slot.currentSprite) {
                slot.currentSprite.renderable = false;
              }
              break;
            }
            if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
              var spriteName = attachment.name;
              if (slot.currentSprite) {
                slot.currentSprite.visible = false;
              }
              slot.sprites = slot.sprites || {};
              if (slot.sprites[spriteName] !== void 0) {
                slot.sprites[spriteName].visible = true;
              } else {
                var sprite = this.createSprite(slot, attachment, spriteName);
                slotContainer.addChild(sprite);
              }
              slot.currentSprite = slot.sprites[spriteName];
              slot.currentSpriteName = spriteName;
            }
            slot.currentSprite.renderable = true;
            if (!slot.hackRegion) {
              this.setSpriteRegion(attachment, slot.currentSprite, region);
            }
            if (slot.currentSprite.color) {
              spriteColor = slot.currentSprite.color;
            } else {
              tempRgb[0] = light[0] * slot.color.r * attColor.r;
              tempRgb[1] = light[1] * slot.color.g * attColor.g;
              tempRgb[2] = light[2] * slot.color.b * attColor.b;
              slot.currentSprite.tint = rgb2hex(tempRgb);
            }
            slot.currentSprite.blendMode = slot.blendMode;
            break;
          case AttachmentType.Mesh:
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
              slot.currentSprite = null;
              slot.currentSpriteName = void 0;
              var transform_1 = new Transform();
              transform_1._parentID = -1;
              transform_1._worldID = slotContainer.transform._worldID;
              slotContainer.transform = transform_1;
            }
            if (!region) {
              if (slot.currentMesh) {
                slot.currentMesh.renderable = false;
              }
              break;
            }
            var id = attachment.id;
            if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {
              var meshId = id;
              if (slot.currentMesh) {
                slot.currentMesh.visible = false;
              }
              slot.meshes = slot.meshes || {};
              if (slot.meshes[meshId] !== void 0) {
                slot.meshes[meshId].visible = true;
              } else {
                var mesh = this.createMesh(slot, attachment);
                slotContainer.addChild(mesh);
              }
              slot.currentMesh = slot.meshes[meshId];
              slot.currentMeshName = attachment.name;
              slot.currentMeshId = meshId;
            }
            slot.currentMesh.renderable = true;
            attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
            if (slot.currentMesh.color) {
              spriteColor = slot.currentMesh.color;
            } else {
              tempRgb[0] = light[0] * slot.color.r * attColor.r;
              tempRgb[1] = light[1] * slot.color.g * attColor.g;
              tempRgb[2] = light[2] * slot.color.b * attColor.b;
              slot.currentMesh.tint = rgb2hex(tempRgb);
            }
            slot.currentMesh.blendMode = slot.blendMode;
            if (!slot.hackRegion) {
              this.setMeshRegion(attachment, slot.currentMesh, region);
            }
            break;
          case AttachmentType.Clipping:
            if (!slot.currentGraphics) {
              this.createGraphics(slot, attachment);
              slotContainer.addChild(slot.clippingContainer);
              slotContainer.addChild(slot.currentGraphics);
            }
            this.updateGraphics(slot, attachment);
            slotContainer.alpha = 1;
            slotContainer.visible = true;
            continue;
          default:
            slotContainer.visible = false;
            continue;
        }
        slotContainer.visible = true;
        if (spriteColor) {
          var r0 = slot.color.r * attColor.r;
          var g0 = slot.color.g * attColor.g;
          var b0 = slot.color.b * attColor.b;
          spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
          if (slot.darkColor) {
            r0 = slot.darkColor.r;
            g0 = slot.darkColor.g;
            b0 = slot.darkColor.b;
          } else {
            r0 = 0;
            g0 = 0;
            b0 = 0;
          }
          spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        }
        slotContainer.alpha = slot.color.a;
      }
      var drawOrder = this.skeleton.drawOrder;
      var clippingAttachment = null;
      var clippingContainer = null;
      for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = slots[drawOrder[i].data.index];
        var slotContainer = this.slotContainers[drawOrder[i].data.index];
        if (!clippingContainer) {
          if (slotContainer.parent !== null && slotContainer.parent !== this) {
            slotContainer.parent.removeChild(slotContainer);
            slotContainer.parent = this;
          }
        }
        if (slot.currentGraphics && slot.getAttachment()) {
          clippingContainer = slot.clippingContainer;
          clippingAttachment = slot.getAttachment();
          clippingContainer.children.length = 0;
          this.children[i] = slotContainer;
          if (clippingAttachment.endSlot === slot.data) {
            clippingAttachment.endSlot = null;
          }
        } else {
          if (clippingContainer) {
            var c = this.tempClipContainers[i];
            if (!c) {
              c = this.tempClipContainers[i] = this.newContainer();
              c.visible = false;
            }
            this.children[i] = c;
            slotContainer.parent = null;
            clippingContainer.addChild(slotContainer);
            if (clippingAttachment.endSlot == slot.data) {
              clippingContainer.renderable = true;
              clippingContainer = null;
              clippingAttachment = null;
            }
          } else {
            this.children[i] = slotContainer;
          }
        }
      }
      (_a = this._debug) === null || _a === void 0 ? void 0 : _a.renderDebug(this);
    };
    SpineBase2.prototype.setSpriteRegion = function(attachment, sprite, region) {
      if (sprite.attachment === attachment && sprite.region === region) {
        return;
      }
      sprite.region = region;
      sprite.attachment = attachment;
      sprite.texture = region.texture;
      sprite.rotation = attachment.rotation * MathUtils.degRad;
      sprite.position.x = attachment.x;
      sprite.position.y = attachment.y;
      sprite.alpha = attachment.color.a;
      if (!region.size) {
        sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
        sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
      } else {
        sprite.scale.x = region.size.width / region.originalWidth;
        sprite.scale.y = -region.size.height / region.originalHeight;
      }
    };
    SpineBase2.prototype.setMeshRegion = function(attachment, mesh, region) {
      if (mesh.attachment === attachment && mesh.region === region) {
        return;
      }
      mesh.region = region;
      mesh.attachment = attachment;
      mesh.texture = region.texture;
      region.texture.updateUvs();
      mesh.uvBuffer.update(attachment.regionUVs);
    };
    SpineBase2.prototype.autoUpdateTransform = function() {
      if (settings.GLOBAL_AUTO_UPDATE) {
        this.lastTime = this.lastTime || Date.now();
        var timeDelta = (Date.now() - this.lastTime) * 1e-3;
        this.lastTime = Date.now();
        this.update(timeDelta);
      } else {
        this.lastTime = 0;
      }
      Container.prototype.updateTransform.call(this);
    };
    SpineBase2.prototype.createSprite = function(slot, attachment, defName) {
      var region = attachment.region;
      if (slot.hackAttachment === attachment) {
        region = slot.hackRegion;
      }
      var texture = region ? region.texture : null;
      var sprite = this.newSprite(texture);
      sprite.anchor.set(0.5);
      if (region) {
        this.setSpriteRegion(attachment, sprite, attachment.region);
      }
      slot.sprites = slot.sprites || {};
      slot.sprites[defName] = sprite;
      return sprite;
    };
    SpineBase2.prototype.createMesh = function(slot, attachment) {
      var region = attachment.region;
      if (slot.hackAttachment === attachment) {
        region = slot.hackRegion;
        slot.hackAttachment = null;
        slot.hackRegion = null;
      }
      var strip = this.newMesh(region ? region.texture : null, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), DRAW_MODES.TRIANGLES);
      if (typeof strip._canvasPadding !== "undefined") {
        strip._canvasPadding = 1.5;
      }
      strip.alpha = attachment.color.a;
      strip.region = attachment.region;
      if (region) {
        this.setMeshRegion(attachment, strip, region);
      }
      slot.meshes = slot.meshes || {};
      slot.meshes[attachment.id] = strip;
      return strip;
    };
    SpineBase2.prototype.createGraphics = function(slot, clip) {
      var graphics = this.newGraphics();
      var poly = new Polygon([]);
      graphics.clear();
      graphics.beginFill(16777215, 1);
      graphics.drawPolygon(poly);
      graphics.renderable = false;
      slot.currentGraphics = graphics;
      slot.clippingContainer = this.newContainer();
      slot.clippingContainer.mask = slot.currentGraphics;
      return graphics;
    };
    SpineBase2.prototype.updateGraphics = function(slot, clip) {
      var geom = slot.currentGraphics.geometry;
      var vertices = geom.graphicsData[0].shape.points;
      var n = clip.worldVerticesLength;
      vertices.length = n;
      clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
      geom.invalidate();
    };
    SpineBase2.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {
      if (texture === void 0) {
        texture = null;
      }
      if (size === void 0) {
        size = null;
      }
      var slot = this.skeleton.slots[slotIndex];
      if (!slot) {
        return false;
      }
      var attachment = slot.getAttachment();
      var region = attachment.region;
      if (texture) {
        region = new TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = attachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite) {
        this.setSpriteRegion(attachment, slot.currentSprite, region);
      } else if (slot.currentMesh) {
        this.setMeshRegion(attachment, slot.currentMesh, region);
      }
      return true;
    };
    SpineBase2.prototype.hackTextureBySlotName = function(slotName, texture, size) {
      if (texture === void 0) {
        texture = null;
      }
      if (size === void 0) {
        size = null;
      }
      var index = this.skeleton.findSlotIndex(slotName);
      if (index == -1) {
        return false;
      }
      return this.hackTextureBySlotIndex(index, texture, size);
    };
    SpineBase2.prototype.hackTextureAttachment = function(slotName, attachmentName, texture, size) {
      if (size === void 0) {
        size = null;
      }
      var slotIndex = this.skeleton.findSlotIndex(slotName);
      var attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
      attachment.region.texture = texture;
      var slot = this.skeleton.slots[slotIndex];
      if (!slot) {
        return false;
      }
      var currentAttachment = slot.getAttachment();
      if (attachmentName === currentAttachment.name) {
        var region = attachment.region;
        if (texture) {
          region = new TextureRegion();
          region.texture = texture;
          region.size = size;
          slot.hackRegion = region;
          slot.hackAttachment = currentAttachment;
        } else {
          slot.hackRegion = null;
          slot.hackAttachment = null;
        }
        if (slot.currentSprite && slot.currentSprite.region != region) {
          this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
          slot.currentSprite.region = region;
        } else if (slot.currentMesh && slot.currentMesh.region != region) {
          this.setMeshRegion(currentAttachment, slot.currentMesh, region);
        }
        return true;
      }
      return false;
    };
    SpineBase2.prototype.newContainer = function() {
      return new Container();
    };
    SpineBase2.prototype.newSprite = function(tex) {
      return new SpineSprite(tex);
    };
    SpineBase2.prototype.newGraphics = function() {
      return new Graphics();
    };
    SpineBase2.prototype.newMesh = function(texture, vertices, uvs, indices, drawMode) {
      return new SpineMesh(texture, vertices, uvs, indices, drawMode);
    };
    SpineBase2.prototype.transformHack = function() {
      return 1;
    };
    SpineBase2.prototype.hackAttachmentGroups = function(nameSuffix, group, outGroup) {
      if (!nameSuffix) {
        return void 0;
      }
      var list_d = [], list_n = [];
      for (var i = 0, len = this.skeleton.slots.length; i < len; i++) {
        var slot = this.skeleton.slots[i];
        var name_1 = slot.currentSpriteName || slot.currentMeshName || "";
        var target = slot.currentSprite || slot.currentMesh;
        if (name_1.endsWith(nameSuffix)) {
          target.parentGroup = group;
          list_n.push(target);
        } else if (outGroup && target) {
          target.parentGroup = outGroup;
          list_d.push(target);
        }
      }
      return [list_d, list_n];
    };
    SpineBase2.prototype.destroy = function(options) {
      this.debug = null;
      for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {
        var slot = this.skeleton.slots[i];
        for (var name_2 in slot.meshes) {
          slot.meshes[name_2].destroy(options);
        }
        slot.meshes = null;
        for (var name_3 in slot.sprites) {
          slot.sprites[name_3].destroy(options);
        }
        slot.sprites = null;
      }
      for (var i = 0, n = this.slotContainers.length; i < n; i++) {
        this.slotContainers[i].destroy(options);
      }
      this.spineData = null;
      this.skeleton = null;
      this.slotContainers = null;
      this.stateData = null;
      this.state = null;
      this.tempClipContainers = null;
      _super.prototype.destroy.call(this, options);
    };
    SpineBase2.clippingPolygon = [];
    return SpineBase2;
  }(Container)
);
Object.defineProperty(SpineBase.prototype, "visible", {
  get: function() {
    return this._visible;
  },
  set: function(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});
var SpineDebugRenderer = (
  /** @class */
  function() {
    function SpineDebugRenderer2() {
      this.registeredSpines = /* @__PURE__ */ new Map();
      this.drawDebug = true;
      this.drawMeshHull = true;
      this.drawMeshTriangles = true;
      this.drawBones = true;
      this.drawPaths = true;
      this.drawBoundingBoxes = true;
      this.drawClipping = true;
      this.drawRegionAttachments = true;
      this.lineWidth = 1;
      this.regionAttachmentsColor = 30975;
      this.meshHullColor = 30975;
      this.meshTrianglesColor = 16763904;
      this.clippingPolygonColor = 16711935;
      this.boundingBoxesRectColor = 65280;
      this.boundingBoxesPolygonColor = 65280;
      this.boundingBoxesCircleColor = 65280;
      this.pathsCurveColor = 16711680;
      this.pathsLineColor = 16711935;
      this.skeletonXYColor = 16711680;
      this.bonesColor = 61132;
    }
    SpineDebugRenderer2.prototype.registerSpine = function(spine) {
      if (this.registeredSpines.has(spine)) {
        console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", spine);
      }
      var debugDisplayObjects = {
        parentDebugContainer: new Container(),
        bones: new Container(),
        skeletonXY: new Graphics(),
        regionAttachmentsShape: new Graphics(),
        meshTrianglesLine: new Graphics(),
        meshHullLine: new Graphics(),
        clippingPolygon: new Graphics(),
        boundingBoxesRect: new Graphics(),
        boundingBoxesCircle: new Graphics(),
        boundingBoxesPolygon: new Graphics(),
        pathsCurve: new Graphics(),
        pathsLine: new Graphics()
      };
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);
      debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);
      spine.addChild(debugDisplayObjects.parentDebugContainer);
      this.registeredSpines.set(spine, debugDisplayObjects);
    };
    SpineDebugRenderer2.prototype.renderDebug = function(spine) {
      if (!this.registeredSpines.has(spine)) {
        this.registerSpine(spine);
      }
      var debugDisplayObjects = this.registeredSpines.get(spine);
      debugDisplayObjects.skeletonXY.clear();
      debugDisplayObjects.regionAttachmentsShape.clear();
      debugDisplayObjects.meshTrianglesLine.clear();
      debugDisplayObjects.meshHullLine.clear();
      debugDisplayObjects.clippingPolygon.clear();
      debugDisplayObjects.boundingBoxesRect.clear();
      debugDisplayObjects.boundingBoxesCircle.clear();
      debugDisplayObjects.boundingBoxesPolygon.clear();
      debugDisplayObjects.pathsCurve.clear();
      debugDisplayObjects.pathsLine.clear();
      for (var len = debugDisplayObjects.bones.children.length; len > 0; len--) {
        debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });
      }
      var scale = spine.scale.x || spine.scale.y || 1;
      var lineWidth = this.lineWidth / scale;
      if (this.drawBones) {
        this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);
      }
      if (this.drawPaths) {
        this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);
      }
      if (this.drawBoundingBoxes) {
        this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);
      }
      if (this.drawClipping) {
        this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);
      }
      if (this.drawMeshHull || this.drawMeshTriangles) {
        this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);
      }
      if (this.drawRegionAttachments) {
        this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);
      }
    };
    SpineDebugRenderer2.prototype.drawBonesFunc = function(spine, debugDisplayObjects, lineWidth, scale) {
      var skeleton = spine.skeleton;
      var skeletonX = skeleton.x;
      var skeletonY = skeleton.y;
      var bones = skeleton.bones;
      debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);
      for (var i = 0, len = bones.length; i < len; i++) {
        var bone = bones[i], boneLen = bone.data.length, starX = skeletonX + bone.matrix.tx, starY = skeletonY + bone.matrix.ty, endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx, endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;
        if (bone.data.name === "root" || bone.data.parent === null) {
          continue;
        }
        var w = Math.abs(starX - endX), h = Math.abs(starY - endY), a2 = Math.pow(w, 2), b = h, b2 = Math.pow(h, 2), c = Math.sqrt(a2 + b2), c2 = Math.pow(c, 2), rad = Math.PI / 180, B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;
        if (c === 0) {
          continue;
        }
        var gp = new Graphics();
        debugDisplayObjects.bones.addChild(gp);
        var refRation = c / 50 / scale;
        gp.beginFill(this.bonesColor, 1);
        gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);
        gp.endFill();
        gp.x = starX;
        gp.y = starY;
        gp.pivot.y = c;
        var rotation = 0;
        if (starX < endX && starY < endY) {
          rotation = -B + 180 * rad;
        } else if (starX > endX && starY < endY) {
          rotation = 180 * rad + B;
        } else if (starX > endX && starY > endY) {
          rotation = -B;
        } else if (starX < endX && starY > endY) {
          rotation = B;
        } else if (starY === endY && starX < endX) {
          rotation = 90 * rad;
        } else if (starY === endY && starX > endX) {
          rotation = -90 * rad;
        } else if (starX === endX && starY < endY) {
          rotation = 180 * rad;
        } else if (starX === endX && starY > endY) {
          rotation = 0;
        }
        gp.rotation = rotation;
        gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);
        gp.beginFill(0, 0.6);
        gp.drawCircle(0, c, refRation * 1.2);
        gp.endFill();
      }
      var startDotSize = lineWidth * 3;
      debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);
      debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);
      debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);
      debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);
    };
    SpineDebugRenderer2.prototype.drawRegionAttachmentsFunc = function(spine, debugDisplayObjects, lineWidth) {
      var skeleton = spine.skeleton;
      var slots = skeleton.slots;
      debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);
      for (var i = 0, len = slots.length; i < len; i++) {
        var slot = slots[i], attachment = slot.getAttachment();
        if (attachment == null || attachment.type !== AttachmentType.Region) {
          continue;
        }
        var regionAttachment = attachment;
        var vertices = new Float32Array(8);
        regionAttachment === null || regionAttachment === void 0 ? void 0 : regionAttachment.updateOffset();
        regionAttachment.computeWorldVertices(slot, vertices, 0, 2);
        debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));
      }
    };
    SpineDebugRenderer2.prototype.drawMeshHullAndMeshTriangles = function(spine, debugDisplayObjects, lineWidth) {
      var skeleton = spine.skeleton;
      var slots = skeleton.slots;
      debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);
      debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);
      for (var i = 0, len = slots.length; i < len; i++) {
        var slot = slots[i];
        if (!slot.bone.active) {
          continue;
        }
        var attachment = slot.getAttachment();
        if (attachment == null || attachment.type !== AttachmentType.Mesh) {
          continue;
        }
        var meshAttachment = attachment;
        var vertices = new Float32Array(meshAttachment.worldVerticesLength), triangles = meshAttachment.triangles;
        var hullLength = meshAttachment.hullLength;
        meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);
        if (this.drawMeshTriangles) {
          for (var i_1 = 0, len_1 = triangles.length; i_1 < len_1; i_1 += 3) {
            var v1 = triangles[i_1] * 2, v2 = triangles[i_1 + 1] * 2, v3 = triangles[i_1 + 2] * 2;
            debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);
            debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);
            debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);
          }
        }
        if (this.drawMeshHull && hullLength > 0) {
          hullLength = (hullLength >> 1) * 2;
          var lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];
          for (var i_2 = 0, len_2 = hullLength; i_2 < len_2; i_2 += 2) {
            var x = vertices[i_2], y = vertices[i_2 + 1];
            debugDisplayObjects.meshHullLine.moveTo(x, y);
            debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);
            lastX = x;
            lastY = y;
          }
        }
      }
    };
    SpineDebugRenderer2.prototype.drawClippingFunc = function(spine, debugDisplayObjects, lineWidth) {
      var skeleton = spine.skeleton;
      var slots = skeleton.slots;
      debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);
      for (var i = 0, len = slots.length; i < len; i++) {
        var slot = slots[i];
        if (!slot.bone.active) {
          continue;
        }
        var attachment = slot.getAttachment();
        if (attachment == null || attachment.type !== AttachmentType.Clipping) {
          continue;
        }
        var clippingAttachment = attachment;
        var nn = clippingAttachment.worldVerticesLength, world = new Float32Array(nn);
        clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
        debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));
      }
    };
    SpineDebugRenderer2.prototype.drawBoundingBoxesFunc = function(spine, debugDisplayObjects, lineWidth) {
      var _this = this;
      debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);
      var bounds = new SkeletonBoundsBase();
      bounds.update(spine.skeleton, true);
      debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
      var polygons = bounds.polygons, drawPolygon = function(polygonVertices, _offset, count) {
        debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, _this.boundingBoxesPolygonColor, 1);
        debugDisplayObjects.boundingBoxesPolygon.beginFill(_this.boundingBoxesPolygonColor, 0.1);
        if (count < 3) {
          throw new Error("Polygon must contain at least 3 vertices");
        }
        var paths = [], dotSize = lineWidth * 2;
        for (var i2 = 0, len2 = polygonVertices.length; i2 < len2; i2 += 2) {
          var x1 = polygonVertices[i2], y1 = polygonVertices[i2 + 1];
          debugDisplayObjects.boundingBoxesCircle.lineStyle(0);
          debugDisplayObjects.boundingBoxesCircle.beginFill(_this.boundingBoxesCircleColor);
          debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);
          debugDisplayObjects.boundingBoxesCircle.endFill();
          paths.push(x1, y1);
        }
        debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);
        debugDisplayObjects.boundingBoxesPolygon.endFill();
      };
      for (var i = 0, len = polygons.length; i < len; i++) {
        var polygon = polygons[i];
        drawPolygon(polygon, 0, polygon.length);
      }
    };
    SpineDebugRenderer2.prototype.drawPathsFunc = function(spine, debugDisplayObjects, lineWidth) {
      var skeleton = spine.skeleton;
      var slots = skeleton.slots;
      debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);
      debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);
      for (var i = 0, len = slots.length; i < len; i++) {
        var slot = slots[i];
        if (!slot.bone.active) {
          continue;
        }
        var attachment = slot.getAttachment();
        if (attachment == null || attachment.type !== AttachmentType.Path) {
          continue;
        }
        var pathAttachment = attachment;
        var nn = pathAttachment.worldVerticesLength;
        var world = new Float32Array(nn);
        pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
        var x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;
        if (pathAttachment.closed) {
          var cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];
          x2 = world[nn - 4];
          y2 = world[nn - 3];
          debugDisplayObjects.pathsCurve.moveTo(x1, y1);
          debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
          debugDisplayObjects.pathsLine.moveTo(x1, y1);
          debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
          debugDisplayObjects.pathsLine.moveTo(x2, y2);
          debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
        }
        nn -= 4;
        for (var ii = 4; ii < nn; ii += 6) {
          var cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];
          x2 = world[ii + 4];
          y2 = world[ii + 5];
          debugDisplayObjects.pathsCurve.moveTo(x1, y1);
          debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
          debugDisplayObjects.pathsLine.moveTo(x1, y1);
          debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
          debugDisplayObjects.pathsLine.moveTo(x2, y2);
          debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
          x1 = x2;
          y1 = y2;
        }
      }
    };
    SpineDebugRenderer2.prototype.unregisterSpine = function(spine) {
      if (!this.registeredSpines.has(spine)) {
        console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", spine);
      }
      var debugDisplayObjects = this.registeredSpines.get(spine);
      debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });
      this.registeredSpines.delete(spine);
    };
    return SpineDebugRenderer2;
  }()
);

// node_modules/@pixi-spine/loader-base/lib/loader-base.es.js
function isJson(resource) {
  return resource.type === LoaderResource.TYPE.JSON;
}
function isBuffer(resource) {
  return resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER;
}
LoaderResource.setExtensionXhrType("skel", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var AbstractSpineParser = (
  /** @class */
  function() {
    function AbstractSpineParser2() {
    }
    AbstractSpineParser2.prototype.genMiddleware = function() {
      var self = this;
      return {
        use: function(resource, next) {
          if (!resource.data) {
            return next();
          }
          var isJsonSpineModel = isJson(resource) && resource.data.bones;
          var isBinarySpineModel = isBuffer(resource) && (resource.extension === "skel" || resource.metadata && resource.metadata.spineMetadata);
          if (!isJsonSpineModel && !isBinarySpineModel) {
            return next();
          }
          var parser = null;
          var dataToParse = resource.data;
          if (isJsonSpineModel) {
            parser = self.createJsonParser();
          } else {
            parser = self.createBinaryParser();
            if (resource.data instanceof ArrayBuffer) {
              dataToParse = new Uint8Array(resource.data);
            }
          }
          var metadata = resource.metadata || {};
          var metadataSkeletonScale = metadata ? metadata.spineSkeletonScale : null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          var metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas === false) {
            return next();
          }
          if (metadataAtlas && metadataAtlas.pages) {
            self.parseData(resource, parser, metadataAtlas, dataToParse);
            return next();
          }
          var metadataAtlasSuffix = metadata.spineAtlasSuffix || ".atlas";
          var atlasPath = resource.url;
          var queryStringPos = atlasPath.indexOf("?");
          if (queryStringPos > 0) {
            atlasPath = atlasPath.substr(0, queryStringPos);
          }
          atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf(".")) + metadataAtlasSuffix;
          if (metadata.spineAtlasFile) {
            atlasPath = metadata.spineAtlasFile;
          }
          atlasPath = atlasPath.replace(this.baseUrl, "");
          var atlasOptions = {
            crossOrigin: resource.crossOrigin,
            xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,
            metadata: metadata.spineMetadata || null,
            parentResource: resource
          };
          var imageOptions = {
            crossOrigin: resource.crossOrigin,
            metadata: metadata.imageMetadata || null,
            parentResource: resource
          };
          var baseUrl = resource.url.substr(0, resource.url.lastIndexOf("/") + 1);
          baseUrl = baseUrl.replace(this.baseUrl, "");
          var namePrefix = metadata.imageNamePrefix || resource.name + "_atlas_page_";
          var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({ "default": metadata.image }) : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions) : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);
          function createSkeletonWithRawAtlas(rawData) {
            new TextureAtlas(rawData, adapter, function(spineAtlas) {
              if (spineAtlas) {
                self.parseData(resource, parser, spineAtlas, dataToParse);
              }
              next();
            });
          }
          if (metadata.atlasRawData) {
            createSkeletonWithRawAtlas(metadata.atlasRawData);
          } else {
            this.add(resource.name + "_atlas", atlasPath, atlasOptions, function(atlasResource) {
              if (!atlasResource.error) {
                createSkeletonWithRawAtlas(atlasResource.data);
              } else {
                next();
              }
            });
          }
        }
      };
    };
    return AbstractSpineParser2;
  }()
);
function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
  if (baseUrl && baseUrl.lastIndexOf("/") !== baseUrl.length - 1) {
    baseUrl += "/";
  }
  return function(line, callback) {
    var name = namePrefix + line;
    var url = baseUrl + line;
    var cachedResource = loader.resources[name];
    if (cachedResource) {
      var done = function() {
        callback(cachedResource.texture.baseTexture);
      };
      if (cachedResource.texture) {
        done();
      } else {
        cachedResource.onAfterMiddleware.add(done);
      }
    } else {
      loader.add(name, url, imageOptions, function(resource) {
        if (!resource.error) {
          if (line.indexOf("-pma.") >= 0) {
            resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;
          }
          callback(resource.texture.baseTexture);
        } else {
          callback(null);
        }
      });
    }
  };
}
function staticImageLoader(pages) {
  return function(line, callback) {
    var page = pages[line] || pages["default"];
    if (page && page.baseTexture)
      callback(page.baseTexture);
    else
      callback(page);
  };
}

// node_modules/@pixi-spine/runtime-3.8/lib/runtime-3.8.es.js
var runtime_3_8_es_exports = {};
__export(runtime_3_8_es_exports, {
  Animation: () => Animation,
  AnimationState: () => AnimationState,
  AnimationStateAdapter: () => AnimationStateAdapter,
  AnimationStateData: () => AnimationStateData,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader,
  Attachment: () => Attachment,
  AttachmentTimeline: () => AttachmentTimeline,
  Bone: () => Bone,
  BoneData: () => BoneData,
  BoundingBoxAttachment: () => BoundingBoxAttachment,
  ClippingAttachment: () => ClippingAttachment,
  ColorTimeline: () => ColorTimeline,
  ConstraintData: () => ConstraintData,
  CurveTimeline: () => CurveTimeline,
  DeformTimeline: () => DeformTimeline,
  DrawOrderTimeline: () => DrawOrderTimeline,
  Event: () => Event,
  EventData: () => EventData,
  EventQueue: () => EventQueue,
  EventTimeline: () => EventTimeline,
  EventType: () => EventType,
  IkConstraint: () => IkConstraint,
  IkConstraintData: () => IkConstraintData,
  IkConstraintTimeline: () => IkConstraintTimeline,
  JitterEffect: () => JitterEffect,
  MeshAttachment: () => MeshAttachment,
  PathAttachment: () => PathAttachment,
  PathConstraint: () => PathConstraint,
  PathConstraintData: () => PathConstraintData,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline,
  PointAttachment: () => PointAttachment,
  RegionAttachment: () => RegionAttachment,
  RotateTimeline: () => RotateTimeline,
  ScaleTimeline: () => ScaleTimeline,
  ShearTimeline: () => ShearTimeline,
  Skeleton: () => Skeleton,
  SkeletonBinary: () => SkeletonBinary,
  SkeletonBounds: () => SkeletonBounds,
  SkeletonData: () => SkeletonData,
  SkeletonJson: () => SkeletonJson,
  Skin: () => Skin,
  SkinEntry: () => SkinEntry,
  Slot: () => Slot,
  SlotData: () => SlotData,
  SpacingMode: () => SpacingMode,
  Spine: () => Spine,
  SwirlEffect: () => SwirlEffect,
  TimelineType: () => TimelineType,
  TrackEntry: () => TrackEntry,
  TransformConstraint: () => TransformConstraint,
  TransformConstraintData: () => TransformConstraintData,
  TransformConstraintTimeline: () => TransformConstraintTimeline,
  TranslateTimeline: () => TranslateTimeline,
  TwoColorTimeline: () => TwoColorTimeline,
  VertexAttachment: () => VertexAttachment
});
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Attachment = (
  /** @class */
  /* @__PURE__ */ function() {
    function Attachment4(name) {
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment4;
  }()
);
var VertexAttachment = (
  /** @class */
  function(_super) {
    __extends2(VertexAttachment4, _super);
    function VertexAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.id = (VertexAttachment4.nextID++ & 65535) << 11;
      _this.worldVerticesLength = 0;
      _this.deformAttachment = _this;
      return _this;
    }
    VertexAttachment4.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment4.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.deform;
      var vertices = this.vertices;
      var bones = this.bones;
      if (bones == null) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y = mat.ty;
        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
        for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
          var vx = vertices[v_1], vy = vertices[v_1 + 1];
          worldVertices[w] = vx * a + vy * b + x;
          worldVertices[w + 1] = vx * c + vy * d + y;
        }
        return;
      }
      var v = 0, skip = 0;
      for (var i = 0; i < start; i += 2) {
        var n = bones[v];
        v += n + 1;
        skip += n;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w = offset, b = skip * 3; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3, f += 2) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      }
    };
    VertexAttachment4.prototype.copyTo = function(attachment) {
      if (this.bones != null) {
        attachment.bones = new Array(this.bones.length);
        Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
      } else
        attachment.bones = null;
      if (this.vertices != null) {
        attachment.vertices = Utils.newFloatArray(this.vertices.length);
        Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
      } else
        attachment.vertices = null;
      attachment.worldVerticesLength = this.worldVerticesLength;
      attachment.deformAttachment = this.deformAttachment;
    };
    VertexAttachment4.nextID = 0;
    return VertexAttachment4;
  }(Attachment)
);
var BoundingBoxAttachment = (
  /** @class */
  function(_super) {
    __extends2(BoundingBoxAttachment4, _super);
    function BoundingBoxAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    BoundingBoxAttachment4.prototype.copy = function() {
      var copy = new BoundingBoxAttachment4(this.name);
      this.copyTo(copy);
      copy.color.setFromColor(this.color);
      return copy;
    };
    return BoundingBoxAttachment4;
  }(VertexAttachment)
);
var ClippingAttachment = (
  /** @class */
  function(_super) {
    __extends2(ClippingAttachment4, _super);
    function ClippingAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    ClippingAttachment4.prototype.copy = function() {
      var copy = new ClippingAttachment4(this.name);
      this.copyTo(copy);
      copy.endSlot = this.endSlot;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return ClippingAttachment4;
  }(VertexAttachment)
);
var MeshAttachment = (
  /** @class */
  function(_super) {
    __extends2(MeshAttachment4, _super);
    function MeshAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.color = new Color(1, 1, 1, 1);
      _this.tempColor = new Color(0, 0, 0, 0);
      return _this;
    }
    MeshAttachment4.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment4.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh != null) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    MeshAttachment4.prototype.copy = function() {
      if (this.parentMesh != null)
        return this.newLinkedMesh();
      var copy = new MeshAttachment4(this.name);
      copy.region = this.region;
      copy.path = this.path;
      copy.color.setFromColor(this.color);
      this.copyTo(copy);
      copy.regionUVs = new Float32Array(this.regionUVs.length);
      Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
      copy.triangles = new Array(this.triangles.length);
      Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
      copy.hullLength = this.hullLength;
      if (this.edges != null) {
        copy.edges = new Array(this.edges.length);
        Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
      }
      copy.width = this.width;
      copy.height = this.height;
      return copy;
    };
    MeshAttachment4.prototype.newLinkedMesh = function() {
      var copy = new MeshAttachment4(this.name);
      copy.region = this.region;
      copy.path = this.path;
      copy.color.setFromColor(this.color);
      copy.deformAttachment = this.deformAttachment;
      copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
      return copy;
    };
    return MeshAttachment4;
  }(VertexAttachment)
);
var PathAttachment = (
  /** @class */
  function(_super) {
    __extends2(PathAttachment4, _super);
    function PathAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    PathAttachment4.prototype.copy = function() {
      var copy = new PathAttachment4(this.name);
      this.copyTo(copy);
      copy.lengths = new Array(this.lengths.length);
      Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
      copy.closed = closed;
      copy.constantSpeed = this.constantSpeed;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return PathAttachment4;
  }(VertexAttachment)
);
var PointAttachment = (
  /** @class */
  function(_super) {
    __extends2(PointAttachment4, _super);
    function PointAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment4.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment4.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y = cos * mat.b + sin * mat.d;
      return Math.atan2(y, x) * MathUtils.radDeg;
    };
    PointAttachment4.prototype.copy = function() {
      var copy = new PointAttachment4(this.name);
      copy.x = this.x;
      copy.y = this.y;
      copy.rotation = this.rotation;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return PointAttachment4;
  }(VertexAttachment)
);
var Slot = (
  /** @class */
  function() {
    function Slot4(data, bone) {
      this.deform = new Array();
      if (data == null)
        throw new Error("data cannot be null.");
      if (bone == null)
        throw new Error("bone cannot be null.");
      this.data = data;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = data.darkColor == null ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot4.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot4.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      this.attachment = attachment;
      this.attachmentTime = this.bone.skeleton.time;
      this.deform.length = 0;
    };
    Slot4.prototype.setAttachmentTime = function(time) {
      this.attachmentTime = this.bone.skeleton.time - time;
    };
    Slot4.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    Slot4.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor != null)
        this.darkColor.setFromColor(this.data.darkColor);
      if (this.data.attachmentName == null)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot4;
  }()
);
var RegionAttachment = (
  /** @class */
  function(_super) {
    __extends2(RegionAttachment4, _super);
    function RegionAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      return _this;
    }
    RegionAttachment4.prototype.updateOffset = function() {
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var localXCos = localX * cos + this.x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + this.y;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + this.x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + this.y;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[RegionAttachment4.OX1] = localXCos - localYSin;
      offset[RegionAttachment4.OY1] = localYCos + localXSin;
      offset[RegionAttachment4.OX2] = localXCos - localY2Sin;
      offset[RegionAttachment4.OY2] = localY2Cos + localXSin;
      offset[RegionAttachment4.OX3] = localX2Cos - localY2Sin;
      offset[RegionAttachment4.OY3] = localY2Cos + localX2Sin;
      offset[RegionAttachment4.OX4] = localX2Cos - localYSin;
      offset[RegionAttachment4.OY4] = localYCos + localX2Sin;
    };
    RegionAttachment4.prototype.setRegion = function(region) {
      this.region = region;
      var uvs = this.uvs;
      if (region.rotate) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment4.prototype.computeWorldVertices = function(bone, worldVertices, offset, stride) {
      var vertexOffset = this.offset;
      var mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;
      var x = mat.tx, y = mat.ty;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[RegionAttachment4.OX1];
      offsetY = vertexOffset[RegionAttachment4.OY1];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX2];
      offsetY = vertexOffset[RegionAttachment4.OY2];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX3];
      offsetY = vertexOffset[RegionAttachment4.OY3];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX4];
      offsetY = vertexOffset[RegionAttachment4.OY4];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    };
    RegionAttachment4.prototype.copy = function() {
      var copy = new RegionAttachment4(this.name);
      copy.region = this.region;
      copy.rendererObject = this.rendererObject;
      copy.path = this.path;
      copy.x = this.x;
      copy.y = this.y;
      copy.scaleX = this.scaleX;
      copy.scaleY = this.scaleY;
      copy.rotation = this.rotation;
      copy.width = this.width;
      copy.height = this.height;
      Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
      Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
      copy.color.setFromColor(this.color);
      return copy;
    };
    RegionAttachment4.OX1 = 0;
    RegionAttachment4.OY1 = 1;
    RegionAttachment4.OX2 = 2;
    RegionAttachment4.OY2 = 3;
    RegionAttachment4.OX3 = 4;
    RegionAttachment4.OY3 = 5;
    RegionAttachment4.OX4 = 6;
    RegionAttachment4.OY4 = 7;
    RegionAttachment4.X1 = 0;
    RegionAttachment4.Y1 = 1;
    RegionAttachment4.C1R = 2;
    RegionAttachment4.C1G = 3;
    RegionAttachment4.C1B = 4;
    RegionAttachment4.C1A = 5;
    RegionAttachment4.U1 = 6;
    RegionAttachment4.V1 = 7;
    RegionAttachment4.X2 = 8;
    RegionAttachment4.Y2 = 9;
    RegionAttachment4.C2R = 10;
    RegionAttachment4.C2G = 11;
    RegionAttachment4.C2B = 12;
    RegionAttachment4.C2A = 13;
    RegionAttachment4.U2 = 14;
    RegionAttachment4.V2 = 15;
    RegionAttachment4.X3 = 16;
    RegionAttachment4.Y3 = 17;
    RegionAttachment4.C3R = 18;
    RegionAttachment4.C3G = 19;
    RegionAttachment4.C3B = 20;
    RegionAttachment4.C3A = 21;
    RegionAttachment4.U3 = 22;
    RegionAttachment4.V3 = 23;
    RegionAttachment4.X4 = 24;
    RegionAttachment4.Y4 = 25;
    RegionAttachment4.C4R = 26;
    RegionAttachment4.C4G = 27;
    RegionAttachment4.C4B = 28;
    RegionAttachment4.C4A = 29;
    RegionAttachment4.U4 = 30;
    RegionAttachment4.V4 = 31;
    return RegionAttachment4;
  }(Attachment)
);
var JitterEffect = (
  /** @class */
  function() {
    function JitterEffect3(jitterX, jitterY) {
      this.jitterX = 0;
      this.jitterY = 0;
      this.jitterX = jitterX;
      this.jitterY = jitterY;
    }
    JitterEffect3.prototype.begin = function(skeleton) {
    };
    JitterEffect3.prototype.transform = function(position, uv, light, dark) {
      position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    JitterEffect3.prototype.end = function() {
    };
    return JitterEffect3;
  }()
);
var SwirlEffect = (
  /** @class */
  function() {
    function SwirlEffect3(radius) {
      this.centerX = 0;
      this.centerY = 0;
      this.radius = 0;
      this.angle = 0;
      this.worldX = 0;
      this.worldY = 0;
      this.radius = radius;
    }
    SwirlEffect3.prototype.begin = function(skeleton) {
      this.worldX = skeleton.x + this.centerX;
      this.worldY = skeleton.y + this.centerY;
    };
    SwirlEffect3.prototype.transform = function(position, uv, light, dark) {
      var radAngle = this.angle * MathUtils.degreesToRadians;
      var x = position.x - this.worldX;
      var y = position.y - this.worldY;
      var dist = Math.sqrt(x * x + y * y);
      if (dist < this.radius) {
        var theta = SwirlEffect3.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
        var cos = Math.cos(theta);
        var sin = Math.sin(theta);
        position.x = cos * x - sin * y + this.worldX;
        position.y = sin * x + cos * y + this.worldY;
      }
    };
    SwirlEffect3.prototype.end = function() {
    };
    SwirlEffect3.interpolation = new PowOut(2);
    return SwirlEffect3;
  }()
);
var Animation = (
  /** @class */
  function() {
    function Animation4(name, timelines, duration) {
      if (name == null)
        throw new Error("name cannot be null.");
      if (timelines == null)
        throw new Error("timelines cannot be null.");
      this.name = name;
      this.timelines = timelines;
      this.timelineIds = [];
      for (var i = 0; i < timelines.length; i++)
        this.timelineIds[timelines[i].getPropertyId()] = true;
      this.duration = duration;
    }
    Animation4.prototype.hasTimeline = function(id) {
      return this.timelineIds[id] == true;
    };
    Animation4.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime > 0)
          lastTime %= this.duration;
      }
      var timelines = this.timelines;
      for (var i = 0, n = timelines.length; i < n; i++)
        timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
    };
    Animation4.binarySearch = function(values, target, step) {
      if (step === void 0) {
        step = 1;
      }
      var low = 0;
      var high = values.length / step - 2;
      if (high == 0)
        return step;
      var current = high >>> 1;
      while (true) {
        if (values[(current + 1) * step] <= target)
          low = current + 1;
        else
          high = current;
        if (low == high)
          return (low + 1) * step;
        current = low + high >>> 1;
      }
    };
    Animation4.linearSearch = function(values, target, step) {
      for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target)
          return i;
      return -1;
    };
    return Animation4;
  }()
);
var TimelineType;
(function(TimelineType3) {
  TimelineType3[TimelineType3["rotate"] = 0] = "rotate";
  TimelineType3[TimelineType3["translate"] = 1] = "translate";
  TimelineType3[TimelineType3["scale"] = 2] = "scale";
  TimelineType3[TimelineType3["shear"] = 3] = "shear";
  TimelineType3[TimelineType3["attachment"] = 4] = "attachment";
  TimelineType3[TimelineType3["color"] = 5] = "color";
  TimelineType3[TimelineType3["deform"] = 6] = "deform";
  TimelineType3[TimelineType3["event"] = 7] = "event";
  TimelineType3[TimelineType3["drawOrder"] = 8] = "drawOrder";
  TimelineType3[TimelineType3["ikConstraint"] = 9] = "ikConstraint";
  TimelineType3[TimelineType3["transformConstraint"] = 10] = "transformConstraint";
  TimelineType3[TimelineType3["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType3[TimelineType3["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType3[TimelineType3["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType3[TimelineType3["twoColor"] = 14] = "twoColor";
})(TimelineType || (TimelineType = {}));
var CurveTimeline = (
  /** @class */
  function() {
    function CurveTimeline4(frameCount) {
      if (frameCount <= 0)
        throw new Error("frameCount must be > 0: " + frameCount);
      this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline4.BEZIER_SIZE);
    }
    CurveTimeline4.prototype.getFrameCount = function() {
      return this.curves.length / CurveTimeline4.BEZIER_SIZE + 1;
    };
    CurveTimeline4.prototype.setLinear = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline4.BEZIER_SIZE] = CurveTimeline4.LINEAR;
    };
    CurveTimeline4.prototype.setStepped = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline4.BEZIER_SIZE] = CurveTimeline4.STEPPED;
    };
    CurveTimeline4.prototype.getCurveType = function(frameIndex) {
      var index = frameIndex * CurveTimeline4.BEZIER_SIZE;
      if (index == this.curves.length)
        return CurveTimeline4.LINEAR;
      var type = this.curves[index];
      if (type == CurveTimeline4.LINEAR)
        return CurveTimeline4.LINEAR;
      if (type == CurveTimeline4.STEPPED)
        return CurveTimeline4.STEPPED;
      return CurveTimeline4.BEZIER;
    };
    CurveTimeline4.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
      var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
      var dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3, dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
      var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
      var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
      var i = frameIndex * CurveTimeline4.BEZIER_SIZE;
      var curves = this.curves;
      curves[i++] = CurveTimeline4.BEZIER;
      var x = dfx, y = dfy;
      for (var n = i + CurveTimeline4.BEZIER_SIZE - 1; i < n; i += 2) {
        curves[i] = x;
        curves[i + 1] = y;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        x += dfx;
        y += dfy;
      }
    };
    CurveTimeline4.prototype.getCurvePercent = function(frameIndex, percent) {
      percent = MathUtils.clamp(percent, 0, 1);
      var curves = this.curves;
      var i = frameIndex * CurveTimeline4.BEZIER_SIZE;
      var type = curves[i];
      if (type == CurveTimeline4.LINEAR)
        return percent;
      if (type == CurveTimeline4.STEPPED)
        return 0;
      i++;
      var x = 0;
      for (var start = i, n = i + CurveTimeline4.BEZIER_SIZE - 1; i < n; i += 2) {
        x = curves[i];
        if (x >= percent) {
          var prevX = void 0, prevY = void 0;
          if (i == start) {
            prevX = 0;
            prevY = 0;
          } else {
            prevX = curves[i - 2];
            prevY = curves[i - 1];
          }
          return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
        }
      }
      var y = curves[i - 1];
      return y + (1 - y) * (percent - x) / (1 - x);
    };
    CurveTimeline4.LINEAR = 0;
    CurveTimeline4.STEPPED = 1;
    CurveTimeline4.BEZIER = 2;
    CurveTimeline4.BEZIER_SIZE = 10 * 2 - 1;
    return CurveTimeline4;
  }()
);
var RotateTimeline = (
  /** @class */
  function(_super) {
    __extends2(RotateTimeline4, _super);
    function RotateTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount << 1);
      return _this;
    }
    RotateTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.rotate << 24) + this.boneIndex;
    };
    RotateTimeline4.prototype.setFrame = function(frameIndex, time, degrees) {
      frameIndex <<= 1;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + RotateTimeline4.ROTATION] = degrees;
    };
    RotateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            var r_1 = bone.data.rotation - bone.rotation;
            bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha;
        }
        return;
      }
      if (time >= frames[frames.length - RotateTimeline4.ENTRIES]) {
        var r_2 = frames[frames.length + RotateTimeline4.PREV_ROTATION];
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation + r_2 * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            r_2 += bone.data.rotation - bone.rotation;
            r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;
          case MixBlend.add:
            bone.rotation += r_2 * alpha;
        }
        return;
      }
      var frame = Animation.binarySearch(frames, time, RotateTimeline4.ENTRIES);
      var prevRotation = frames[frame + RotateTimeline4.PREV_ROTATION];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline4.PREV_TIME] - frameTime));
      var r = frames[frame + RotateTimeline4.ROTATION] - prevRotation;
      r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
      }
    };
    RotateTimeline4.ENTRIES = 2;
    RotateTimeline4.PREV_TIME = -2;
    RotateTimeline4.PREV_ROTATION = -1;
    RotateTimeline4.ROTATION = 1;
    return RotateTimeline4;
  }(CurveTimeline)
);
var TranslateTimeline = (
  /** @class */
  function(_super) {
    __extends2(TranslateTimeline4, _super);
    function TranslateTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TranslateTimeline4.ENTRIES);
      return _this;
    }
    TranslateTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.translate << 24) + this.boneIndex;
    };
    TranslateTimeline4.prototype.setFrame = function(frameIndex, time, x, y) {
      frameIndex *= TranslateTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TranslateTimeline4.X] = x;
      this.frames[frameIndex + TranslateTimeline4.Y] = y;
    };
    TranslateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha;
            bone.y += (bone.data.y - bone.y) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - TranslateTimeline4.ENTRIES]) {
        x = frames[frames.length + TranslateTimeline4.PREV_X];
        y = frames[frames.length + TranslateTimeline4.PREV_Y];
      } else {
        var frame = Animation.binarySearch(frames, time, TranslateTimeline4.ENTRIES);
        x = frames[frame + TranslateTimeline4.PREV_X];
        y = frames[frame + TranslateTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TranslateTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline4.PREV_TIME] - frameTime));
        x += (frames[frame + TranslateTimeline4.X] - x) * percent;
        y += (frames[frame + TranslateTimeline4.Y] - y) * percent;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha;
          bone.y = bone.data.y + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha;
          bone.y += (bone.data.y + y - bone.y) * alpha;
          break;
        case MixBlend.add:
          bone.x += x * alpha;
          bone.y += y * alpha;
      }
    };
    TranslateTimeline4.ENTRIES = 3;
    TranslateTimeline4.PREV_TIME = -3;
    TranslateTimeline4.PREV_X = -2;
    TranslateTimeline4.PREV_Y = -1;
    TranslateTimeline4.X = 1;
    TranslateTimeline4.Y = 2;
    return TranslateTimeline4;
  }(CurveTimeline)
);
var ScaleTimeline = (
  /** @class */
  function(_super) {
    __extends2(ScaleTimeline4, _super);
    function ScaleTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ScaleTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.scale << 24) + this.boneIndex;
    };
    ScaleTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - ScaleTimeline4.ENTRIES]) {
        x = frames[frames.length + ScaleTimeline4.PREV_X] * bone.data.scaleX;
        y = frames[frames.length + ScaleTimeline4.PREV_Y] * bone.data.scaleY;
      } else {
        var frame = Animation.binarySearch(frames, time, ScaleTimeline4.ENTRIES);
        x = frames[frame + ScaleTimeline4.PREV_X];
        y = frames[frame + ScaleTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ScaleTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline4.PREV_TIME] - frameTime));
        x = (x + (frames[frame + ScaleTimeline4.X] - x) * percent) * bone.data.scaleX;
        y = (y + (frames[frame + ScaleTimeline4.Y] - y) * percent) * bone.data.scaleY;
      }
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.add:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.add:
              bx = MathUtils.signum(x);
              by = MathUtils.signum(y);
              bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
              bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
          }
        }
      }
    };
    return ScaleTimeline4;
  }(TranslateTimeline)
);
var ShearTimeline = (
  /** @class */
  function(_super) {
    __extends2(ShearTimeline4, _super);
    function ShearTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ShearTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.shear << 24) + this.boneIndex;
    };
    ShearTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - ShearTimeline4.ENTRIES]) {
        x = frames[frames.length + ShearTimeline4.PREV_X];
        y = frames[frames.length + ShearTimeline4.PREV_Y];
      } else {
        var frame = Animation.binarySearch(frames, time, ShearTimeline4.ENTRIES);
        x = frames[frame + ShearTimeline4.PREV_X];
        y = frames[frame + ShearTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ShearTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline4.PREV_TIME] - frameTime));
        x = x + (frames[frame + ShearTimeline4.X] - x) * percent;
        y = y + (frames[frame + ShearTimeline4.Y] - y) * percent;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha;
          bone.shearY = bone.data.shearY + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha;
          bone.shearY += y * alpha;
      }
    };
    return ShearTimeline4;
  }(TranslateTimeline)
);
var ColorTimeline = (
  /** @class */
  function(_super) {
    __extends2(ColorTimeline3, _super);
    function ColorTimeline3(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * ColorTimeline3.ENTRIES);
      return _this;
    }
    ColorTimeline3.prototype.getPropertyId = function() {
      return (TimelineType.color << 24) + this.slotIndex;
    };
    ColorTimeline3.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
      frameIndex *= ColorTimeline3.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + ColorTimeline3.R] = r;
      this.frames[frameIndex + ColorTimeline3.G] = g;
      this.frames[frameIndex + ColorTimeline3.B] = b;
      this.frames[frameIndex + ColorTimeline3.A] = a;
    };
    ColorTimeline3.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            return;
          case MixBlend.first:
            var color = slot.color, setup = slot.data.color;
            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0;
      if (time >= frames[frames.length - ColorTimeline3.ENTRIES]) {
        var i = frames.length;
        r = frames[i + ColorTimeline3.PREV_R];
        g = frames[i + ColorTimeline3.PREV_G];
        b = frames[i + ColorTimeline3.PREV_B];
        a = frames[i + ColorTimeline3.PREV_A];
      } else {
        var frame = Animation.binarySearch(frames, time, ColorTimeline3.ENTRIES);
        r = frames[frame + ColorTimeline3.PREV_R];
        g = frames[frame + ColorTimeline3.PREV_G];
        b = frames[frame + ColorTimeline3.PREV_B];
        a = frames[frame + ColorTimeline3.PREV_A];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ColorTimeline3.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline3.PREV_TIME] - frameTime));
        r += (frames[frame + ColorTimeline3.R] - r) * percent;
        g += (frames[frame + ColorTimeline3.G] - g) * percent;
        b += (frames[frame + ColorTimeline3.B] - b) * percent;
        a += (frames[frame + ColorTimeline3.A] - a) * percent;
      }
      if (alpha == 1)
        slot.color.set(r, g, b, a);
      else {
        var color = slot.color;
        if (blend == MixBlend.setup)
          color.setFromColor(slot.data.color);
        color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
      }
    };
    ColorTimeline3.ENTRIES = 5;
    ColorTimeline3.PREV_TIME = -5;
    ColorTimeline3.PREV_R = -4;
    ColorTimeline3.PREV_G = -3;
    ColorTimeline3.PREV_B = -2;
    ColorTimeline3.PREV_A = -1;
    ColorTimeline3.R = 1;
    ColorTimeline3.G = 2;
    ColorTimeline3.B = 3;
    ColorTimeline3.A = 4;
    return ColorTimeline3;
  }(CurveTimeline)
);
var TwoColorTimeline = (
  /** @class */
  function(_super) {
    __extends2(TwoColorTimeline3, _super);
    function TwoColorTimeline3(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline3.ENTRIES);
      return _this;
    }
    TwoColorTimeline3.prototype.getPropertyId = function() {
      return (TimelineType.twoColor << 24) + this.slotIndex;
    };
    TwoColorTimeline3.prototype.setFrame = function(frameIndex, time, r, g, b, a, r2, g2, b2) {
      frameIndex *= TwoColorTimeline3.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TwoColorTimeline3.R] = r;
      this.frames[frameIndex + TwoColorTimeline3.G] = g;
      this.frames[frameIndex + TwoColorTimeline3.B] = b;
      this.frames[frameIndex + TwoColorTimeline3.A] = a;
      this.frames[frameIndex + TwoColorTimeline3.R2] = r2;
      this.frames[frameIndex + TwoColorTimeline3.G2] = g2;
      this.frames[frameIndex + TwoColorTimeline3.B2] = b2;
    };
    TwoColorTimeline3.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            slot.darkColor.setFromColor(slot.data.darkColor);
            return;
          case MixBlend.first:
            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
      if (time >= frames[frames.length - TwoColorTimeline3.ENTRIES]) {
        var i = frames.length;
        r = frames[i + TwoColorTimeline3.PREV_R];
        g = frames[i + TwoColorTimeline3.PREV_G];
        b = frames[i + TwoColorTimeline3.PREV_B];
        a = frames[i + TwoColorTimeline3.PREV_A];
        r2 = frames[i + TwoColorTimeline3.PREV_R2];
        g2 = frames[i + TwoColorTimeline3.PREV_G2];
        b2 = frames[i + TwoColorTimeline3.PREV_B2];
      } else {
        var frame = Animation.binarySearch(frames, time, TwoColorTimeline3.ENTRIES);
        r = frames[frame + TwoColorTimeline3.PREV_R];
        g = frames[frame + TwoColorTimeline3.PREV_G];
        b = frames[frame + TwoColorTimeline3.PREV_B];
        a = frames[frame + TwoColorTimeline3.PREV_A];
        r2 = frames[frame + TwoColorTimeline3.PREV_R2];
        g2 = frames[frame + TwoColorTimeline3.PREV_G2];
        b2 = frames[frame + TwoColorTimeline3.PREV_B2];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TwoColorTimeline3.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline3.PREV_TIME] - frameTime));
        r += (frames[frame + TwoColorTimeline3.R] - r) * percent;
        g += (frames[frame + TwoColorTimeline3.G] - g) * percent;
        b += (frames[frame + TwoColorTimeline3.B] - b) * percent;
        a += (frames[frame + TwoColorTimeline3.A] - a) * percent;
        r2 += (frames[frame + TwoColorTimeline3.R2] - r2) * percent;
        g2 += (frames[frame + TwoColorTimeline3.G2] - g2) * percent;
        b2 += (frames[frame + TwoColorTimeline3.B2] - b2) * percent;
      }
      if (alpha == 1) {
        slot.color.set(r, g, b, a);
        slot.darkColor.set(r2, g2, b2, 1);
      } else {
        var light = slot.color, dark = slot.darkColor;
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          dark.setFromColor(slot.data.darkColor);
        }
        light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
        dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
      }
    };
    TwoColorTimeline3.ENTRIES = 8;
    TwoColorTimeline3.PREV_TIME = -8;
    TwoColorTimeline3.PREV_R = -7;
    TwoColorTimeline3.PREV_G = -6;
    TwoColorTimeline3.PREV_B = -5;
    TwoColorTimeline3.PREV_A = -4;
    TwoColorTimeline3.PREV_R2 = -3;
    TwoColorTimeline3.PREV_G2 = -2;
    TwoColorTimeline3.PREV_B2 = -1;
    TwoColorTimeline3.R = 1;
    TwoColorTimeline3.G = 2;
    TwoColorTimeline3.B = 3;
    TwoColorTimeline3.A = 4;
    TwoColorTimeline3.R2 = 5;
    TwoColorTimeline3.G2 = 6;
    TwoColorTimeline3.B2 = 7;
    return TwoColorTimeline3;
  }(CurveTimeline)
);
var AttachmentTimeline = (
  /** @class */
  function() {
    function AttachmentTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.attachmentNames = new Array(frameCount);
    }
    AttachmentTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.attachment << 24) + this.slotIndex;
    };
    AttachmentTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline4.prototype.setFrame = function(frameIndex, time, attachmentName) {
      this.frames[frameIndex] = time;
      this.attachmentNames[frameIndex] = attachmentName;
    };
    AttachmentTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      var frameIndex = 0;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation.binarySearch(frames, time, 1) - 1;
      var attachmentName = this.attachmentNames[frameIndex];
      skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    AttachmentTimeline4.prototype.setAttachment = function(skeleton, slot, attachmentName) {
      slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline4;
  }()
);
var zeros = null;
var DeformTimeline = (
  /** @class */
  function(_super) {
    __extends2(DeformTimeline4, _super);
    function DeformTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount);
      _this.frameVertices = new Array(frameCount);
      if (zeros == null)
        zeros = Utils.newFloatArray(64);
      return _this;
    }
    DeformTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    DeformTimeline4.prototype.setFrame = function(frameIndex, time, vertices) {
      this.frames[frameIndex] = time;
      this.frameVertices[frameIndex] = vertices;
    };
    DeformTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.getAttachment();
      if (!(slotAttachment instanceof VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))
        return;
      var deformArray = slot.deform;
      if (deformArray.length == 0)
        blend = MixBlend.setup;
      var frameVertices = this.frameVertices;
      var vertexCount = frameVertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        var vertexAttachment = slotAttachment;
        switch (blend) {
          case MixBlend.setup:
            deformArray.length = 0;
            return;
          case MixBlend.first:
            if (alpha == 1) {
              deformArray.length = 0;
              break;
            }
            var deform_1 = Utils.setArraySize(deformArray, vertexCount);
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++)
                deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;
            } else {
              alpha = 1 - alpha;
              for (var i = 0; i < vertexCount; i++)
                deform_1[i] *= alpha;
            }
        }
        return;
      }
      var deform = Utils.setArraySize(deformArray, vertexCount);
      if (time >= frames[frames.length - 1]) {
        var lastVertices = frameVertices[frames.length - 1];
        if (alpha == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_1 = 0; i_1 < vertexCount; i_1++) {
                deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
              }
            } else {
              for (var i_2 = 0; i_2 < vertexCount; i_2++)
                deform[i_2] += lastVertices[i_2];
            }
          } else {
            Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
          }
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (vertexAttachment_1.bones == null) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                  var setup = setupVertices[i_3];
                  deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;
                }
              } else {
                for (var i_4 = 0; i_4 < vertexCount; i_4++)
                  deform[i_4] = lastVertices[i_4] * alpha;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i_5 = 0; i_5 < vertexCount; i_5++)
                deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;
              break;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (vertexAttachment.bones == null) {
                var setupVertices = vertexAttachment.vertices;
                for (var i_6 = 0; i_6 < vertexCount; i_6++) {
                  deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;
                }
              } else {
                for (var i_7 = 0; i_7 < vertexCount; i_7++)
                  deform[i_7] += lastVertices[i_7] * alpha;
              }
          }
        }
        return;
      }
      var frame = Animation.binarySearch(frames, time);
      var prevVertices = frameVertices[frame - 1];
      var nextVertices = frameVertices[frame];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            var setupVertices = vertexAttachment.vertices;
            for (var i_8 = 0; i_8 < vertexCount; i_8++) {
              var prev = prevVertices[i_8];
              deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];
            }
          } else {
            for (var i_9 = 0; i_9 < vertexCount; i_9++) {
              var prev = prevVertices[i_9];
              deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;
            }
          }
        } else {
          for (var i_10 = 0; i_10 < vertexCount; i_10++) {
            var prev = prevVertices[i_10];
            deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (vertexAttachment_2.bones == null) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i_11 = 0; i_11 < vertexCount; i_11++) {
                var prev = prevVertices[i_11], setup = setupVertices[i_11];
                deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;
              }
            } else {
              for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                var prev = prevVertices[i_12];
                deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i_13 = 0; i_13 < vertexCount; i_13++) {
              var prev = prevVertices[i_13];
              deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_14 = 0; i_14 < vertexCount; i_14++) {
                var prev = prevVertices[i_14];
                deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;
              }
            } else {
              for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                var prev = prevVertices[i_15];
                deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;
              }
            }
        }
      }
    };
    return DeformTimeline4;
  }(CurveTimeline)
);
var EventTimeline = (
  /** @class */
  function() {
    function EventTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.events = new Array(frameCount);
    }
    EventTimeline4.prototype.getPropertyId = function() {
      return TimelineType.event << 24;
    };
    EventTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline4.prototype.setFrame = function(frameIndex, event) {
      this.frames[frameIndex] = event.time;
      this.events[frameIndex] = event;
    };
    EventTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (firedEvents == null)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
        lastTime = -1;
      } else if (lastTime >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var frame = 0;
      if (lastTime < frames[0])
        frame = 0;
      else {
        frame = Animation.binarySearch(frames, lastTime);
        var frameTime = frames[frame];
        while (frame > 0) {
          if (frames[frame - 1] != frameTime)
            break;
          frame--;
        }
      }
      for (; frame < frameCount && time >= frames[frame]; frame++)
        firedEvents.push(this.events[frame]);
    };
    return EventTimeline4;
  }()
);
var DrawOrderTimeline = (
  /** @class */
  function() {
    function DrawOrderTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.drawOrders = new Array(frameCount);
    }
    DrawOrderTimeline4.prototype.getPropertyId = function() {
      return TimelineType.drawOrder << 24;
    };
    DrawOrderTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline4.prototype.setFrame = function(frameIndex, time, drawOrder) {
      this.frames[frameIndex] = time;
      this.drawOrders[frameIndex] = drawOrder;
    };
    DrawOrderTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var drawOrder = skeleton.drawOrder;
      var slots = skeleton.slots;
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frame = 0;
      if (time >= frames[frames.length - 1])
        frame = frames.length - 1;
      else
        frame = Animation.binarySearch(frames, time) - 1;
      var drawOrderToSetupIndex = this.drawOrders[frame];
      if (drawOrderToSetupIndex == null)
        Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
      else {
        for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
          drawOrder[i] = slots[drawOrderToSetupIndex[i]];
      }
    };
    return DrawOrderTimeline4;
  }()
);
var IkConstraintTimeline = (
  /** @class */
  function(_super) {
    __extends2(IkConstraintTimeline4, _super);
    function IkConstraintTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline4.ENTRIES);
      return _this;
    }
    IkConstraintTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
    };
    IkConstraintTimeline4.prototype.setFrame = function(frameIndex, time, mix, softness, bendDirection, compress, stretch) {
      frameIndex *= IkConstraintTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + IkConstraintTimeline4.MIX] = mix;
      this.frames[frameIndex + IkConstraintTimeline4.SOFTNESS] = softness;
      this.frames[frameIndex + IkConstraintTimeline4.BEND_DIRECTION] = bendDirection;
      this.frames[frameIndex + IkConstraintTimeline4.COMPRESS] = compress ? 1 : 0;
      this.frames[frameIndex + IkConstraintTimeline4.STRETCH] = stretch ? 1 : 0;
    };
    IkConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.softness = constraint.data.softness;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      if (time >= frames[frames.length - IkConstraintTimeline4.ENTRIES]) {
        if (blend == MixBlend.setup) {
          constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline4.PREV_MIX] - constraint.data.mix) * alpha;
          constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline4.PREV_SOFTNESS] - constraint.data.softness) * alpha;
          if (direction == MixDirection.mixOut) {
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
          } else {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline4.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline4.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline4.PREV_STRETCH] != 0;
          }
        } else {
          constraint.mix += (frames[frames.length + IkConstraintTimeline4.PREV_MIX] - constraint.mix) * alpha;
          constraint.softness += (frames[frames.length + IkConstraintTimeline4.PREV_SOFTNESS] - constraint.softness) * alpha;
          if (direction == MixDirection.mixIn) {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline4.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline4.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline4.PREV_STRETCH] != 0;
          }
        }
        return;
      }
      var frame = Animation.binarySearch(frames, time, IkConstraintTimeline4.ENTRIES);
      var mix = frames[frame + IkConstraintTimeline4.PREV_MIX];
      var softness = frames[frame + IkConstraintTimeline4.PREV_SOFTNESS];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent(frame / IkConstraintTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline4.PREV_TIME] - frameTime));
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline4.MIX] - mix) * percent - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (softness + (frames[frame + IkConstraintTimeline4.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frame + IkConstraintTimeline4.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame + IkConstraintTimeline4.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame + IkConstraintTimeline4.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (mix + (frames[frame + IkConstraintTimeline4.MIX] - mix) * percent - constraint.mix) * alpha;
        constraint.softness += (softness + (frames[frame + IkConstraintTimeline4.SOFTNESS] - softness) * percent - constraint.softness) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frame + IkConstraintTimeline4.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame + IkConstraintTimeline4.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame + IkConstraintTimeline4.PREV_STRETCH] != 0;
        }
      }
    };
    IkConstraintTimeline4.ENTRIES = 6;
    IkConstraintTimeline4.PREV_TIME = -6;
    IkConstraintTimeline4.PREV_MIX = -5;
    IkConstraintTimeline4.PREV_SOFTNESS = -4;
    IkConstraintTimeline4.PREV_BEND_DIRECTION = -3;
    IkConstraintTimeline4.PREV_COMPRESS = -2;
    IkConstraintTimeline4.PREV_STRETCH = -1;
    IkConstraintTimeline4.MIX = 1;
    IkConstraintTimeline4.SOFTNESS = 2;
    IkConstraintTimeline4.BEND_DIRECTION = 3;
    IkConstraintTimeline4.COMPRESS = 4;
    IkConstraintTimeline4.STRETCH = 5;
    return IkConstraintTimeline4;
  }(CurveTimeline)
);
var TransformConstraintTimeline = (
  /** @class */
  function(_super) {
    __extends2(TransformConstraintTimeline4, _super);
    function TransformConstraintTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline4.ENTRIES);
      return _this;
    }
    TransformConstraintTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
    };
    TransformConstraintTimeline4.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
      frameIndex *= TransformConstraintTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TransformConstraintTimeline4.ROTATE] = rotateMix;
      this.frames[frameIndex + TransformConstraintTimeline4.TRANSLATE] = translateMix;
      this.frames[frameIndex + TransformConstraintTimeline4.SCALE] = scaleMix;
      this.frames[frameIndex + TransformConstraintTimeline4.SHEAR] = shearMix;
    };
    TransformConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        var data = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = data.rotateMix;
            constraint.translateMix = data.translateMix;
            constraint.scaleMix = data.scaleMix;
            constraint.shearMix = data.shearMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
        }
        return;
      }
      var rotate = 0, translate = 0, scale = 0, shear = 0;
      if (time >= frames[frames.length - TransformConstraintTimeline4.ENTRIES]) {
        var i = frames.length;
        rotate = frames[i + TransformConstraintTimeline4.PREV_ROTATE];
        translate = frames[i + TransformConstraintTimeline4.PREV_TRANSLATE];
        scale = frames[i + TransformConstraintTimeline4.PREV_SCALE];
        shear = frames[i + TransformConstraintTimeline4.PREV_SHEAR];
      } else {
        var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline4.ENTRIES);
        rotate = frames[frame + TransformConstraintTimeline4.PREV_ROTATE];
        translate = frames[frame + TransformConstraintTimeline4.PREV_TRANSLATE];
        scale = frames[frame + TransformConstraintTimeline4.PREV_SCALE];
        shear = frames[frame + TransformConstraintTimeline4.PREV_SHEAR];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TransformConstraintTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline4.PREV_TIME] - frameTime));
        rotate += (frames[frame + TransformConstraintTimeline4.ROTATE] - rotate) * percent;
        translate += (frames[frame + TransformConstraintTimeline4.TRANSLATE] - translate) * percent;
        scale += (frames[frame + TransformConstraintTimeline4.SCALE] - scale) * percent;
        shear += (frames[frame + TransformConstraintTimeline4.SHEAR] - shear) * percent;
      }
      if (blend == MixBlend.setup) {
        var data = constraint.data;
        constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
        constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
        constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
        constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
        constraint.translateMix += (translate - constraint.translateMix) * alpha;
        constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
        constraint.shearMix += (shear - constraint.shearMix) * alpha;
      }
    };
    TransformConstraintTimeline4.ENTRIES = 5;
    TransformConstraintTimeline4.PREV_TIME = -5;
    TransformConstraintTimeline4.PREV_ROTATE = -4;
    TransformConstraintTimeline4.PREV_TRANSLATE = -3;
    TransformConstraintTimeline4.PREV_SCALE = -2;
    TransformConstraintTimeline4.PREV_SHEAR = -1;
    TransformConstraintTimeline4.ROTATE = 1;
    TransformConstraintTimeline4.TRANSLATE = 2;
    TransformConstraintTimeline4.SCALE = 3;
    TransformConstraintTimeline4.SHEAR = 4;
    return TransformConstraintTimeline4;
  }(CurveTimeline)
);
var PathConstraintPositionTimeline = (
  /** @class */
  function(_super) {
    __extends2(PathConstraintPositionTimeline4, _super);
    function PathConstraintPositionTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline4.ENTRIES);
      return _this;
    }
    PathConstraintPositionTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    PathConstraintPositionTimeline4.prototype.setFrame = function(frameIndex, time, value) {
      frameIndex *= PathConstraintPositionTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintPositionTimeline4.VALUE] = value;
    };
    PathConstraintPositionTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha;
        }
        return;
      }
      var position = 0;
      if (time >= frames[frames.length - PathConstraintPositionTimeline4.ENTRIES])
        position = frames[frames.length + PathConstraintPositionTimeline4.PREV_VALUE];
      else {
        var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline4.ENTRIES);
        position = frames[frame + PathConstraintPositionTimeline4.PREV_VALUE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline4.PREV_TIME] - frameTime));
        position += (frames[frame + PathConstraintPositionTimeline4.VALUE] - position) * percent;
      }
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
      else
        constraint.position += (position - constraint.position) * alpha;
    };
    PathConstraintPositionTimeline4.ENTRIES = 2;
    PathConstraintPositionTimeline4.PREV_TIME = -2;
    PathConstraintPositionTimeline4.PREV_VALUE = -1;
    PathConstraintPositionTimeline4.VALUE = 1;
    return PathConstraintPositionTimeline4;
  }(CurveTimeline)
);
var PathConstraintSpacingTimeline = (
  /** @class */
  function(_super) {
    __extends2(PathConstraintSpacingTimeline4, _super);
    function PathConstraintSpacingTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    PathConstraintSpacingTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    PathConstraintSpacingTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
        }
        return;
      }
      var spacing = 0;
      if (time >= frames[frames.length - PathConstraintSpacingTimeline4.ENTRIES])
        spacing = frames[frames.length + PathConstraintSpacingTimeline4.PREV_VALUE];
      else {
        var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline4.ENTRIES);
        spacing = frames[frame + PathConstraintSpacingTimeline4.PREV_VALUE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline4.PREV_TIME] - frameTime));
        spacing += (frames[frame + PathConstraintSpacingTimeline4.VALUE] - spacing) * percent;
      }
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha;
    };
    return PathConstraintSpacingTimeline4;
  }(PathConstraintPositionTimeline)
);
var PathConstraintMixTimeline = (
  /** @class */
  function(_super) {
    __extends2(PathConstraintMixTimeline4, _super);
    function PathConstraintMixTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline4.ENTRIES);
      return _this;
    }
    PathConstraintMixTimeline4.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    PathConstraintMixTimeline4.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
      frameIndex *= PathConstraintMixTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintMixTimeline4.ROTATE] = rotateMix;
      this.frames[frameIndex + PathConstraintMixTimeline4.TRANSLATE] = translateMix;
    };
    PathConstraintMixTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = constraint.data.rotateMix;
            constraint.translateMix = constraint.data.translateMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
        }
        return;
      }
      var rotate = 0, translate = 0;
      if (time >= frames[frames.length - PathConstraintMixTimeline4.ENTRIES]) {
        rotate = frames[frames.length + PathConstraintMixTimeline4.PREV_ROTATE];
        translate = frames[frames.length + PathConstraintMixTimeline4.PREV_TRANSLATE];
      } else {
        var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline4.ENTRIES);
        rotate = frames[frame + PathConstraintMixTimeline4.PREV_ROTATE];
        translate = frames[frame + PathConstraintMixTimeline4.PREV_TRANSLATE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintMixTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline4.PREV_TIME] - frameTime));
        rotate += (frames[frame + PathConstraintMixTimeline4.ROTATE] - rotate) * percent;
        translate += (frames[frame + PathConstraintMixTimeline4.TRANSLATE] - translate) * percent;
      }
      if (blend == MixBlend.setup) {
        constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
        constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
        constraint.translateMix += (translate - constraint.translateMix) * alpha;
      }
    };
    PathConstraintMixTimeline4.ENTRIES = 3;
    PathConstraintMixTimeline4.PREV_TIME = -3;
    PathConstraintMixTimeline4.PREV_ROTATE = -2;
    PathConstraintMixTimeline4.PREV_TRANSLATE = -1;
    PathConstraintMixTimeline4.ROTATE = 1;
    PathConstraintMixTimeline4.TRANSLATE = 2;
    return PathConstraintMixTimeline4;
  }(CurveTimeline)
);
var AnimationState = (
  /** @class */
  function() {
    function AnimationState4(data) {
      this.tracks = new Array();
      this.timeScale = 1;
      this.unkeyedState = 0;
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue(this);
      this.propertyIDs = new IntSet();
      this.animationsChanged = false;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry();
      });
      this.data = data;
    }
    AnimationState4.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i = 0, n = tracks.length; i < n; i++) {
        var current = tracks[i];
        if (current == null)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next = current.next;
        if (next != null) {
          var nextTime = current.trackLast - next.delay;
          if (nextTime >= 0) {
            next.delay = 0;
            next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i, next, true);
            while (next.mixingFrom != null) {
              next.mixTime += delta;
              next = next.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
          tracks[i] = null;
          this.queue.end(current);
          this.disposeNext(current);
          continue;
        }
        if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
          var from = current.mixingFrom;
          current.mixingFrom = null;
          if (from != null)
            from.mixingTo = null;
          while (from != null) {
            this.queue.end(from);
            from = from.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState4.prototype.updateMixingFrom = function(to, delta) {
      var from = to.mixingFrom;
      if (from == null)
        return true;
      var finished = this.updateMixingFrom(from, delta);
      from.animationLast = from.nextAnimationLast;
      from.trackLast = from.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from.mixingFrom;
          if (from.mixingFrom != null)
            from.mixingFrom.mixingTo = to;
          to.interruptAlpha = from.interruptAlpha;
          this.queue.end(from);
        }
        return finished;
      }
      from.trackTime += delta * from.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState4.prototype.apply = function(skeleton) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i_1 = 0, n_1 = tracks.length; i_1 < n_1; i_1++) {
        var current = tracks[i_1];
        if (current == null || current.delay > 0)
          continue;
        applied = true;
        var blend = i_1 == 0 ? MixBlend.first : current.mixBlend;
        var mix = current.alpha;
        if (current.mixingFrom != null)
          mix *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && current.next == null)
          mix = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime();
        var timelineCount = current.animation.timelines.length;
        var timelines = current.animation.timelines;
        if (i_1 == 0 && mix == 1 || blend == MixBlend.add) {
          for (var ii = 0; ii < timelineCount; ii++) {
            Utils.webkit602BugfixHelper(mix, blend);
            var timeline = timelines[ii];
            if (timeline instanceof AttachmentTimeline)
              this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
            else
              timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var firstFrame = current.timelinesRotation.length == 0;
          if (firstFrame)
            Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = current.timelinesRotation;
          for (var ii = 0; ii < timelineCount; ii++) {
            var timeline_1 = timelines[ii];
            var timelineBlend = timelineMode[ii] == AnimationState4.SUBSEQUENT ? blend : MixBlend.setup;
            if (timeline_1 instanceof RotateTimeline) {
              this.applyRotateTimeline(timeline_1, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
            } else if (timeline_1 instanceof AttachmentTimeline) {
              this.applyAttachmentTimeline(timeline_1, skeleton, animationTime, blend, true);
            } else {
              Utils.webkit602BugfixHelper(mix, blend);
              timeline_1.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      var setupState = this.unkeyedState + AnimationState4.SETUP;
      var slots = skeleton.slots;
      for (var i = 0, n = skeleton.slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.attachmentState == setupState) {
          var attachmentName = slot.data.attachmentName;
          slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
        }
      }
      this.unkeyedState += 2;
      this.queue.drain();
      return applied;
    };
    AnimationState4.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from = to.mixingFrom;
      if (from.mixingFrom != null)
        this.applyMixingFrom(from, skeleton, blend);
      var mix = 0;
      if (to.mixDuration == 0) {
        mix = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix = to.mixTime / to.mixDuration;
        if (mix > 1)
          mix = 1;
        if (blend != MixBlend.first)
          blend = from.mixBlend;
      }
      var events = mix < from.eventThreshold ? this.events : null;
      var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
      var animationLast = from.animationLast, animationTime = from.getAnimationTime();
      var timelineCount = from.animation.timelines.length;
      var timelines = from.animation.timelines;
      var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
      if (blend == MixBlend.add) {
        for (var i = 0; i < timelineCount; i++)
          timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from.timelineMode;
        var timelineHoldMix = from.timelineHoldMix;
        var firstFrame = from.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
        var timelinesRotation = from.timelinesRotation;
        from.totalAlpha = 0;
        for (var i = 0; i < timelineCount; i++) {
          var timeline = timelines[i];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha = 0;
          switch (timelineMode[i]) {
            case AnimationState4.SUBSEQUENT:
              if (!drawOrder && timeline instanceof DrawOrderTimeline)
                continue;
              timelineBlend = blend;
              alpha = alphaMix;
              break;
            case AnimationState4.FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaMix;
              break;
            case AnimationState4.HOLD_SUBSEQUENT:
              timelineBlend = blend;
              alpha = alphaHold;
              break;
            case AnimationState4.HOLD_FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i];
              alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from.totalAlpha += alpha;
          if (timeline instanceof RotateTimeline)
            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
          else if (timeline instanceof AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);
          else {
            Utils.webkit602BugfixHelper(alpha, blend);
            if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)
              direction = MixDirection.mixIn;
            timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from, animationTime);
      this.events.length = 0;
      from.nextAnimationLast = animationTime;
      from.nextTrackLast = from.trackTime;
      return mix;
    };
    AnimationState4.prototype.applyAttachmentTimeline = function(timeline, skeleton, time, blend, attachments) {
      var slot = skeleton.slots[timeline.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = timeline.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
      } else {
        var frameIndex;
        if (time >= frames[frames.length - 1])
          frameIndex = frames.length - 1;
        else
          frameIndex = Animation.binarySearch(frames, time) - 1;
        this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
      }
      if (slot.attachmentState <= this.unkeyedState)
        slot.attachmentState = this.unkeyedState + AnimationState4.SETUP;
    };
    AnimationState4.prototype.setAttachment = function(skeleton, slot, attachmentName, attachments) {
      slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      if (attachments)
        slot.attachmentState = this.unkeyedState + AnimationState4.CURRENT;
    };
    AnimationState4.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
      if (firstFrame)
        timelinesRotation[i] = 0;
      if (alpha == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var rotateTimeline = timeline;
      var frames = rotateTimeline.frames;
      var bone = skeleton.bones[rotateTimeline.boneIndex];
      if (!bone.active)
        return;
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        if (time >= frames[frames.length - RotateTimeline.ENTRIES])
          r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];
        else {
          var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
          var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
          var frameTime = frames[frame];
          var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
          r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          r2 = prevRotation + r2 * percent + bone.data.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        }
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i];
          lastDiff = timelinesRotation[i + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i] = total;
      }
      timelinesRotation[i + 1] = diff;
      r1 += total * alpha;
      bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
    };
    AnimationState4.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i = 0, n = events.length;
      for (; i < n; i++) {
        var event_1 = events[i];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i < n; i++) {
        var event_2 = events[i];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, events[i]);
      }
    };
    AnimationState4.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++)
        this.clearTrack(i);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (current == null)
        return;
      this.queue.end(current);
      this.disposeNext(current);
      var entry = current;
      while (true) {
        var from = entry.mixingFrom;
        if (from == null)
          break;
        this.queue.end(from);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState4.prototype.setCurrent = function(index, current, interrupt) {
      var from = this.expandToIndex(index);
      this.tracks[index] = current;
      if (from != null) {
        if (interrupt)
          this.queue.interrupt(from);
        current.mixingFrom = from;
        from.mixingTo = current;
        current.mixTime = 0;
        if (from.mixingFrom != null && from.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
        from.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState4.prototype.setAnimation = function(trackIndex, animationName, loop) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (animation == null)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation, loop);
    };
    AnimationState4.prototype.setAnimationWith = function(trackIndex, animation, loop) {
      if (animation == null)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current != null) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.disposeNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.disposeNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState4.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (animation == null)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation, loop, delay);
    };
    AnimationState4.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
      if (animation == null)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last != null) {
        while (last.next != null)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation, loop, last);
      if (last == null) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        if (delay <= 0) {
          var duration = last.animationEnd - last.animationStart;
          if (duration != 0) {
            if (last.loop)
              delay += duration * (1 + (last.trackTime / duration | 0));
            else
              delay += Math.max(duration, last.trackTime);
            delay -= this.data.getMix(last.animation, animation);
          } else
            delay = last.trackTime;
        }
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      var entry = this.setAnimationWith(trackIndex, AnimationState4.emptyAnimation, false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (delay <= 0)
        delay -= mixDuration;
      var entry = this.addAnimationWith(trackIndex, AnimationState4.emptyAnimation, false, delay);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimations = function(mixDuration) {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++) {
        var current = this.tracks[i];
        if (current != null)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.expandToIndex = function(index) {
      if (index < this.tracks.length)
        return this.tracks[index];
      Utils.ensureArrayCapacity(this.tracks, index + 1, null);
      this.tracks.length = index + 1;
      return null;
    };
    AnimationState4.prototype.trackEntry = function(trackIndex, animation, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.trackIndex = trackIndex;
      entry.animation = animation;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.interruptAlpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
      entry.mixBlend = MixBlend.replace;
      return entry;
    };
    AnimationState4.prototype.disposeNext = function(entry) {
      var next = entry.next;
      while (next != null) {
        this.queue.dispose(next);
        next = next.next;
      }
      entry.next = null;
    };
    AnimationState4.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      for (var i = 0, n = this.tracks.length; i < n; i++) {
        var entry = this.tracks[i];
        if (entry == null)
          continue;
        while (entry.mixingFrom != null)
          entry = entry.mixingFrom;
        do {
          if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
            this.computeHold(entry);
          entry = entry.mixingTo;
        } while (entry != null);
      }
    };
    AnimationState4.prototype.computeHold = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
      entry.timelineHoldMix.length = 0;
      var timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
      var propertyIDs = this.propertyIDs;
      if (to != null && to.holdPrevious) {
        for (var i = 0; i < timelinesCount; i++) {
          timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState4.HOLD_FIRST : AnimationState4.HOLD_SUBSEQUENT;
        }
        return;
      }
      outer: for (var i = 0; i < timelinesCount; i++) {
        var timeline = timelines[i];
        var id = timeline.getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = AnimationState4.SUBSEQUENT;
        else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {
          timelineMode[i] = AnimationState4.FIRST;
        } else {
          for (var next = to.mixingTo; next != null; next = next.mixingTo) {
            if (next.animation.hasTimeline(id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = AnimationState4.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = AnimationState4.HOLD_FIRST;
        }
      }
    };
    AnimationState4.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState4.prototype.addListener = function(listener) {
      if (listener == null)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState4.prototype.removeListener = function(listener) {
      var index = this.listeners.indexOf(listener);
      if (index >= 0)
        this.listeners.splice(index, 1);
    };
    AnimationState4.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState4.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState4.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState4.deprecatedWarning1) {
        AnimationState4.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState4.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState4.deprecatedWarning2) {
        AnimationState4.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState4.prototype.hasAnimation = function(animationName) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      return animation !== null;
    };
    AnimationState4.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState4.deprecatedWarning3) {
        AnimationState4.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState4.emptyAnimation = new Animation("<empty>", [], 0);
    AnimationState4.SUBSEQUENT = 0;
    AnimationState4.FIRST = 1;
    AnimationState4.HOLD_SUBSEQUENT = 2;
    AnimationState4.HOLD_FIRST = 3;
    AnimationState4.HOLD_MIX = 4;
    AnimationState4.SETUP = 1;
    AnimationState4.CURRENT = 2;
    AnimationState4.deprecatedWarning1 = false;
    AnimationState4.deprecatedWarning2 = false;
    AnimationState4.deprecatedWarning3 = false;
    return AnimationState4;
  }()
);
var TrackEntry = (
  /** @class */
  function() {
    function TrackEntry4() {
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry4.prototype.reset = function() {
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry4.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry4.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry4.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry4.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    Object.defineProperty(TrackEntry4.prototype, "time", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry4.prototype, "endTime", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry4.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry4.deprecatedWarning1 = false;
    TrackEntry4.deprecatedWarning2 = false;
    return TrackEntry4;
  }()
);
var EventQueue = (
  /** @class */
  function() {
    function EventQueue4(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue4.prototype.start = function(entry) {
      this.objects.push(EventType.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.interrupt = function(entry) {
      this.objects.push(EventType.interrupt);
      this.objects.push(entry);
    };
    EventQueue4.prototype.end = function(entry) {
      this.objects.push(EventType.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.dispose = function(entry) {
      this.objects.push(EventType.dispose);
      this.objects.push(entry);
    };
    EventQueue4.prototype.complete = function(entry) {
      this.objects.push(EventType.complete);
      this.objects.push(entry);
    };
    EventQueue4.prototype.event = function(entry, event) {
      this.objects.push(EventType.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue4.prototype.deprecateStuff = function() {
      if (!EventQueue4.deprecatedWarning1) {
        EventQueue4.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'");
      }
      return true;
    };
    EventQueue4.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i = 0; i < objects.length; i += 2) {
        var type = objects[i];
        var entry = objects[i + 1];
        switch (type) {
          case EventType.start:
            if (entry.listener != null && entry.listener.start)
              entry.listener.start(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].start)
                listeners[ii].start(entry);
            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
            break;
          case EventType.interrupt:
            if (entry.listener != null && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].interrupt)
                listeners[ii].interrupt(entry);
            break;
          case EventType.end:
            if (entry.listener != null && entry.listener.end)
              entry.listener.end(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].end)
                listeners[ii].end(entry);
            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
          case EventType.dispose:
            if (entry.listener != null && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].dispose)
                listeners[ii].dispose(entry);
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType.complete:
            if (entry.listener != null && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].complete)
                listeners[ii].complete(entry);
            var count = MathUtils.toInt(entry.loopsCount());
            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
            break;
          case EventType.event:
            var event_3 = objects[i++ + 2];
            if (entry.listener != null && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].event)
                listeners[ii].event(entry, event_3);
            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue4.prototype.clear = function() {
      this.objects.length = 0;
    };
    EventQueue4.deprecatedWarning1 = false;
    return EventQueue4;
  }()
);
var EventType;
(function(EventType4) {
  EventType4[EventType4["start"] = 0] = "start";
  EventType4[EventType4["interrupt"] = 1] = "interrupt";
  EventType4[EventType4["end"] = 2] = "end";
  EventType4[EventType4["dispose"] = 3] = "dispose";
  EventType4[EventType4["complete"] = 4] = "complete";
  EventType4[EventType4["event"] = 5] = "event";
})(EventType || (EventType = {}));
var AnimationStateAdapter = (
  /** @class */
  function() {
    function AnimationStateAdapter4() {
    }
    AnimationStateAdapter4.prototype.start = function(entry) {
    };
    AnimationStateAdapter4.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter4.prototype.end = function(entry) {
    };
    AnimationStateAdapter4.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter4.prototype.complete = function(entry) {
    };
    AnimationStateAdapter4.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter4;
  }()
);
var AnimationStateData = (
  /** @class */
  function() {
    function AnimationStateData4(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (skeletonData == null)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData4.prototype.setMix = function(fromName, toName, duration) {
      var from = this.skeletonData.findAnimation(fromName);
      if (from == null)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (to == null)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from, to, duration);
    };
    AnimationStateData4.prototype.setMixByName = function(fromName, toName, duration) {
      if (!AnimationStateData4.deprecatedWarning1) {
        AnimationStateData4.deprecatedWarning1 = true;
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
      }
      this.setMix(fromName, toName, duration);
    };
    AnimationStateData4.prototype.setMixWith = function(from, to, duration) {
      if (from == null)
        throw new Error("from cannot be null.");
      if (to == null)
        throw new Error("to cannot be null.");
      var key = from.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData4.prototype.getMix = function(from, to) {
      var key = from.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    AnimationStateData4.deprecatedWarning1 = false;
    return AnimationStateData4;
  }()
);
var AtlasAttachmentLoader = (
  /** @class */
  function() {
    function AtlasAttachmentLoader4(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader4.prototype.newRegionAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
      var attachment = new RegionAttachment(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newMeshAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
      var attachment = new MeshAttachment(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment(name);
    };
    AtlasAttachmentLoader4.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment(name);
    };
    AtlasAttachmentLoader4.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment(name);
    };
    AtlasAttachmentLoader4.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment(name);
    };
    return AtlasAttachmentLoader4;
  }()
);
var Bone = (
  /** @class */
  function() {
    function Bone4(data, skeleton, parent) {
      this.matrix = new Matrix();
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.appliedValid = false;
      this.sorted = false;
      this.active = false;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone4.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone4.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone4.prototype.isActive = function() {
      return this.active;
    };
    Bone4.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone4.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone4.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      this.appliedValid = true;
      var parent = this.parent;
      var m = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
      if (parent == null) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m.tx = x * sx + skeleton.x;
        m.ty = y * sy + skeleton.y;
        return;
      }
      var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
      m.tx = pa * x + pb * y + parent.matrix.tx;
      m.ty = pc * x + pd * y + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb = MathUtils.cosDeg(rotationY) * scaleY;
          var lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld = MathUtils.sinDeg(rotationY) * scaleY;
          m.a = pa * la + pb * lc;
          m.c = pa * lb + pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m.c = MathUtils.cosDeg(rotationY) * scaleY;
          m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s = pa * pa + pc * pc;
          var prx = 0;
          if (s > 1e-4) {
            s = Math.abs(pa * pd - pb * pc) / s;
            pa /= this.skeleton.scaleX;
            pc /= this.skeleton.scaleY;
            pb = pc * s;
            pd = pa * s;
            prx = Math.atan2(pc, pa) * MathUtils.radDeg;
          } else {
            pa = 0;
            pc = 0;
            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la = MathUtils.cosDeg(rx) * scaleX;
          var lb = MathUtils.cosDeg(ry) * scaleY;
          var lc = MathUtils.sinDeg(rx) * scaleX;
          var ld = MathUtils.sinDeg(ry) * scaleY;
          m.a = pa * la - pb * lc;
          m.c = pa * lb - pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za = (pa * cos + pb * sin) / sx;
          var zc = (pc * cos + pd * sin) / sy;
          var s = Math.sqrt(za * za + zc * zc);
          if (s > 1e-5)
            s = 1 / s;
          za *= s;
          zc *= s;
          s = Math.sqrt(za * za + zc * zc);
          if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
            s = -s;
          var r = Math.PI / 2 + Math.atan2(zc, za);
          var zb = Math.cos(r) * s;
          var zd = Math.sin(r) * s;
          var la = MathUtils.cosDeg(shearX) * scaleX;
          var lb = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc = MathUtils.sinDeg(shearX) * scaleX;
          var ld = MathUtils.sinDeg(90 + shearY) * scaleY;
          m.a = za * la + zb * lc;
          m.c = za * lb + zb * ld;
          m.b = zc * la + zd * lc;
          m.d = zc * lb + zd * ld;
          break;
        }
      }
      m.a *= sx;
      m.c *= sx;
      m.b *= sy;
      m.d *= sy;
    };
    Bone4.prototype.setToSetupPose = function() {
      var data = this.data;
      this.x = data.x;
      this.y = data.y;
      this.rotation = data.rotation;
      this.scaleX = data.scaleX;
      this.scaleY = data.scaleY;
      this.shearX = data.shearX;
      this.shearY = data.shearY;
    };
    Bone4.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldScaleX = function() {
      var m = this.matrix;
      return Math.sqrt(m.a * m.a + m.c * m.c);
    };
    Bone4.prototype.getWorldScaleY = function() {
      var m = this.matrix;
      return Math.sqrt(m.b * m.b + m.d * m.d);
    };
    Bone4.prototype.updateAppliedTransform = function() {
      this.appliedValid = true;
      var parent = this.parent;
      var m = this.matrix;
      if (parent == null) {
        this.ax = m.tx;
        this.ay = m.ty;
        this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
        this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m.tx - pm.tx, dy = m.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia = pid * pm.d;
      var id = pid * pm.a;
      var ib = pid * pm.c;
      var ic = pid * pm.b;
      var ra = ia * m.a - ib * m.b;
      var rb = ia * m.c - ib * m.d;
      var rc = id * m.b - ic * m.a;
      var rd = id * m.d - ic * m.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra * ra + rc * rc);
      if (this.ascaleX > 1e-4) {
        var det = ra * rd - rb * rc;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb * rb + rd * rd);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
      }
    };
    Bone4.prototype.worldToLocal = function(world) {
      var m = this.matrix;
      var a = m.a, b = m.c, c = m.b, d = m.d;
      var invDet = 1 / (a * d - b * c);
      var x = world.x - m.tx, y = world.y - m.ty;
      world.x = x * d * invDet - y * b * invDet;
      world.y = y * a * invDet - x * c * invDet;
      return world;
    };
    Bone4.prototype.localToWorld = function(local) {
      var m = this.matrix;
      var x = local.x, y = local.y;
      local.x = x * m.a + y * m.c + m.tx;
      local.y = x * m.b + y * m.d + m.ty;
      return local;
    };
    Bone4.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone4.prototype.localToWorldRotation = function(localRotation) {
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone4.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a - sin * c;
      mat.c = cos * b - sin * d;
      mat.b = sin * a + cos * c;
      mat.d = sin * b + cos * d;
      this.appliedValid = false;
    };
    return Bone4;
  }()
);
var BoneData = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoneData4(index, name, parent) {
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      this.skinRequired = false;
      this.color = new Color();
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      this.index = index;
      this.name = name;
      this.parent = parent;
    }
    return BoneData4;
  }()
);
var ConstraintData = (
  /** @class */
  /* @__PURE__ */ function() {
    function ConstraintData3(name, order, skinRequired) {
      this.name = name;
      this.order = order;
      this.skinRequired = skinRequired;
    }
    return ConstraintData3;
  }()
);
var Event = (
  /** @class */
  /* @__PURE__ */ function() {
    function Event4(time, data) {
      if (data == null)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data;
    }
    return Event4;
  }()
);
var EventData = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventData4(name) {
      this.name = name;
    }
    return EventData4;
  }()
);
var IkConstraint = (
  /** @class */
  function() {
    function IkConstraint4(data, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      this.softness = 0;
      this.active = false;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.mix = data.mix;
      this.softness = data.softness;
      this.bendDirection = data.bendDirection;
      this.compress = data.compress;
      this.stretch = data.stretch;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findBone(data.target.name);
    }
    IkConstraint4.prototype.isActive = function() {
      return this.active;
    };
    IkConstraint4.prototype.apply = function() {
      this.update();
    };
    IkConstraint4.prototype.update = function() {
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
          break;
      }
    };
    IkConstraint4.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha) {
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      var p = bone.parent.matrix;
      var pa = p.a, pb = p.c, pc = p.b, pd = p.d;
      var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
      switch (bone.data.transformMode) {
        case TransformMode.OnlyTranslation:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
          break;
        case TransformMode.NoRotationOrReflection:
          var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
          var sa = pa / bone.skeleton.scaleX;
          var sc = pc / bone.skeleton.scaleY;
          pb = -sc * s * bone.skeleton.scaleX;
          pd = sa * s * bone.skeleton.scaleY;
          rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
        default:
          var x = targetX - p.tx, y = targetY - p.ty;
          var d = pa * pd - pb * pc;
          tx = (x * pd - y * pb) / d - bone.ax;
          ty = (y * pa - x * pc) / d - bone.ay;
      }
      rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        switch (bone.data.transformMode) {
          case TransformMode.NoScale:
          case TransformMode.NoScaleOrReflection:
            tx = targetX - bone.worldX;
            ty = targetY - bone.worldY;
        }
        var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd < b || stretch && dd > b && b > 1e-4) {
          var s = (dd / b - 1) * alpha + 1;
          sx *= s;
          if (uniform)
            sy *= s;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint4.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
      if (alpha == 0) {
        child.updateWorldTransform();
        return;
      }
      if (!parent.appliedValid)
        parent.updateAppliedTransform();
      if (!child.appliedValid)
        child.updateAppliedTransform();
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;
      var u = Math.abs(psx - psy) <= 1e-4;
      if (!u) {
        cy = 0;
        cwx = a * cx + pmat.tx;
        cwy = c * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a * cx + b * cy + pmat.tx;
        cwy = c * cx + d * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      a = pp.a;
      b = pp.c;
      c = pp.b;
      d = pp.d;
      var id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;
      var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;
      if (l1 < 1e-4) {
        this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
        child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        return;
      }
      x = targetX - pp.tx;
      y = targetY - pp.ty;
      var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
      var dd = tx * tx + ty * ty;
      if (softness != 0) {
        softness *= psx * (csx + 1) / 2;
        var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;
        if (sd > 0) {
          var p = Math.min(1, sd / (softness * 2)) - 1;
          p = (sd - softness * (1 - p * p)) / td;
          tx -= p * tx;
          ty -= p * ty;
          dd = tx * tx + ty * ty;
        }
      }
      outer: if (u) {
        l2 *= psx;
        var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        var c1 = -2 * bb * l1, c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          var q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          var r0 = q / c2, r1 = c / q;
          var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        var minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
        var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
      rotation = child.arotation;
      a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a2 > 180)
        a2 -= 360;
      else if (a2 < -180)
        a2 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint4;
  }()
);
var IkConstraintData = (
  /** @class */
  function(_super) {
    __extends2(IkConstraintData4, _super);
    function IkConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this.bendDirection = 1;
      _this.compress = false;
      _this.stretch = false;
      _this.uniform = false;
      _this.mix = 1;
      _this.softness = 0;
      return _this;
    }
    return IkConstraintData4;
  }(ConstraintData)
);
var PathConstraintData = (
  /** @class */
  function(_super) {
    __extends2(PathConstraintData4, _super);
    function PathConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      return _this;
    }
    return PathConstraintData4;
  }(ConstraintData)
);
var SpacingMode;
(function(SpacingMode4) {
  SpacingMode4[SpacingMode4["Length"] = 0] = "Length";
  SpacingMode4[SpacingMode4["Fixed"] = 1] = "Fixed";
  SpacingMode4[SpacingMode4["Percent"] = 2] = "Percent";
})(SpacingMode || (SpacingMode = {}));
var PathConstraint = (
  /** @class */
  function() {
    function PathConstraint4(data, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.rotateMix = 0;
      this.translateMix = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      this.active = false;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0, n = data.bones.length; i < n; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findSlot(data.target.name);
      this.position = data.position;
      this.spacing = data.spacing;
      this.rotateMix = data.rotateMix;
      this.translateMix = data.translateMix;
    }
    PathConstraint4.prototype.isActive = function() {
      return this.active;
    };
    PathConstraint4.prototype.apply = function() {
      this.update();
    };
    PathConstraint4.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment))
        return;
      var rotateMix = this.rotateMix, translateMix = this.translateMix;
      var translate = translateMix > 0, rotate = rotateMix > 0;
      if (!translate && !rotate)
        return;
      var data = this.data;
      var spacingMode = data.spacingMode;
      var lengthSpacing = spacingMode == SpacingMode.Length;
      var rotateMode = data.rotateMode;
      var tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;
      var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var bones = this.bones;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = null;
      var spacing = this.spacing;
      if (scale || lengthSpacing) {
        if (scale)
          lengths = Utils.setArraySize(this.lengths, boneCount);
        for (var i = 0, n = spacesCount - 1; i < n; ) {
          var bone = bones[i];
          var setupLength = bone.data.length;
          if (setupLength < PathConstraint4.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = 0;
          } else {
            var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
            var length_1 = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length_1;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
          }
        }
      } else {
        for (var i = 1; i < spacesCount; i++)
          spaces[i] = spacing;
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
        var bone = bones[i];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * translateMix;
        mat.ty += (boneY - mat.ty) * translateMix;
        var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
        if (scale) {
          var length_2 = lengths[i];
          if (length_2 != 0) {
            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
            mat.a *= s;
            mat.b *= s;
          }
        }
        boneX = x;
        boneY = y;
        if (rotate) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
          r -= Math.atan2(c, a);
          if (tip) {
            cos = Math.cos(r);
            sin = Math.sin(r);
            var length_3 = bone.data.length;
            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
          } else {
            r += offsetRotation;
          }
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          cos = Math.cos(r);
          sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
        }
        bone.appliedValid = false;
      }
    };
    PathConstraint4.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
      var target = this.target;
      var position = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint4.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (percentPosition)
          position *= pathLength_1;
        if (percentSpacing) {
          for (var i = 0; i < spacesCount; i++)
            spaces[i] *= pathLength_1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
          var space = spaces[i];
          position += space;
          var p = position;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint4.BEFORE) {
              prevCurve = PathConstraint4.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint4.AFTER) {
              prevCurve = PathConstraint4.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o);
            continue;
          }
          for (; ; curve++) {
            var length_4 = lengths[curve];
            if (p > length_4)
              continue;
            if (curve == 0)
              p /= length_4;
            else {
              var prev = lengths[curve - 1];
              p = (p - prev) / (length_4 - prev);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
        cx1 = world[w];
        cy1 = world[w + 1];
        cx2 = world[w + 2];
        cy2 = world[w + 3];
        x2 = world[w + 4];
        y2 = world[w + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (percentPosition)
        position *= pathLength;
      if (percentSpacing) {
        for (var i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
        var space = spaces[i];
        position += space;
        var p = position;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
          continue;
        }
        for (; ; curve++) {
          var length_5 = curves[curve];
          if (p > length_5)
            continue;
          if (curve == 0)
            p /= length_5;
          else {
            var prev = curves[curve - 1];
            p = (p - prev) / (length_5 - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii = curve * 6;
          x1 = world[ii];
          y1 = world[ii + 1];
          cx1 = world[ii + 2];
          cy1 = world[ii + 3];
          cx2 = world[ii + 4];
          cy2 = world[ii + 5];
          x2 = world[ii + 6];
          y2 = world[ii + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii = 1; ii < 8; ii++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_6 = segments[segment];
          if (p > length_6)
            continue;
          if (segment == 0)
            p /= length_6;
          else {
            var prev = segments[segment - 1];
            p = segment + (p - prev) / (length_6 - prev);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
      }
      return out;
    };
    PathConstraint4.prototype.addBeforePosition = function(p, temp, i, out, o) {
      var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addAfterPosition = function(p, temp, i, out, o) {
      var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
      if (p == 0 || isNaN(p))
        p = 1e-4;
      var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
      var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o] = x;
      out[o + 1] = y;
      if (tangents)
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    };
    PathConstraint4.NONE = -1;
    PathConstraint4.BEFORE = -2;
    PathConstraint4.AFTER = -3;
    PathConstraint4.epsilon = 1e-5;
    return PathConstraint4;
  }()
);
var TransformConstraint = (
  /** @class */
  function() {
    function TransformConstraint4(data, skeleton) {
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.temp = new Vector2();
      this.active = false;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.rotateMix = data.rotateMix;
      this.translateMix = data.translateMix;
      this.scaleMix = data.scaleMix;
      this.shearMix = data.shearMix;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findBone(data.target.name);
    }
    TransformConstraint4.prototype.isActive = function() {
      return this.active;
    };
    TransformConstraint4.prototype.apply = function() {
      this.update();
    };
    TransformConstraint4.prototype.update = function() {
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint4.prototype.applyAbsoluteWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
          modified = true;
        }
        if (translateMix != 0) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp.x - mat.tx) * translateMix;
          mat.ty += (temp.y - mat.ty) * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          var ts = Math.sqrt(ta * ta + tc * tc);
          if (s > 1e-5)
            s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
          mat.a *= s;
          mat.b *= s;
          s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          ts = Math.sqrt(tb * tb + td * td);
          if (s > 1e-5)
            s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
          mat.c *= s;
          mat.d *= s;
          modified = true;
        }
        if (shearMix > 0) {
          var b = mat.c, d = mat.d;
          var by = Math.atan2(d, b);
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r = by + (r + offsetShearY) * shearMix;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint4.prototype.applyRelativeWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
          modified = true;
        }
        if (translateMix != 0) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp.x * translateMix;
          mat.ty += temp.y * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
          mat.a *= s;
          mat.b *= s;
          s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
          mat.c *= s;
          mat.d *= s;
          modified = true;
        }
        if (shearMix > 0) {
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          var b = mat.c, d = mat.d;
          r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint4.prototype.applyAbsoluteLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0) {
          var r = target.arotation - rotation + this.data.offsetRotation;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          rotation += r * rotateMix;
        }
        var x = bone.ax, y = bone.ay;
        if (translateMix != 0) {
          x += (target.ax - x + this.data.offsetX) * translateMix;
          y += (target.ay - y + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
          if (scaleY > 1e-5)
            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0) {
          var r = target.ashearY - shearY + this.data.offsetShearY;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          bone.shearY += r * shearMix;
        }
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint4.prototype.applyRelativeLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0)
          rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
        var x = bone.ax, y = bone.ay;
        if (translateMix != 0) {
          x += (target.ax + this.data.offsetX) * translateMix;
          y += (target.ay + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
          if (scaleY > 1e-5)
            scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0)
          shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    return TransformConstraint4;
  }()
);
var Skeleton = (
  /** @class */
  function() {
    function Skeleton4(data) {
      this._updateCache = new Array();
      this.updateCacheReset = new Array();
      this.time = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (data == null)
        throw new Error("data cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++) {
        var boneData = data.bones[i];
        var bone = void 0;
        if (boneData.parent == null)
          bone = new Bone(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i = 0; i < data.slots.length; i++) {
        var slotData = data.slots[i];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i = 0; i < data.ikConstraints.length; i++) {
        var ikConstraintData = data.ikConstraints[i];
        this.ikConstraints.push(new IkConstraint(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i = 0; i < data.transformConstraints.length; i++) {
        var transformConstraintData = data.transformConstraints[i];
        this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i = 0; i < data.pathConstraints.length; i++) {
        var pathConstraintData = data.pathConstraints[i];
        this.pathConstraints.push(new PathConstraint(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton4.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      this.updateCacheReset.length = 0;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        bone.sorted = bone.data.skinRequired;
        bone.active = !bone.sorted;
      }
      if (this.skin != null) {
        var skinBones = this.skin.bones;
        for (var i = 0, n = this.skin.bones.length; i < n; i++) {
          var bone = this.bones[skinBones[i].index];
          do {
            bone.sorted = false;
            bone.active = true;
            bone = bone.parent;
          } while (bone != null);
        }
      }
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer: for (var i = 0; i < constraintCount; i++) {
        for (var ii = 0; ii < ikCount; ii++) {
          var constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < transformCount; ii++) {
          var constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < pathCount; ii++) {
          var constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
      for (var i = 0, n = bones.length; i < n; i++)
        this.sortBone(bones[i]);
    };
    Skeleton4.prototype.sortIkConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length > 1) {
        var child = constrained[constrained.length - 1];
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      constrained[constrained.length - 1].sorted = true;
    };
    Skeleton4.prototype.sortPathConstraint = function(constraint) {
      constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin != null)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i = 0, n = this.data.skins.length; i < n; i++)
        this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i = 0; i < boneCount; i++)
        this.sortBone(constrained[i]);
      this._updateCache.push(constraint);
      for (var i = 0; i < boneCount; i++)
        this.sortReset(constrained[i].children);
      for (var i = 0; i < boneCount; i++)
        constrained[i].sorted = true;
    };
    Skeleton4.prototype.sortTransformConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i = 0; i < boneCount; i++) {
          var child = constrained[i];
          this.sortBone(child.parent);
          if (!(this._updateCache.indexOf(child) > -1))
            this.updateCacheReset.push(child);
        }
      } else {
        for (var i = 0; i < boneCount; i++) {
          this.sortBone(constrained[i]);
        }
      }
      this._updateCache.push(constraint);
      for (var ii = 0; ii < boneCount; ii++)
        this.sortReset(constrained[ii].children);
      for (var ii = 0; ii < boneCount; ii++)
        constrained[ii].sorted = true;
    };
    Skeleton4.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton4.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment))
        return;
      var pathBones = attachment.bones;
      if (pathBones == null)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        var i = 0;
        while (i < pathBones.length) {
          var boneCount = pathBones[i++];
          for (var n = i + boneCount; i < n; i++) {
            var boneIndex = pathBones[i];
            this.sortBone(bones[boneIndex]);
          }
        }
      }
    };
    Skeleton4.prototype.sortBone = function(bone) {
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent != null)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton4.prototype.sortReset = function(bones) {
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.active)
          continue;
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton4.prototype.updateWorldTransform = function() {
      var updateCacheReset = this.updateCacheReset;
      for (var i = 0, n = updateCacheReset.length; i < n; i++) {
        var bone = updateCacheReset[i];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
        bone.appliedValid = true;
      }
      var updateCache = this._updateCache;
      for (var i = 0, n = updateCache.length; i < n; i++)
        updateCache[i].update();
    };
    Skeleton4.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton4.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        bones[i].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        constraint.mix = constraint.data.mix;
        constraint.softness = constraint.data.softness;
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      }
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        var data = constraint.data;
        constraint.rotateMix = data.rotateMix;
        constraint.translateMix = data.translateMix;
        constraint.scaleMix = data.scaleMix;
        constraint.shearMix = data.shearMix;
      }
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        var data = constraint.data;
        constraint.position = data.position;
        constraint.spacing = data.spacing;
        constraint.rotateMix = data.rotateMix;
        constraint.translateMix = data.translateMix;
      }
    };
    Skeleton4.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i = 0, n = slots.length; i < n; i++)
        slots[i].setToSetupPose();
    };
    Skeleton4.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton4.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton4.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].data.name == boneName)
          return i;
      return -1;
    };
    Skeleton4.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton4.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].data.name == slotName)
          return i;
      return -1;
    };
    Skeleton4.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (skin == null)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton4.prototype.setSkin = function(newSkin) {
      if (newSkin == this.skin)
        return;
      if (newSkin != null) {
        if (this.skin != null)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            var name_1 = slot.data.attachmentName;
            if (name_1 != null) {
              var attachment = newSkin.getAttachment(i, name_1);
              if (attachment != null)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
      this.updateCache();
    };
    Skeleton4.prototype.getAttachmentByName = function(slotName, attachmentName) {
      return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
    };
    Skeleton4.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (attachmentName == null)
        throw new Error("attachmentName cannot be null.");
      if (this.skin != null) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.defaultSkin != null)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton4.prototype.setAttachment = function(slotName, attachmentName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName != null) {
            attachment = this.getAttachment(i, attachmentName);
            if (attachment == null)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton4.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var ikConstraint = ikConstraints[i];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton4.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.getBounds = function(offset, size, temp) {
      if (temp === void 0) {
        temp = new Array(2);
      }
      if (offset == null)
        throw new Error("offset cannot be null.");
      if (size == null)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        if (!slot.bone.active)
          continue;
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices != null) {
          for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
            var x = vertices[ii], y = vertices[ii + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Skeleton4.prototype.update = function(delta) {
      this.time += delta;
    };
    Object.defineProperty(Skeleton4.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton4.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton4.deprecatedWarning1 = false;
    return Skeleton4;
  }()
);
var SkeletonData = (
  /** @class */
  function() {
    function SkeletonData4() {
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.fps = 0;
    }
    SkeletonData4.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData4.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].name == boneName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData4.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].name == slotName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSkin = function(skinName) {
      if (skinName == null)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i = 0, n = skins.length; i < n; i++) {
        var skin = skins[i];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData4.prototype.findEvent = function(eventDataName) {
      if (eventDataName == null)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i = 0, n = events.length; i < n; i++) {
        var event_1 = events[i];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData4.prototype.findAnimation = function(animationName) {
      if (animationName == null)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i = 0, n = animations.length; i < n; i++) {
        var animation = animations[i];
        if (animation.name == animationName)
          return animation;
      }
      return null;
    };
    SkeletonData4.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++)
        if (pathConstraints[i].name == pathConstraintName)
          return i;
      return -1;
    };
    return SkeletonData4;
  }()
);
var SlotData = (
  /** @class */
  /* @__PURE__ */ function() {
    function SlotData4(index, name, boneData) {
      this.color = new Color(1, 1, 1, 1);
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      if (boneData == null)
        throw new Error("boneData cannot be null.");
      this.index = index;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData4;
  }()
);
var TransformConstraintData = (
  /** @class */
  function(_super) {
    __extends2(TransformConstraintData4, _super);
    function TransformConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this.rotateMix = 0;
      _this.translateMix = 0;
      _this.scaleMix = 0;
      _this.shearMix = 0;
      _this.offsetRotation = 0;
      _this.offsetX = 0;
      _this.offsetY = 0;
      _this.offsetScaleX = 0;
      _this.offsetScaleY = 0;
      _this.offsetShearY = 0;
      _this.relative = false;
      _this.local = false;
      return _this;
    }
    return TransformConstraintData4;
  }(ConstraintData)
);
var SkinEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function SkinEntry3(slotIndex, name, attachment) {
      this.slotIndex = slotIndex;
      this.name = name;
      this.attachment = attachment;
    }
    return SkinEntry3;
  }()
);
var Skin = (
  /** @class */
  function() {
    function Skin4(name) {
      this.attachments = new Array();
      this.bones = Array();
      this.constraints = new Array();
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin4.prototype.setAttachment = function(slotIndex, name, attachment) {
      if (attachment == null)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin4.prototype.addSkin = function(skin) {
      for (var i = 0; i < skin.bones.length; i++) {
        var bone = skin.bones[i];
        var contained = false;
        for (var j = 0; j < this.bones.length; j++) {
          if (this.bones[j] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i = 0; i < skin.constraints.length; i++) {
        var constraint = skin.constraints[i];
        var contained = false;
        for (var j = 0; j < this.constraints.length; j++) {
          if (this.constraints[j] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i = 0; i < attachments.length; i++) {
        var attachment = attachments[i];
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    };
    Skin4.prototype.copySkin = function(skin) {
      for (var i = 0; i < skin.bones.length; i++) {
        var bone = skin.bones[i];
        var contained = false;
        for (var j = 0; j < this.bones.length; j++) {
          if (this.bones[j] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i = 0; i < skin.constraints.length; i++) {
        var constraint = skin.constraints[i];
        var contained = false;
        for (var j = 0; j < this.constraints.length; j++) {
          if (this.constraints[j] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i = 0; i < attachments.length; i++) {
        var attachment = attachments[i];
        if (attachment.attachment == null)
          continue;
        if (attachment.attachment instanceof MeshAttachment) {
          attachment.attachment = attachment.attachment.newLinkedMesh();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        } else {
          attachment.attachment = attachment.attachment.copy();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }
    };
    Skin4.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin4.prototype.removeAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      if (dictionary)
        dictionary[name] = null;
    };
    Skin4.prototype.getAttachments = function() {
      var entries = new Array();
      for (var i = 0; i < this.attachments.length; i++) {
        var slotAttachments = this.attachments[i];
        if (slotAttachments) {
          for (var name_1 in slotAttachments) {
            var attachment = slotAttachments[name_1];
            if (attachment)
              entries.push(new SkinEntry(i, name_1, attachment));
          }
        }
      }
      return entries;
    };
    Skin4.prototype.getAttachmentsForSlot = function(slotIndex, attachments) {
      var slotAttachments = this.attachments[slotIndex];
      if (slotAttachments) {
        for (var name_2 in slotAttachments) {
          var attachment = slotAttachments[name_2];
          if (attachment)
            attachments.push(new SkinEntry(slotIndex, name_2, attachment));
        }
      }
    };
    Skin4.prototype.clear = function() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    };
    Skin4.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i = 0; i < skeleton.slots.length; i++) {
        var slot = skeleton.slots[i];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment != null)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin4;
  }()
);
var SkeletonBinary = (
  /** @class */
  function() {
    function SkeletonBinary3(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonBinary3.prototype.readSkeletonData = function(binary) {
      var scale = this.scale;
      var skeletonData = new SkeletonData();
      skeletonData.name = "";
      var input = new BinaryInput(binary);
      skeletonData.hash = input.readString();
      skeletonData.version = input.readString();
      if (skeletonData.version === "3.8.75") {
        var error = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
        console.error(error);
      }
      skeletonData.x = input.readFloat();
      skeletonData.y = input.readFloat();
      skeletonData.width = input.readFloat();
      skeletonData.height = input.readFloat();
      var nonessential = input.readBoolean();
      if (nonessential) {
        skeletonData.fps = input.readFloat();
        skeletonData.imagesPath = input.readString();
        skeletonData.audioPath = input.readString();
      }
      var n = 0;
      n = input.readInt(true);
      for (var i = 0; i < n; i++)
        input.strings.push(input.readString());
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var name_1 = input.readString();
        var parent_1 = i == 0 ? null : skeletonData.bones[input.readInt(true)];
        var data = new BoneData(i, name_1, parent_1);
        data.rotation = input.readFloat();
        data.x = input.readFloat() * scale;
        data.y = input.readFloat() * scale;
        data.scaleX = input.readFloat();
        data.scaleY = input.readFloat();
        data.shearX = input.readFloat();
        data.shearY = input.readFloat();
        data.length = input.readFloat() * scale;
        data.transformMode = SkeletonBinary3.TransformModeValues[input.readInt(true)];
        data.skinRequired = input.readBoolean();
        if (nonessential)
          Color.rgba8888ToColor(data.color, input.readInt32());
        skeletonData.bones.push(data);
      }
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var slotName = input.readString();
        var boneData = skeletonData.bones[input.readInt(true)];
        var data = new SlotData(i, slotName, boneData);
        Color.rgba8888ToColor(data.color, input.readInt32());
        var darkColor = input.readInt32();
        if (darkColor != -1)
          Color.rgb888ToColor(data.darkColor = new Color(), darkColor);
        data.attachmentName = input.readStringRef();
        data.blendMode = SkeletonBinary3.BlendModeValues[input.readInt(true)];
        skeletonData.slots.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var data = new IkConstraintData(input.readString());
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        data.mix = input.readFloat();
        data.softness = input.readFloat() * scale;
        data.bendDirection = input.readByte();
        data.compress = input.readBoolean();
        data.stretch = input.readBoolean();
        data.uniform = input.readBoolean();
        skeletonData.ikConstraints.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var data = new TransformConstraintData(input.readString());
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        data.local = input.readBoolean();
        data.relative = input.readBoolean();
        data.offsetRotation = input.readFloat();
        data.offsetX = input.readFloat() * scale;
        data.offsetY = input.readFloat() * scale;
        data.offsetScaleX = input.readFloat();
        data.offsetScaleY = input.readFloat();
        data.offsetShearY = input.readFloat();
        data.rotateMix = input.readFloat();
        data.translateMix = input.readFloat();
        data.scaleMix = input.readFloat();
        data.shearMix = input.readFloat();
        skeletonData.transformConstraints.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var data = new PathConstraintData(input.readString());
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.slots[input.readInt(true)];
        data.positionMode = SkeletonBinary3.PositionModeValues[input.readInt(true)];
        data.spacingMode = SkeletonBinary3.SpacingModeValues[input.readInt(true)];
        data.rotateMode = SkeletonBinary3.RotateModeValues[input.readInt(true)];
        data.offsetRotation = input.readFloat();
        data.position = input.readFloat();
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = input.readFloat();
        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = input.readFloat();
        data.translateMix = input.readFloat();
        skeletonData.pathConstraints.push(data);
      }
      var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
      if (defaultSkin != null) {
        skeletonData.defaultSkin = defaultSkin;
        skeletonData.skins.push(defaultSkin);
      }
      {
        var i = skeletonData.skins.length;
        Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
        for (; i < n; i++)
          skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
      }
      n = this.linkedMeshes.length;
      for (var i = 0; i < n; i++) {
        var linkedMesh = this.linkedMeshes[i];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var data = new EventData(input.readStringRef());
        data.intValue = input.readInt(false);
        data.floatValue = input.readFloat();
        data.stringValue = input.readString();
        data.audioPath = input.readString();
        if (data.audioPath != null) {
          data.volume = input.readFloat();
          data.balance = input.readFloat();
        }
        skeletonData.events.push(data);
      }
      n = input.readInt(true);
      for (var i = 0; i < n; i++)
        skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
      return skeletonData;
    };
    SkeletonBinary3.prototype.readSkin = function(input, skeletonData, defaultSkin, nonessential) {
      var skin = null;
      var slotCount = 0;
      if (defaultSkin) {
        slotCount = input.readInt(true);
        if (slotCount == 0)
          return null;
        skin = new Skin("default");
      } else {
        skin = new Skin(input.readStringRef());
        skin.bones.length = input.readInt(true);
        for (var i = 0, n = skin.bones.length; i < n; i++)
          skin.bones[i] = skeletonData.bones[input.readInt(true)];
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
        slotCount = input.readInt(true);
      }
      for (var i = 0; i < slotCount; i++) {
        var slotIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var name_2 = input.readStringRef();
          var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_2, nonessential);
          if (attachment != null)
            skin.setAttachment(slotIndex, name_2, attachment);
        }
      }
      return skin;
    };
    SkeletonBinary3.prototype.readAttachment = function(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
      var scale = this.scale;
      var name = input.readStringRef();
      if (name == null)
        name = attachmentName;
      var typeIndex = input.readByte();
      var type = SkeletonBinary3.AttachmentTypeValues[typeIndex];
      switch (type) {
        case AttachmentType.Region: {
          var path = input.readStringRef();
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y = input.readFloat();
          var scaleX = input.readFloat();
          var scaleY = input.readFloat();
          var width = input.readFloat();
          var height = input.readFloat();
          var color = input.readInt32();
          if (path == null)
            path = name;
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = x * scale;
          region.y = y * scale;
          region.scaleX = scaleX;
          region.scaleY = scaleY;
          region.rotation = rotation;
          region.width = width * scale;
          region.height = height * scale;
          Color.rgba8888ToColor(region.color, color);
          return region;
        }
        case AttachmentType.BoundingBox: {
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color = nonessential ? input.readInt32() : 0;
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          box.worldVerticesLength = vertexCount << 1;
          box.vertices = vertices.vertices;
          box.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(box.color, color);
          return box;
        }
        case AttachmentType.Mesh: {
          var path = input.readStringRef();
          var color = input.readInt32();
          var vertexCount = input.readInt(true);
          var uvs = this.readFloatArray(input, vertexCount << 1, 1);
          var triangles = this.readShortArray(input);
          var vertices = this.readVertices(input, vertexCount);
          var hullLength = input.readInt(true);
          var edges = null;
          var width = 0, height = 0;
          if (nonessential) {
            edges = this.readShortArray(input);
            width = input.readFloat();
            height = input.readFloat();
          }
          if (path == null)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color);
          mesh.bones = vertices.bones;
          mesh.vertices = vertices.vertices;
          mesh.worldVerticesLength = vertexCount << 1;
          mesh.triangles = triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = hullLength << 1;
          if (nonessential) {
            mesh.edges = edges;
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          return mesh;
        }
        case AttachmentType.LinkedMesh: {
          var path = input.readStringRef();
          var color = input.readInt32();
          var skinName = input.readStringRef();
          var parent_3 = input.readStringRef();
          var inheritDeform = input.readBoolean();
          var width = 0, height = 0;
          if (nonessential) {
            width = input.readFloat();
            height = input.readFloat();
          }
          if (path == null)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color);
          if (nonessential) {
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          this.linkedMeshes.push(new LinkedMesh$1(mesh, skinName, slotIndex, parent_3, inheritDeform));
          return mesh;
        }
        case AttachmentType.Path: {
          var closed_1 = input.readBoolean();
          var constantSpeed = input.readBoolean();
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i = 0, n = lengths.length; i < n; i++)
            lengths[i] = input.readFloat() * scale;
          var color = nonessential ? input.readInt32() : 0;
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = closed_1;
          path.constantSpeed = constantSpeed;
          path.worldVerticesLength = vertexCount << 1;
          path.vertices = vertices.vertices;
          path.bones = vertices.bones;
          path.lengths = lengths;
          if (nonessential)
            Color.rgba8888ToColor(path.color, color);
          return path;
        }
        case AttachmentType.Point: {
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y = input.readFloat();
          var color = nonessential ? input.readInt32() : 0;
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = x * scale;
          point.y = y * scale;
          point.rotation = rotation;
          if (nonessential)
            Color.rgba8888ToColor(point.color, color);
          return point;
        }
        case AttachmentType.Clipping: {
          var endSlotIndex = input.readInt(true);
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color = nonessential ? input.readInt32() : 0;
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          clip.endSlot = skeletonData.slots[endSlotIndex];
          clip.worldVerticesLength = vertexCount << 1;
          clip.vertices = vertices.vertices;
          clip.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(clip.color, color);
          return clip;
        }
      }
      return null;
    };
    SkeletonBinary3.prototype.readVertices = function(input, vertexCount) {
      var verticesLength = vertexCount << 1;
      var vertices = new Vertices();
      var scale = this.scale;
      if (!input.readBoolean()) {
        vertices.vertices = this.readFloatArray(input, verticesLength, scale);
        return vertices;
      }
      var weights = new Array();
      var bonesArray = new Array();
      for (var i = 0; i < vertexCount; i++) {
        var boneCount = input.readInt(true);
        bonesArray.push(boneCount);
        for (var ii = 0; ii < boneCount; ii++) {
          bonesArray.push(input.readInt(true));
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat());
        }
      }
      vertices.vertices = Utils.toFloatArray(weights);
      vertices.bones = bonesArray;
      return vertices;
    };
    SkeletonBinary3.prototype.readFloatArray = function(input, n, scale) {
      var array = new Array(n);
      if (scale == 1) {
        for (var i = 0; i < n; i++)
          array[i] = input.readFloat();
      } else {
        for (var i = 0; i < n; i++)
          array[i] = input.readFloat() * scale;
      }
      return array;
    };
    SkeletonBinary3.prototype.readShortArray = function(input) {
      var n = input.readInt(true);
      var array = new Array(n);
      for (var i = 0; i < n; i++)
        array[i] = input.readShort();
      return array;
    };
    SkeletonBinary3.prototype.readAnimation = function(input, name, skeletonData) {
      var timelines = new Array();
      var scale = this.scale;
      var duration = 0;
      var tempColor1 = new Color();
      var tempColor2 = new Color();
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var slotIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary3.SLOT_ATTACHMENT: {
              var timeline = new AttachmentTimeline(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)
                timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[frameCount - 1]);
              break;
            }
            case SkeletonBinary3.SLOT_COLOR: {
              var timeline = new ColorTimeline(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                Color.rgba8888ToColor(tempColor1, input.readInt32());
                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);
              break;
            }
            case SkeletonBinary3.SLOT_TWO_COLOR: {
              var timeline = new TwoColorTimeline(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                Color.rgba8888ToColor(tempColor1, input.readInt32());
                Color.rgb888ToColor(tempColor2, input.readInt32());
                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var boneIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary3.BONE_ROTATE: {
              var timeline = new RotateTimeline(frameCount);
              timeline.boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);
              break;
            }
            case SkeletonBinary3.BONE_TRANSLATE:
            case SkeletonBinary3.BONE_SCALE:
            case SkeletonBinary3.BONE_SHEAR: {
              var timeline = void 0;
              var timelineScale = 1;
              if (timelineType == SkeletonBinary3.BONE_SCALE)
                timeline = new ScaleTimeline(frameCount);
              else if (timelineType == SkeletonBinary3.BONE_SHEAR)
                timeline = new ShearTimeline(frameCount);
              else {
                timeline = new TranslateTimeline(frameCount);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true);
        var frameCount = input.readInt(true);
        var timeline = new IkConstraintTimeline(frameCount);
        timeline.ikConstraintIndex = index;
        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
          timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
          if (frameIndex < frameCount - 1)
            this.readCurve(input, frameIndex, timeline);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true);
        var frameCount = input.readInt(true);
        var timeline = new TransformConstraintTimeline(frameCount);
        timeline.transformConstraintIndex = index;
        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
          timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
          if (frameIndex < frameCount - 1)
            this.readCurve(input, frameIndex, timeline);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true);
        var data = skeletonData.pathConstraints[index];
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary3.PATH_POSITION:
            case SkeletonBinary3.PATH_SPACING: {
              var timeline = void 0;
              var timelineScale = 1;
              if (timelineType == SkeletonBinary3.PATH_SPACING) {
                timeline = new PathConstraintSpacingTimeline(frameCount);
                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline(frameCount);
                if (data.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);
              break;
            }
            case SkeletonBinary3.PATH_MIX: {
              var timeline = new PathConstraintMixTimeline(frameCount);
              timeline.pathConstraintIndex = index;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var skin = skeletonData.skins[input.readInt(true)];
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var slotIndex = input.readInt(true);
          for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
            var attachment = skin.getAttachment(slotIndex, input.readStringRef());
            var weighted = attachment.bones != null;
            var vertices = attachment.vertices;
            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            var frameCount = input.readInt(true);
            var timeline = new DeformTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              var time = input.readFloat();
              var deform = void 0;
              var end = input.readInt(true);
              if (end == 0)
                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = Utils.newFloatArray(deformLength);
                var start = input.readInt(true);
                end += start;
                if (scale == 1) {
                  for (var v = start; v < end; v++)
                    deform[v] = input.readFloat();
                } else {
                  for (var v = start; v < end; v++)
                    deform[v] = input.readFloat() * scale;
                }
                if (!weighted) {
                  for (var v = 0, vn = deform.length; v < vn; v++)
                    deform[v] += vertices[v];
                }
              }
              timeline.setFrame(frameIndex, time, deform);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[frameCount - 1]);
          }
        }
      }
      var drawOrderCount = input.readInt(true);
      if (drawOrderCount > 0) {
        var timeline = new DrawOrderTimeline(drawOrderCount);
        var slotCount = skeletonData.slots.length;
        for (var i = 0; i < drawOrderCount; i++) {
          var time = input.readFloat();
          var offsetCount = input.readInt(true);
          var drawOrder = Utils.newArray(slotCount, 0);
          for (var ii = slotCount - 1; ii >= 0; ii--)
            drawOrder[ii] = -1;
          var unchanged = Utils.newArray(slotCount - offsetCount, 0);
          var originalIndex = 0, unchangedIndex = 0;
          for (var ii = 0; ii < offsetCount; ii++) {
            var slotIndex = input.readInt(true);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (var ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
          timeline.setFrame(i, time, drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
      }
      var eventCount = input.readInt(true);
      if (eventCount > 0) {
        var timeline = new EventTimeline(eventCount);
        for (var i = 0; i < eventCount; i++) {
          var time = input.readFloat();
          var eventData = skeletonData.events[input.readInt(true)];
          var event_1 = new Event(time, eventData);
          event_1.intValue = input.readInt(false);
          event_1.floatValue = input.readFloat();
          event_1.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
          if (event_1.data.audioPath != null) {
            event_1.volume = input.readFloat();
            event_1.balance = input.readFloat();
          }
          timeline.setFrame(i, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[eventCount - 1]);
      }
      return new Animation(name, timelines, duration);
    };
    SkeletonBinary3.prototype.readCurve = function(input, frameIndex, timeline) {
      switch (input.readByte()) {
        case SkeletonBinary3.CURVE_STEPPED:
          timeline.setStepped(frameIndex);
          break;
        case SkeletonBinary3.CURVE_BEZIER:
          this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
          break;
      }
    };
    SkeletonBinary3.prototype.setCurve = function(timeline, frameIndex, cx1, cy1, cx2, cy2) {
      timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
    };
    SkeletonBinary3.AttachmentTypeValues = [
      0,
      1,
      2,
      3,
      4,
      5,
      6
      /*AttachmentType.Clipping*/
    ];
    SkeletonBinary3.TransformModeValues = [TransformMode.Normal, TransformMode.OnlyTranslation, TransformMode.NoRotationOrReflection, TransformMode.NoScale, TransformMode.NoScaleOrReflection];
    SkeletonBinary3.PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];
    SkeletonBinary3.SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];
    SkeletonBinary3.RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];
    SkeletonBinary3.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];
    SkeletonBinary3.BONE_ROTATE = 0;
    SkeletonBinary3.BONE_TRANSLATE = 1;
    SkeletonBinary3.BONE_SCALE = 2;
    SkeletonBinary3.BONE_SHEAR = 3;
    SkeletonBinary3.SLOT_ATTACHMENT = 0;
    SkeletonBinary3.SLOT_COLOR = 1;
    SkeletonBinary3.SLOT_TWO_COLOR = 2;
    SkeletonBinary3.PATH_POSITION = 0;
    SkeletonBinary3.PATH_SPACING = 1;
    SkeletonBinary3.PATH_MIX = 2;
    SkeletonBinary3.CURVE_LINEAR = 0;
    SkeletonBinary3.CURVE_STEPPED = 1;
    SkeletonBinary3.CURVE_BEZIER = 2;
    return SkeletonBinary3;
  }()
);
var LinkedMesh$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function LinkedMesh4(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritDeform = inheritDeform;
    }
    return LinkedMesh4;
  }()
);
var Vertices = (
  /** @class */
  /* @__PURE__ */ function() {
    function Vertices3(bones, vertices) {
      if (bones === void 0) {
        bones = null;
      }
      if (vertices === void 0) {
        vertices = null;
      }
      this.bones = bones;
      this.vertices = vertices;
    }
    return Vertices3;
  }()
);
var SkeletonBounds = (
  /** @class */
  function(_super) {
    __extends2(SkeletonBounds4, _super);
    function SkeletonBounds4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds4;
  }(SkeletonBoundsBase)
);
var SkeletonJson = (
  /** @class */
  function() {
    function SkeletonJson4(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson4.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData();
      var root = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root.skeleton;
      if (skeletonMap != null) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        if (skeletonData.version.substr(0, 3) !== "3.8") {
          var error = "Spine 3.8 loader cant load version " + skeletonMap.spine + ". Please configure your pixi-spine bundle";
          console.error(error);
        }
        if (skeletonData.version === "3.8.75") {
          var error = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
          console.error(error);
        }
        skeletonData.x = skeletonMap.x;
        skeletonData.y = skeletonMap.y;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root.bones) {
        for (var i = 0; i < root.bones.length; i++) {
          var boneMap = root.bones[i];
          var parent_1 = null;
          var parentName = this.getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data = new BoneData(skeletonData.bones.length, boneMap.name, parent_1);
          data.length = this.getValue(boneMap, "length", 0) * scale;
          data.x = this.getValue(boneMap, "x", 0) * scale;
          data.y = this.getValue(boneMap, "y", 0) * scale;
          data.rotation = this.getValue(boneMap, "rotation", 0);
          data.scaleX = this.getValue(boneMap, "scaleX", 1);
          data.scaleY = this.getValue(boneMap, "scaleY", 1);
          data.shearX = this.getValue(boneMap, "shearX", 0);
          data.shearY = this.getValue(boneMap, "shearY", 0);
          data.transformMode = SkeletonJson4.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
          data.skinRequired = this.getValue(boneMap, "skin", false);
          skeletonData.bones.push(data);
        }
      }
      if (root.slots) {
        for (var i = 0; i < root.slots.length; i++) {
          var slotMap = root.slots[i];
          var slotName = slotMap.name;
          var boneName = slotMap.bone;
          var boneData = skeletonData.findBone(boneName);
          if (boneData == null)
            throw new Error("Slot bone not found: " + boneName);
          var data = new SlotData(skeletonData.slots.length, slotName, boneData);
          var color = this.getValue(slotMap, "color", null);
          if (color != null)
            data.color.setFromString(color);
          var dark = this.getValue(slotMap, "dark", null);
          if (dark != null) {
            data.darkColor = new Color(1, 1, 1, 1);
            data.darkColor.setFromString(dark);
          }
          data.attachmentName = this.getValue(slotMap, "attachment", null);
          data.blendMode = SkeletonJson4.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data);
        }
      }
      if (root.ik) {
        for (var i = 0; i < root.ik.length; i++) {
          var constraintMap = root.ik[i];
          var data = new IkConstraintData(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findBone(targetName);
          if (data.target == null)
            throw new Error("IK target bone not found: " + targetName);
          data.mix = this.getValue(constraintMap, "mix", 1);
          data.softness = this.getValue(constraintMap, "softness", 0) * scale;
          data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data.compress = this.getValue(constraintMap, "compress", false);
          data.stretch = this.getValue(constraintMap, "stretch", false);
          data.uniform = this.getValue(constraintMap, "uniform", false);
          skeletonData.ikConstraints.push(data);
        }
      }
      if (root.transform) {
        for (var i = 0; i < root.transform.length; i++) {
          var constraintMap = root.transform[i];
          var data = new TransformConstraintData(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findBone(targetName);
          if (data.target == null)
            throw new Error("Transform constraint target bone not found: " + targetName);
          data.local = this.getValue(constraintMap, "local", false);
          data.relative = this.getValue(constraintMap, "relative", false);
          data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
          data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
          data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
          data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
          data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
          data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data.translateMix = this.getValue(constraintMap, "translateMix", 1);
          data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
          data.shearMix = this.getValue(constraintMap, "shearMix", 1);
          skeletonData.transformConstraints.push(data);
        }
      }
      if (root.path) {
        for (var i = 0; i < root.path.length; i++) {
          var constraintMap = root.path[i];
          var data = new PathConstraintData(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findSlot(targetName);
          if (data.target == null)
            throw new Error("Path target slot not found: " + targetName);
          data.positionMode = SkeletonJson4.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
          data.spacingMode = SkeletonJson4.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
          data.rotateMode = SkeletonJson4.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
          data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data.position = this.getValue(constraintMap, "position", 0);
          if (data.positionMode == PositionMode.Fixed)
            data.position *= scale;
          data.spacing = this.getValue(constraintMap, "spacing", 0);
          if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
            data.spacing *= scale;
          data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data.translateMix = this.getValue(constraintMap, "translateMix", 1);
          skeletonData.pathConstraints.push(data);
        }
      }
      if (root.skins) {
        for (var i = 0; i < root.skins.length; i++) {
          var skinMap = root.skins[i];
          var skin = new Skin(skinMap.name);
          if (skinMap.bones) {
            for (var ii = 0; ii < skinMap.bones.length; ii++) {
              var bone = skeletonData.findBone(skinMap.bones[ii]);
              if (bone == null)
                throw new Error("Skin bone not found: " + skinMap.bones[i]);
              skin.bones.push(bone);
            }
          }
          if (skinMap.ik) {
            for (var ii = 0; ii < skinMap.ik.length; ii++) {
              var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
              if (constraint == null)
                throw new Error("Skin IK constraint not found: " + skinMap.ik[i]);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.transform) {
            for (var ii = 0; ii < skinMap.transform.length; ii++) {
              var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
              if (constraint == null)
                throw new Error("Skin transform constraint not found: " + skinMap.transform[i]);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.path) {
            for (var ii = 0; ii < skinMap.path.length; ii++) {
              var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
              if (constraint == null)
                throw new Error("Skin path constraint not found: " + skinMap.path[i]);
              skin.constraints.push(constraint);
            }
          }
          for (var slotName in skinMap.attachments) {
            var slot = skeletonData.findSlot(slotName);
            if (slot == null)
              throw new Error("Slot not found: " + slotName);
            var slotMap = skinMap.attachments[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
              if (attachment != null)
                skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
        var linkedMesh = this.linkedMeshes[i];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root.events) {
        for (var eventName in root.events) {
          var eventMap = root.events[eventName];
          var data = new EventData(eventName);
          data.intValue = this.getValue(eventMap, "int", 0);
          data.floatValue = this.getValue(eventMap, "float", 0);
          data.stringValue = this.getValue(eventMap, "string", "");
          data.audioPath = this.getValue(eventMap, "audio", null);
          if (data.audioPath != null) {
            data.volume = this.getValue(eventMap, "volume", 1);
            data.balance = this.getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data);
        }
      }
      if (root.animations) {
        for (var animationName in root.animations) {
          var animationMap = root.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson4.prototype.readAttachment = function(map, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = this.getValue(map, "name", name);
      var type = this.getValue(map, "type", "region");
      switch (type) {
        case "region": {
          var path = this.getValue(map, "path", name);
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = this.getValue(map, "x", 0) * scale;
          region.y = this.getValue(map, "y", 0) * scale;
          region.scaleX = this.getValue(map, "scaleX", 1);
          region.scaleY = this.getValue(map, "scaleY", 1);
          region.rotation = this.getValue(map, "rotation", 0);
          region.width = map.width * scale;
          region.height = map.height * scale;
          var color = this.getValue(map, "color", null);
          if (color != null)
            region.color.setFromString(color);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          this.readVertices(map, box, map.vertexCount << 1);
          var color = this.getValue(map, "color", null);
          if (color != null)
            box.color.setFromString(color);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = this.getValue(map, "path", name);
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          var color = this.getValue(map, "color", null);
          if (color != null)
            mesh.color.setFromString(color);
          mesh.width = this.getValue(map, "width", 0) * scale;
          mesh.height = this.getValue(map, "height", 0) * scale;
          var parent_3 = this.getValue(map, "parent", null);
          if (parent_3 != null) {
            this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_3, this.getValue(map, "deform", true)));
            return mesh;
          }
          var uvs = map.uvs;
          this.readVertices(map, mesh, uvs.length);
          mesh.triangles = map.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.edges = this.getValue(map, "edges", null);
          mesh.hullLength = this.getValue(map, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = this.getValue(map, "closed", false);
          path.constantSpeed = this.getValue(map, "constantSpeed", true);
          var vertexCount = map.vertexCount;
          this.readVertices(map, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i = 0; i < map.lengths.length; i++)
            lengths[i] = map.lengths[i] * scale;
          path.lengths = lengths;
          var color = this.getValue(map, "color", null);
          if (color != null)
            path.color.setFromString(color);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = this.getValue(map, "x", 0) * scale;
          point.y = this.getValue(map, "y", 0) * scale;
          point.rotation = this.getValue(map, "rotation", 0);
          var color = this.getValue(map, "color", null);
          if (color != null)
            point.color.setFromString(color);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          var end = this.getValue(map, "end", null);
          if (end != null) {
            var slot = skeletonData.findSlot(end);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end);
            clip.endSlot = slot;
          }
          var vertexCount = map.vertexCount;
          this.readVertices(map, clip, vertexCount << 1);
          var color = this.getValue(map, "color", null);
          if (color != null)
            clip.color.setFromString(color);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson4.prototype.readVertices = function(map, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i = 0, n = vertices.length; i < n; i++)
            scaledVertices[i] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i = 0, n = vertices.length; i < n; ) {
        var boneCount = vertices[i++];
        bones.push(boneCount);
        for (var nn = i + boneCount * 4; i < nn; i += 4) {
          bones.push(vertices[i]);
          weights.push(vertices[i + 1] * scale);
          weights.push(vertices[i + 2] * scale);
          weights.push(vertices[i + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson4.prototype.readAnimation = function(map, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      var duration = 0;
      if (map.slots) {
        for (var slotName in map.slots) {
          var slotMap = map.slots[slotName];
          var slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error("Slot not found: " + slotName);
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            } else if (timelineName == "color") {
              var timeline = new ColorTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var color = new Color();
                color.setFromString(valueMap.color || "ffffffff");
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);
            } else if (timelineName == "twoColor") {
              var timeline = new TwoColorTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var light = new Color();
                var dark = new Color();
                light.setFromString(valueMap.light);
                dark.setFromString(valueMap.dark);
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
          }
        }
      }
      if (map.bones) {
        for (var boneName in map.bones) {
          var boneMap = map.bones[boneName];
          var boneIndex = skeletonData.findBoneIndex(boneName);
          if (boneIndex == -1)
            throw new Error("Bone not found: " + boneName);
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            if (timelineName === "rotate") {
              var timeline = new RotateTimeline(timelineMap.length);
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);
            } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
              var timeline = null;
              var timelineScale = 1, defaultValue = 0;
              if (timelineName === "scale") {
                timeline = new ScaleTimeline(timelineMap.length);
                defaultValue = 1;
              } else if (timelineName === "shear")
                timeline = new ShearTimeline(timelineMap.length);
              else {
                timeline = new TranslateTimeline(timelineMap.length);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var x = this.getValue(valueMap, "x", defaultValue), y = this.getValue(valueMap, "y", defaultValue);
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
          }
        }
      }
      if (map.ik) {
        for (var constraintName in map.ik) {
          var constraintMap = map.ik[constraintName];
          var constraint = skeletonData.findIkConstraint(constraintName);
          var timeline = new IkConstraintTimeline(constraintMap.length);
          timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "softness", 0) * scale, this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);
        }
      }
      if (map.transform) {
        for (var constraintName in map.transform) {
          var constraintMap = map.transform[constraintName];
          var constraint = skeletonData.findTransformConstraint(constraintName);
          var timeline = new TransformConstraintTimeline(constraintMap.length);
          timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);
        }
      }
      if (map.path) {
        for (var constraintName in map.path) {
          var constraintMap = map.path[constraintName];
          var index = skeletonData.findPathConstraintIndex(constraintName);
          if (index == -1)
            throw new Error("Path constraint not found: " + constraintName);
          var data = skeletonData.pathConstraints[index];
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            if (timelineName === "position" || timelineName === "spacing") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "spacing") {
                timeline = new PathConstraintSpacingTimeline(timelineMap.length);
                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline(timelineMap.length);
                if (data.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline(timelineMap.length);
              timeline.pathConstraintIndex = index;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);
            }
          }
        }
      }
      if (map.deform) {
        for (var deformName in map.deform) {
          var deformMap = map.deform[deformName];
          var skin = skeletonData.findSkin(deformName);
          if (skin == null) {
            if (settings.FAIL_ON_NON_EXISTING_SKIN) {
              throw new Error("Skin not found: " + deformName);
            } else {
              continue;
            }
          }
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotMap.name);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName];
              var attachment = skin.getAttachment(slotIndex, timelineName);
              if (attachment == null)
                throw new Error("Deform attachment not found: " + timelineMap.name);
              var weighted = attachment.bones != null;
              var vertices = attachment.vertices;
              var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              var timeline = new DeformTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              timeline.attachment = attachment;
              var frameIndex = 0;
              for (var j = 0; j < timelineMap.length; j++) {
                var valueMap = timelineMap[j];
                var deform = void 0;
                var verticesValue = this.getValue(valueMap, "vertices", null);
                if (verticesValue == null)
                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils.newFloatArray(deformLength);
                  var start = this.getValue(valueMap, "offset", 0);
                  Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                  if (scale != 1) {
                    for (var i = start, n = i + verticesValue.length; i < n; i++)
                      deform[i] *= scale;
                  }
                  if (!weighted) {
                    for (var i = 0; i < deformLength; i++)
                      deform[i] += vertices[i];
                  }
                }
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            }
          }
        }
      }
      var drawOrderNode = map.drawOrder;
      if (drawOrderNode == null)
        drawOrderNode = map.draworder;
      if (drawOrderNode != null) {
        var timeline = new DrawOrderTimeline(drawOrderNode.length);
        var slotCount = skeletonData.slots.length;
        var frameIndex = 0;
        for (var j = 0; j < drawOrderNode.length; j++) {
          var drawOrderMap = drawOrderNode[j];
          var drawOrder = null;
          var offsets = this.getValue(drawOrderMap, "offsets", null);
          if (offsets != null) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var i = 0; i < offsets.length; i++) {
              var offsetMap = offsets[i];
              var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
              if (slotIndex == -1)
                throw new Error("Slot not found: " + offsetMap.slot);
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var i = slotCount - 1; i >= 0; i--)
              if (drawOrder[i] == -1)
                drawOrder[i] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (map.events) {
        var timeline = new EventTimeline(map.events.length);
        var frameIndex = 0;
        for (var i = 0; i < map.events.length; i++) {
          var eventMap = map.events[i];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (eventData == null)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event(Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
          event_1.intValue = this.getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath != null) {
            event_1.volume = this.getValue(eventMap, "volume", 1);
            event_1.balance = this.getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frameIndex++, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation(name, timelines, duration));
    };
    SkeletonJson4.prototype.readCurve = function(map, timeline, frameIndex) {
      if (!map.hasOwnProperty("curve"))
        return;
      if (map.curve === "stepped")
        timeline.setStepped(frameIndex);
      else {
        var curve = map.curve;
        timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
      }
    };
    SkeletonJson4.prototype.getValue = function(map, prop, defaultValue) {
      return map[prop] !== void 0 ? map[prop] : defaultValue;
    };
    SkeletonJson4.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES.NORMAL;
      if (str == "additive")
        return BLEND_MODES.ADD;
      if (str == "multiply")
        return BLEND_MODES.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    SkeletonJson4.positionModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "fixed")
        return PositionMode.Fixed;
      if (str == "percent")
        return PositionMode.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson4.spacingModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "length")
        return SpacingMode.Length;
      if (str == "fixed")
        return SpacingMode.Fixed;
      if (str == "percent")
        return SpacingMode.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson4.rotateModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "tangent")
        return RotateMode.Tangent;
      if (str == "chain")
        return RotateMode.Chain;
      if (str == "chainscale")
        return RotateMode.ChainScale;
      throw new Error("Unknown rotate mode: " + str);
    };
    SkeletonJson4.transformModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return TransformMode.Normal;
      if (str == "onlytranslation")
        return TransformMode.OnlyTranslation;
      if (str == "norotationorreflection")
        return TransformMode.NoRotationOrReflection;
      if (str == "noscale")
        return TransformMode.NoScale;
      if (str == "noscaleorreflection")
        return TransformMode.NoScaleOrReflection;
      throw new Error("Unknown transform mode: " + str);
    };
    return SkeletonJson4;
  }()
);
var LinkedMesh = (
  /** @class */
  /* @__PURE__ */ function() {
    function LinkedMesh4(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritDeform = inheritDeform;
    }
    return LinkedMesh4;
  }()
);
var Spine = (
  /** @class */
  function(_super) {
    __extends2(Spine5, _super);
    function Spine5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine5.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData(spineData);
      this.state = new AnimationState(this.stateData);
    };
    return Spine5;
  }(SpineBase)
);

// node_modules/@pixi-spine/runtime-3.7/lib/runtime-3.7.es.js
var runtime_3_7_es_exports = {};
__export(runtime_3_7_es_exports, {
  Animation: () => Animation2,
  AnimationState: () => AnimationState2,
  AnimationStateAdapter2: () => AnimationStateAdapter2,
  AnimationStateData: () => AnimationStateData2,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader2,
  Attachment: () => Attachment2,
  AttachmentTimeline: () => AttachmentTimeline2,
  Bone: () => Bone2,
  BoneData: () => BoneData2,
  BoundingBoxAttachment: () => BoundingBoxAttachment2,
  ClippingAttachment: () => ClippingAttachment2,
  ColorTimeline: () => ColorTimeline2,
  CurveTimeline: () => CurveTimeline2,
  DeformTimeline: () => DeformTimeline2,
  DrawOrderTimeline: () => DrawOrderTimeline2,
  Event: () => Event2,
  EventData: () => EventData2,
  EventQueue: () => EventQueue2,
  EventTimeline: () => EventTimeline2,
  EventType: () => EventType2,
  IkConstraint: () => IkConstraint2,
  IkConstraintData: () => IkConstraintData2,
  IkConstraintTimeline: () => IkConstraintTimeline2,
  JitterEffect: () => JitterEffect2,
  MeshAttachment: () => MeshAttachment2,
  PathAttachment: () => PathAttachment2,
  PathConstraint: () => PathConstraint2,
  PathConstraintData: () => PathConstraintData2,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline2,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline2,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline2,
  PointAttachment: () => PointAttachment2,
  RegionAttachment: () => RegionAttachment2,
  RotateTimeline: () => RotateTimeline2,
  ScaleTimeline: () => ScaleTimeline2,
  ShearTimeline: () => ShearTimeline2,
  Skeleton: () => Skeleton2,
  SkeletonBounds: () => SkeletonBounds2,
  SkeletonData: () => SkeletonData2,
  SkeletonJson: () => SkeletonJson2,
  Skin: () => Skin2,
  Slot: () => Slot2,
  SlotData: () => SlotData2,
  SpacingMode: () => SpacingMode2,
  Spine: () => Spine2,
  SwirlEffect: () => SwirlEffect2,
  TimelineType: () => TimelineType2,
  TrackEntry: () => TrackEntry2,
  TransformConstraint: () => TransformConstraint2,
  TransformConstraintData: () => TransformConstraintData2,
  TransformConstraintTimeline: () => TransformConstraintTimeline2,
  TranslateTimeline: () => TranslateTimeline2,
  TwoColorTimeline: () => TwoColorTimeline2,
  VertexAttachment: () => VertexAttachment2
});
var extendStatics3 = function(d, b) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics3(d, b);
};
function __extends3(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Attachment2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Attachment4(name) {
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment4;
  }()
);
var VertexAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(VertexAttachment4, _super);
    function VertexAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.id = (VertexAttachment4.nextID++ & 65535) << 11;
      _this.worldVerticesLength = 0;
      return _this;
    }
    VertexAttachment4.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment4.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.attachmentVertices;
      var vertices = this.vertices;
      var bones = this.bones;
      if (bones == null) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y = mat.ty;
        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
        for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
          var vx = vertices[v_1], vy = vertices[v_1 + 1];
          worldVertices[w] = vx * a + vy * b + x;
          worldVertices[w + 1] = vx * c + vy * d + y;
        }
        return;
      }
      var v = 0, skip = 0;
      for (var i = 0; i < start; i += 2) {
        var n = bones[v];
        v += n + 1;
        skip += n;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w = offset, b = skip * 3; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3, f += 2) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      }
    };
    VertexAttachment4.prototype.applyDeform = function(sourceAttachment) {
      return this == sourceAttachment;
    };
    VertexAttachment4.nextID = 0;
    return VertexAttachment4;
  }(Attachment2)
);
var BoundingBoxAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(BoundingBoxAttachment4, _super);
    function BoundingBoxAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    return BoundingBoxAttachment4;
  }(VertexAttachment2)
);
var ClippingAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(ClippingAttachment4, _super);
    function ClippingAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    return ClippingAttachment4;
  }(VertexAttachment2)
);
var MeshAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(MeshAttachment4, _super);
    function MeshAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.color = new Color(1, 1, 1, 1);
      _this.inheritDeform = false;
      _this.tempColor = new Color(0, 0, 0, 0);
      return _this;
    }
    MeshAttachment4.prototype.applyDeform = function(sourceAttachment) {
      return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
    };
    MeshAttachment4.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment4.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh != null) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    return MeshAttachment4;
  }(VertexAttachment2)
);
var PathAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(PathAttachment4, _super);
    function PathAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    return PathAttachment4;
  }(VertexAttachment2)
);
var PointAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(PointAttachment4, _super);
    function PointAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment4.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment4.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y = cos * mat.b + sin * mat.d;
      return Math.atan2(y, x) * MathUtils.radDeg;
    };
    return PointAttachment4;
  }(VertexAttachment2)
);
var Slot2 = (
  /** @class */
  function() {
    function Slot4(data, bone) {
      this.attachmentVertices = new Array();
      if (data == null)
        throw new Error("data cannot be null.");
      if (bone == null)
        throw new Error("bone cannot be null.");
      this.data = data;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = data.darkColor == null ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot4.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot4.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      this.attachment = attachment;
      this.attachmentTime = this.bone.skeleton.time;
      this.attachmentVertices.length = 0;
    };
    Slot4.prototype.setAttachmentTime = function(time) {
      this.attachmentTime = this.bone.skeleton.time - time;
    };
    Slot4.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    Slot4.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor != null)
        this.darkColor.setFromColor(this.data.darkColor);
      if (this.data.attachmentName == null)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot4;
  }()
);
var RegionAttachment2 = (
  /** @class */
  function(_super) {
    __extends3(RegionAttachment4, _super);
    function RegionAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      return _this;
    }
    RegionAttachment4.prototype.updateOffset = function() {
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var localXCos = localX * cos + this.x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + this.y;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + this.x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + this.y;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[RegionAttachment4.OX1] = localXCos - localYSin;
      offset[RegionAttachment4.OY1] = localYCos + localXSin;
      offset[RegionAttachment4.OX2] = localXCos - localY2Sin;
      offset[RegionAttachment4.OY2] = localY2Cos + localXSin;
      offset[RegionAttachment4.OX3] = localX2Cos - localY2Sin;
      offset[RegionAttachment4.OY3] = localY2Cos + localX2Sin;
      offset[RegionAttachment4.OX4] = localX2Cos - localYSin;
      offset[RegionAttachment4.OY4] = localYCos + localX2Sin;
    };
    RegionAttachment4.prototype.setRegion = function(region) {
      this.region = region;
      var uvs = this.uvs;
      if (region.rotate) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment4.prototype.computeWorldVertices = function(bone, worldVertices, offset, stride) {
      var vertexOffset = this.offset;
      var mat = bone instanceof Slot2 ? bone.bone.matrix : bone.matrix;
      var x = mat.tx, y = mat.ty;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[RegionAttachment4.OX1];
      offsetY = vertexOffset[RegionAttachment4.OY1];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX2];
      offsetY = vertexOffset[RegionAttachment4.OY2];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX3];
      offsetY = vertexOffset[RegionAttachment4.OY3];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment4.OX4];
      offsetY = vertexOffset[RegionAttachment4.OY4];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    };
    RegionAttachment4.OX1 = 0;
    RegionAttachment4.OY1 = 1;
    RegionAttachment4.OX2 = 2;
    RegionAttachment4.OY2 = 3;
    RegionAttachment4.OX3 = 4;
    RegionAttachment4.OY3 = 5;
    RegionAttachment4.OX4 = 6;
    RegionAttachment4.OY4 = 7;
    RegionAttachment4.X1 = 0;
    RegionAttachment4.Y1 = 1;
    RegionAttachment4.C1R = 2;
    RegionAttachment4.C1G = 3;
    RegionAttachment4.C1B = 4;
    RegionAttachment4.C1A = 5;
    RegionAttachment4.U1 = 6;
    RegionAttachment4.V1 = 7;
    RegionAttachment4.X2 = 8;
    RegionAttachment4.Y2 = 9;
    RegionAttachment4.C2R = 10;
    RegionAttachment4.C2G = 11;
    RegionAttachment4.C2B = 12;
    RegionAttachment4.C2A = 13;
    RegionAttachment4.U2 = 14;
    RegionAttachment4.V2 = 15;
    RegionAttachment4.X3 = 16;
    RegionAttachment4.Y3 = 17;
    RegionAttachment4.C3R = 18;
    RegionAttachment4.C3G = 19;
    RegionAttachment4.C3B = 20;
    RegionAttachment4.C3A = 21;
    RegionAttachment4.U3 = 22;
    RegionAttachment4.V3 = 23;
    RegionAttachment4.X4 = 24;
    RegionAttachment4.Y4 = 25;
    RegionAttachment4.C4R = 26;
    RegionAttachment4.C4G = 27;
    RegionAttachment4.C4B = 28;
    RegionAttachment4.C4A = 29;
    RegionAttachment4.U4 = 30;
    RegionAttachment4.V4 = 31;
    return RegionAttachment4;
  }(Attachment2)
);
var JitterEffect2 = (
  /** @class */
  function() {
    function JitterEffect3(jitterX, jitterY) {
      this.jitterX = 0;
      this.jitterY = 0;
      this.jitterX = jitterX;
      this.jitterY = jitterY;
    }
    JitterEffect3.prototype.begin = function(skeleton) {
    };
    JitterEffect3.prototype.transform = function(position, uv, light, dark) {
      position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    JitterEffect3.prototype.end = function() {
    };
    return JitterEffect3;
  }()
);
var SwirlEffect2 = (
  /** @class */
  function() {
    function SwirlEffect3(radius) {
      this.centerX = 0;
      this.centerY = 0;
      this.radius = 0;
      this.angle = 0;
      this.worldX = 0;
      this.worldY = 0;
      this.radius = radius;
    }
    SwirlEffect3.prototype.begin = function(skeleton) {
      this.worldX = skeleton.x + this.centerX;
      this.worldY = skeleton.y + this.centerY;
    };
    SwirlEffect3.prototype.transform = function(position, uv, light, dark) {
      var radAngle = this.angle * MathUtils.degreesToRadians;
      var x = position.x - this.worldX;
      var y = position.y - this.worldY;
      var dist = Math.sqrt(x * x + y * y);
      if (dist < this.radius) {
        var theta = SwirlEffect3.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
        var cos = Math.cos(theta);
        var sin = Math.sin(theta);
        position.x = cos * x - sin * y + this.worldX;
        position.y = sin * x + cos * y + this.worldY;
      }
    };
    SwirlEffect3.prototype.end = function() {
    };
    SwirlEffect3.interpolation = new PowOut(2);
    return SwirlEffect3;
  }()
);
var Animation2 = (
  /** @class */
  function() {
    function Animation4(name, timelines, duration) {
      if (name == null)
        throw new Error("name cannot be null.");
      if (timelines == null)
        throw new Error("timelines cannot be null.");
      this.name = name;
      this.timelines = timelines;
      this.duration = duration;
    }
    Animation4.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime > 0)
          lastTime %= this.duration;
      }
      var timelines = this.timelines;
      for (var i = 0, n = timelines.length; i < n; i++)
        timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
    };
    Animation4.binarySearch = function(values, target, step) {
      if (step === void 0) {
        step = 1;
      }
      var low = 0;
      var high = values.length / step - 2;
      if (high == 0)
        return step;
      var current = high >>> 1;
      while (true) {
        if (values[(current + 1) * step] <= target)
          low = current + 1;
        else
          high = current;
        if (low == high)
          return (low + 1) * step;
        current = low + high >>> 1;
      }
    };
    Animation4.linearSearch = function(values, target, step) {
      for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target)
          return i;
      return -1;
    };
    return Animation4;
  }()
);
var TimelineType2;
(function(TimelineType3) {
  TimelineType3[TimelineType3["rotate"] = 0] = "rotate";
  TimelineType3[TimelineType3["translate"] = 1] = "translate";
  TimelineType3[TimelineType3["scale"] = 2] = "scale";
  TimelineType3[TimelineType3["shear"] = 3] = "shear";
  TimelineType3[TimelineType3["attachment"] = 4] = "attachment";
  TimelineType3[TimelineType3["color"] = 5] = "color";
  TimelineType3[TimelineType3["deform"] = 6] = "deform";
  TimelineType3[TimelineType3["event"] = 7] = "event";
  TimelineType3[TimelineType3["drawOrder"] = 8] = "drawOrder";
  TimelineType3[TimelineType3["ikConstraint"] = 9] = "ikConstraint";
  TimelineType3[TimelineType3["transformConstraint"] = 10] = "transformConstraint";
  TimelineType3[TimelineType3["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType3[TimelineType3["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType3[TimelineType3["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType3[TimelineType3["twoColor"] = 14] = "twoColor";
})(TimelineType2 || (TimelineType2 = {}));
var CurveTimeline2 = (
  /** @class */
  function() {
    function CurveTimeline4(frameCount) {
      if (frameCount <= 0)
        throw new Error("frameCount must be > 0: " + frameCount);
      this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline4.BEZIER_SIZE);
    }
    CurveTimeline4.prototype.getFrameCount = function() {
      return this.curves.length / CurveTimeline4.BEZIER_SIZE + 1;
    };
    CurveTimeline4.prototype.setLinear = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline4.BEZIER_SIZE] = CurveTimeline4.LINEAR;
    };
    CurveTimeline4.prototype.setStepped = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline4.BEZIER_SIZE] = CurveTimeline4.STEPPED;
    };
    CurveTimeline4.prototype.getCurveType = function(frameIndex) {
      var index = frameIndex * CurveTimeline4.BEZIER_SIZE;
      if (index == this.curves.length)
        return CurveTimeline4.LINEAR;
      var type = this.curves[index];
      if (type == CurveTimeline4.LINEAR)
        return CurveTimeline4.LINEAR;
      if (type == CurveTimeline4.STEPPED)
        return CurveTimeline4.STEPPED;
      return CurveTimeline4.BEZIER;
    };
    CurveTimeline4.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
      var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
      var dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3, dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
      var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
      var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
      var i = frameIndex * CurveTimeline4.BEZIER_SIZE;
      var curves = this.curves;
      curves[i++] = CurveTimeline4.BEZIER;
      var x = dfx, y = dfy;
      for (var n = i + CurveTimeline4.BEZIER_SIZE - 1; i < n; i += 2) {
        curves[i] = x;
        curves[i + 1] = y;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        x += dfx;
        y += dfy;
      }
    };
    CurveTimeline4.prototype.getCurvePercent = function(frameIndex, percent) {
      percent = MathUtils.clamp(percent, 0, 1);
      var curves = this.curves;
      var i = frameIndex * CurveTimeline4.BEZIER_SIZE;
      var type = curves[i];
      if (type == CurveTimeline4.LINEAR)
        return percent;
      if (type == CurveTimeline4.STEPPED)
        return 0;
      i++;
      var x = 0;
      for (var start = i, n = i + CurveTimeline4.BEZIER_SIZE - 1; i < n; i += 2) {
        x = curves[i];
        if (x >= percent) {
          var prevX = void 0, prevY = void 0;
          if (i == start) {
            prevX = 0;
            prevY = 0;
          } else {
            prevX = curves[i - 2];
            prevY = curves[i - 1];
          }
          return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
        }
      }
      var y = curves[i - 1];
      return y + (1 - y) * (percent - x) / (1 - x);
    };
    CurveTimeline4.LINEAR = 0;
    CurveTimeline4.STEPPED = 1;
    CurveTimeline4.BEZIER = 2;
    CurveTimeline4.BEZIER_SIZE = 10 * 2 - 1;
    return CurveTimeline4;
  }()
);
var RotateTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(RotateTimeline4, _super);
    function RotateTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount << 1);
      return _this;
    }
    RotateTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.rotate << 24) + this.boneIndex;
    };
    RotateTimeline4.prototype.setFrame = function(frameIndex, time, degrees) {
      frameIndex <<= 1;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + RotateTimeline4.ROTATION] = degrees;
    };
    RotateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            var r_1 = bone.data.rotation - bone.rotation;
            bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha;
        }
        return;
      }
      if (time >= frames[frames.length - RotateTimeline4.ENTRIES]) {
        var r_2 = frames[frames.length + RotateTimeline4.PREV_ROTATION];
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation + r_2 * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            r_2 += bone.data.rotation - bone.rotation;
            r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;
          case MixBlend.add:
            bone.rotation += r_2 * alpha;
        }
        return;
      }
      var frame = Animation2.binarySearch(frames, time, RotateTimeline4.ENTRIES);
      var prevRotation = frames[frame + RotateTimeline4.PREV_ROTATION];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline4.PREV_TIME] - frameTime));
      var r = frames[frame + RotateTimeline4.ROTATION] - prevRotation;
      r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
      }
    };
    RotateTimeline4.ENTRIES = 2;
    RotateTimeline4.PREV_TIME = -2;
    RotateTimeline4.PREV_ROTATION = -1;
    RotateTimeline4.ROTATION = 1;
    return RotateTimeline4;
  }(CurveTimeline2)
);
var TranslateTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(TranslateTimeline4, _super);
    function TranslateTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TranslateTimeline4.ENTRIES);
      return _this;
    }
    TranslateTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.translate << 24) + this.boneIndex;
    };
    TranslateTimeline4.prototype.setFrame = function(frameIndex, time, x, y) {
      frameIndex *= TranslateTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TranslateTimeline4.X] = x;
      this.frames[frameIndex + TranslateTimeline4.Y] = y;
    };
    TranslateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha;
            bone.y += (bone.data.y - bone.y) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - TranslateTimeline4.ENTRIES]) {
        x = frames[frames.length + TranslateTimeline4.PREV_X];
        y = frames[frames.length + TranslateTimeline4.PREV_Y];
      } else {
        var frame = Animation2.binarySearch(frames, time, TranslateTimeline4.ENTRIES);
        x = frames[frame + TranslateTimeline4.PREV_X];
        y = frames[frame + TranslateTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TranslateTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline4.PREV_TIME] - frameTime));
        x += (frames[frame + TranslateTimeline4.X] - x) * percent;
        y += (frames[frame + TranslateTimeline4.Y] - y) * percent;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha;
          bone.y = bone.data.y + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha;
          bone.y += (bone.data.y + y - bone.y) * alpha;
          break;
        case MixBlend.add:
          bone.x += x * alpha;
          bone.y += y * alpha;
      }
    };
    TranslateTimeline4.ENTRIES = 3;
    TranslateTimeline4.PREV_TIME = -3;
    TranslateTimeline4.PREV_X = -2;
    TranslateTimeline4.PREV_Y = -1;
    TranslateTimeline4.X = 1;
    TranslateTimeline4.Y = 2;
    return TranslateTimeline4;
  }(CurveTimeline2)
);
var ScaleTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(ScaleTimeline4, _super);
    function ScaleTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ScaleTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.scale << 24) + this.boneIndex;
    };
    ScaleTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - ScaleTimeline4.ENTRIES]) {
        x = frames[frames.length + ScaleTimeline4.PREV_X] * bone.data.scaleX;
        y = frames[frames.length + ScaleTimeline4.PREV_Y] * bone.data.scaleY;
      } else {
        var frame = Animation2.binarySearch(frames, time, ScaleTimeline4.ENTRIES);
        x = frames[frame + ScaleTimeline4.PREV_X];
        y = frames[frame + ScaleTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ScaleTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline4.PREV_TIME] - frameTime));
        x = (x + (frames[frame + ScaleTimeline4.X] - x) * percent) * bone.data.scaleX;
        y = (y + (frames[frame + ScaleTimeline4.Y] - y) * percent) * bone.data.scaleY;
      }
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.add:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.add:
              bx = MathUtils.signum(x);
              by = MathUtils.signum(y);
              bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
              bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
          }
        }
      }
    };
    return ScaleTimeline4;
  }(TranslateTimeline2)
);
var ShearTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(ShearTimeline4, _super);
    function ShearTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ShearTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.shear << 24) + this.boneIndex;
    };
    ShearTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      if (time >= frames[frames.length - ShearTimeline4.ENTRIES]) {
        x = frames[frames.length + ShearTimeline4.PREV_X];
        y = frames[frames.length + ShearTimeline4.PREV_Y];
      } else {
        var frame = Animation2.binarySearch(frames, time, ShearTimeline4.ENTRIES);
        x = frames[frame + ShearTimeline4.PREV_X];
        y = frames[frame + ShearTimeline4.PREV_Y];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ShearTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline4.PREV_TIME] - frameTime));
        x = x + (frames[frame + ShearTimeline4.X] - x) * percent;
        y = y + (frames[frame + ShearTimeline4.Y] - y) * percent;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha;
          bone.shearY = bone.data.shearY + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha;
          bone.shearY += y * alpha;
      }
    };
    return ShearTimeline4;
  }(TranslateTimeline2)
);
var ColorTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(ColorTimeline3, _super);
    function ColorTimeline3(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * ColorTimeline3.ENTRIES);
      return _this;
    }
    ColorTimeline3.prototype.getPropertyId = function() {
      return (TimelineType2.color << 24) + this.slotIndex;
    };
    ColorTimeline3.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
      frameIndex *= ColorTimeline3.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + ColorTimeline3.R] = r;
      this.frames[frameIndex + ColorTimeline3.G] = g;
      this.frames[frameIndex + ColorTimeline3.B] = b;
      this.frames[frameIndex + ColorTimeline3.A] = a;
    };
    ColorTimeline3.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            return;
          case MixBlend.first:
            var color = slot.color, setup = slot.data.color;
            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0;
      if (time >= frames[frames.length - ColorTimeline3.ENTRIES]) {
        var i = frames.length;
        r = frames[i + ColorTimeline3.PREV_R];
        g = frames[i + ColorTimeline3.PREV_G];
        b = frames[i + ColorTimeline3.PREV_B];
        a = frames[i + ColorTimeline3.PREV_A];
      } else {
        var frame = Animation2.binarySearch(frames, time, ColorTimeline3.ENTRIES);
        r = frames[frame + ColorTimeline3.PREV_R];
        g = frames[frame + ColorTimeline3.PREV_G];
        b = frames[frame + ColorTimeline3.PREV_B];
        a = frames[frame + ColorTimeline3.PREV_A];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / ColorTimeline3.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline3.PREV_TIME] - frameTime));
        r += (frames[frame + ColorTimeline3.R] - r) * percent;
        g += (frames[frame + ColorTimeline3.G] - g) * percent;
        b += (frames[frame + ColorTimeline3.B] - b) * percent;
        a += (frames[frame + ColorTimeline3.A] - a) * percent;
      }
      if (alpha == 1)
        slot.color.set(r, g, b, a);
      else {
        var color = slot.color;
        if (blend == MixBlend.setup)
          color.setFromColor(slot.data.color);
        color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
      }
    };
    ColorTimeline3.ENTRIES = 5;
    ColorTimeline3.PREV_TIME = -5;
    ColorTimeline3.PREV_R = -4;
    ColorTimeline3.PREV_G = -3;
    ColorTimeline3.PREV_B = -2;
    ColorTimeline3.PREV_A = -1;
    ColorTimeline3.R = 1;
    ColorTimeline3.G = 2;
    ColorTimeline3.B = 3;
    ColorTimeline3.A = 4;
    return ColorTimeline3;
  }(CurveTimeline2)
);
var TwoColorTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(TwoColorTimeline3, _super);
    function TwoColorTimeline3(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline3.ENTRIES);
      return _this;
    }
    TwoColorTimeline3.prototype.getPropertyId = function() {
      return (TimelineType2.twoColor << 24) + this.slotIndex;
    };
    TwoColorTimeline3.prototype.setFrame = function(frameIndex, time, r, g, b, a, r2, g2, b2) {
      frameIndex *= TwoColorTimeline3.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TwoColorTimeline3.R] = r;
      this.frames[frameIndex + TwoColorTimeline3.G] = g;
      this.frames[frameIndex + TwoColorTimeline3.B] = b;
      this.frames[frameIndex + TwoColorTimeline3.A] = a;
      this.frames[frameIndex + TwoColorTimeline3.R2] = r2;
      this.frames[frameIndex + TwoColorTimeline3.G2] = g2;
      this.frames[frameIndex + TwoColorTimeline3.B2] = b2;
    };
    TwoColorTimeline3.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            slot.darkColor.setFromColor(slot.data.darkColor);
            return;
          case MixBlend.first:
            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
      if (time >= frames[frames.length - TwoColorTimeline3.ENTRIES]) {
        var i = frames.length;
        r = frames[i + TwoColorTimeline3.PREV_R];
        g = frames[i + TwoColorTimeline3.PREV_G];
        b = frames[i + TwoColorTimeline3.PREV_B];
        a = frames[i + TwoColorTimeline3.PREV_A];
        r2 = frames[i + TwoColorTimeline3.PREV_R2];
        g2 = frames[i + TwoColorTimeline3.PREV_G2];
        b2 = frames[i + TwoColorTimeline3.PREV_B2];
      } else {
        var frame = Animation2.binarySearch(frames, time, TwoColorTimeline3.ENTRIES);
        r = frames[frame + TwoColorTimeline3.PREV_R];
        g = frames[frame + TwoColorTimeline3.PREV_G];
        b = frames[frame + TwoColorTimeline3.PREV_B];
        a = frames[frame + TwoColorTimeline3.PREV_A];
        r2 = frames[frame + TwoColorTimeline3.PREV_R2];
        g2 = frames[frame + TwoColorTimeline3.PREV_G2];
        b2 = frames[frame + TwoColorTimeline3.PREV_B2];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TwoColorTimeline3.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline3.PREV_TIME] - frameTime));
        r += (frames[frame + TwoColorTimeline3.R] - r) * percent;
        g += (frames[frame + TwoColorTimeline3.G] - g) * percent;
        b += (frames[frame + TwoColorTimeline3.B] - b) * percent;
        a += (frames[frame + TwoColorTimeline3.A] - a) * percent;
        r2 += (frames[frame + TwoColorTimeline3.R2] - r2) * percent;
        g2 += (frames[frame + TwoColorTimeline3.G2] - g2) * percent;
        b2 += (frames[frame + TwoColorTimeline3.B2] - b2) * percent;
      }
      if (alpha == 1) {
        slot.color.set(r, g, b, a);
        slot.darkColor.set(r2, g2, b2, 1);
      } else {
        var light = slot.color, dark = slot.darkColor;
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          dark.setFromColor(slot.data.darkColor);
        }
        light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
        dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
      }
    };
    TwoColorTimeline3.ENTRIES = 8;
    TwoColorTimeline3.PREV_TIME = -8;
    TwoColorTimeline3.PREV_R = -7;
    TwoColorTimeline3.PREV_G = -6;
    TwoColorTimeline3.PREV_B = -5;
    TwoColorTimeline3.PREV_A = -4;
    TwoColorTimeline3.PREV_R2 = -3;
    TwoColorTimeline3.PREV_G2 = -2;
    TwoColorTimeline3.PREV_B2 = -1;
    TwoColorTimeline3.R = 1;
    TwoColorTimeline3.G = 2;
    TwoColorTimeline3.B = 3;
    TwoColorTimeline3.A = 4;
    TwoColorTimeline3.R2 = 5;
    TwoColorTimeline3.G2 = 6;
    TwoColorTimeline3.B2 = 7;
    return TwoColorTimeline3;
  }(CurveTimeline2)
);
var AttachmentTimeline2 = (
  /** @class */
  function() {
    function AttachmentTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.attachmentNames = new Array(frameCount);
    }
    AttachmentTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.attachment << 24) + this.slotIndex;
    };
    AttachmentTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline4.prototype.setFrame = function(frameIndex, time, attachmentName) {
      this.frames[frameIndex] = time;
      this.attachmentNames[frameIndex] = attachmentName;
    };
    AttachmentTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        var attachmentName_1 = slot.data.attachmentName;
        slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first) {
          var attachmentName_2 = slot.data.attachmentName;
          slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
        }
        return;
      }
      var frameIndex = 0;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation2.binarySearch(frames, time, 1) - 1;
      var attachmentName = this.attachmentNames[frameIndex];
      skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline4;
  }()
);
var zeros2 = null;
var DeformTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(DeformTimeline4, _super);
    function DeformTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount);
      _this.frameVertices = new Array(frameCount);
      if (zeros2 == null)
        zeros2 = Utils.newFloatArray(64);
      return _this;
    }
    DeformTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    DeformTimeline4.prototype.setFrame = function(frameIndex, time, vertices) {
      this.frames[frameIndex] = time;
      this.frameVertices[frameIndex] = vertices;
    };
    DeformTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var slotAttachment = slot.getAttachment();
      if (!(slotAttachment instanceof VertexAttachment2) || !slotAttachment.applyDeform(this.attachment))
        return;
      var verticesArray = slot.attachmentVertices;
      if (verticesArray.length == 0)
        blend = MixBlend.setup;
      var frameVertices = this.frameVertices;
      var vertexCount = frameVertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        var vertexAttachment = slotAttachment;
        switch (blend) {
          case MixBlend.setup:
            verticesArray.length = 0;
            return;
          case MixBlend.first:
            if (alpha == 1) {
              verticesArray.length = 0;
              break;
            }
            var vertices_1 = Utils.setArraySize(verticesArray, vertexCount);
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++)
                vertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;
            } else {
              alpha = 1 - alpha;
              for (var i = 0; i < vertexCount; i++)
                vertices_1[i] *= alpha;
            }
        }
        return;
      }
      var vertices = Utils.setArraySize(verticesArray, vertexCount);
      if (time >= frames[frames.length - 1]) {
        var lastVertices = frameVertices[frames.length - 1];
        if (alpha == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++) {
                vertices[i] += lastVertices[i] - setupVertices[i];
              }
            } else {
              for (var i = 0; i < vertexCount; i++)
                vertices[i] += lastVertices[i];
            }
          } else {
            Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
          }
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (vertexAttachment_1.bones == null) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i = 0; i < vertexCount; i++) {
                  var setup = setupVertices[i];
                  vertices[i] = setup + (lastVertices[i] - setup) * alpha;
                }
              } else {
                for (var i = 0; i < vertexCount; i++)
                  vertices[i] = lastVertices[i] * alpha;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i = 0; i < vertexCount; i++)
                vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (vertexAttachment.bones == null) {
                var setupVertices = vertexAttachment.vertices;
                for (var i = 0; i < vertexCount; i++) {
                  vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;
                }
              } else {
                for (var i = 0; i < vertexCount; i++)
                  vertices[i] += lastVertices[i] * alpha;
              }
          }
        }
        return;
      }
      var frame = Animation2.binarySearch(frames, time);
      var prevVertices = frameVertices[frame - 1];
      var nextVertices = frameVertices[frame];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            var setupVertices = vertexAttachment.vertices;
            for (var i = 0; i < vertexCount; i++) {
              var prev = prevVertices[i];
              vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
            }
          } else {
            for (var i = 0; i < vertexCount; i++) {
              var prev = prevVertices[i];
              vertices[i] += prev + (nextVertices[i] - prev) * percent;
            }
          }
        } else {
          for (var i = 0; i < vertexCount; i++) {
            var prev = prevVertices[i];
            vertices[i] = prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (vertexAttachment_2.bones == null) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i = 0; i < vertexCount; i++) {
                var prev = prevVertices[i], setup = setupVertices[i];
                vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
              }
            } else {
              for (var i = 0; i < vertexCount; i++) {
                var prev = prevVertices[i];
                vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i = 0; i < vertexCount; i++) {
              var prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++) {
                var prev = prevVertices[i];
                vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
              }
            } else {
              for (var i = 0; i < vertexCount; i++) {
                var prev = prevVertices[i];
                vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
              }
            }
        }
      }
    };
    return DeformTimeline4;
  }(CurveTimeline2)
);
var EventTimeline2 = (
  /** @class */
  function() {
    function EventTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.events = new Array(frameCount);
    }
    EventTimeline4.prototype.getPropertyId = function() {
      return TimelineType2.event << 24;
    };
    EventTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline4.prototype.setFrame = function(frameIndex, event) {
      this.frames[frameIndex] = event.time;
      this.events[frameIndex] = event;
    };
    EventTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (firedEvents == null)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
        lastTime = -1;
      } else if (lastTime >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var frame = 0;
      if (lastTime < frames[0])
        frame = 0;
      else {
        frame = Animation2.binarySearch(frames, lastTime);
        var frameTime = frames[frame];
        while (frame > 0) {
          if (frames[frame - 1] != frameTime)
            break;
          frame--;
        }
      }
      for (; frame < frameCount && time >= frames[frame]; frame++)
        firedEvents.push(this.events[frame]);
    };
    return EventTimeline4;
  }()
);
var DrawOrderTimeline2 = (
  /** @class */
  function() {
    function DrawOrderTimeline4(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.drawOrders = new Array(frameCount);
    }
    DrawOrderTimeline4.prototype.getPropertyId = function() {
      return TimelineType2.drawOrder << 24;
    };
    DrawOrderTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline4.prototype.setFrame = function(frameIndex, time, drawOrder) {
      this.frames[frameIndex] = time;
      this.drawOrders[frameIndex] = drawOrder;
    };
    DrawOrderTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var drawOrder = skeleton.drawOrder;
      var slots = skeleton.slots;
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frame = 0;
      if (time >= frames[frames.length - 1])
        frame = frames.length - 1;
      else
        frame = Animation2.binarySearch(frames, time) - 1;
      var drawOrderToSetupIndex = this.drawOrders[frame];
      if (drawOrderToSetupIndex == null)
        Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
      else {
        for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
          drawOrder[i] = slots[drawOrderToSetupIndex[i]];
      }
    };
    return DrawOrderTimeline4;
  }()
);
var IkConstraintTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(IkConstraintTimeline4, _super);
    function IkConstraintTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline4.ENTRIES);
      return _this;
    }
    IkConstraintTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.ikConstraint << 24) + this.ikConstraintIndex;
    };
    IkConstraintTimeline4.prototype.setFrame = function(frameIndex, time, mix, bendDirection, compress, stretch) {
      frameIndex *= IkConstraintTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + IkConstraintTimeline4.MIX] = mix;
      this.frames[frameIndex + IkConstraintTimeline4.BEND_DIRECTION] = bendDirection;
      this.frames[frameIndex + IkConstraintTimeline4.COMPRESS] = compress ? 1 : 0;
      this.frames[frameIndex + IkConstraintTimeline4.STRETCH] = stretch ? 1 : 0;
    };
    IkConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      if (time >= frames[frames.length - IkConstraintTimeline4.ENTRIES]) {
        if (blend == MixBlend.setup) {
          constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline4.PREV_MIX] - constraint.data.mix) * alpha;
          if (direction == MixDirection.mixOut) {
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
          } else {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline4.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline4.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline4.PREV_STRETCH] != 0;
          }
        } else {
          constraint.mix += (frames[frames.length + IkConstraintTimeline4.PREV_MIX] - constraint.mix) * alpha;
          if (direction == MixDirection.mixIn) {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline4.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline4.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline4.PREV_STRETCH] != 0;
          }
        }
        return;
      }
      var frame = Animation2.binarySearch(frames, time, IkConstraintTimeline4.ENTRIES);
      var mix = frames[frame + IkConstraintTimeline4.PREV_MIX];
      var frameTime = frames[frame];
      var percent = this.getCurvePercent(frame / IkConstraintTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline4.PREV_TIME] - frameTime));
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline4.MIX] - mix) * percent - constraint.data.mix) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frame + IkConstraintTimeline4.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame + IkConstraintTimeline4.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame + IkConstraintTimeline4.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (mix + (frames[frame + IkConstraintTimeline4.MIX] - mix) * percent - constraint.mix) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frame + IkConstraintTimeline4.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame + IkConstraintTimeline4.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame + IkConstraintTimeline4.PREV_STRETCH] != 0;
        }
      }
    };
    IkConstraintTimeline4.ENTRIES = 5;
    IkConstraintTimeline4.PREV_TIME = -5;
    IkConstraintTimeline4.PREV_MIX = -4;
    IkConstraintTimeline4.PREV_BEND_DIRECTION = -3;
    IkConstraintTimeline4.PREV_COMPRESS = -2;
    IkConstraintTimeline4.PREV_STRETCH = -1;
    IkConstraintTimeline4.MIX = 1;
    IkConstraintTimeline4.BEND_DIRECTION = 2;
    IkConstraintTimeline4.COMPRESS = 3;
    IkConstraintTimeline4.STRETCH = 4;
    return IkConstraintTimeline4;
  }(CurveTimeline2)
);
var TransformConstraintTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(TransformConstraintTimeline4, _super);
    function TransformConstraintTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline4.ENTRIES);
      return _this;
    }
    TransformConstraintTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.transformConstraint << 24) + this.transformConstraintIndex;
    };
    TransformConstraintTimeline4.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
      frameIndex *= TransformConstraintTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TransformConstraintTimeline4.ROTATE] = rotateMix;
      this.frames[frameIndex + TransformConstraintTimeline4.TRANSLATE] = translateMix;
      this.frames[frameIndex + TransformConstraintTimeline4.SCALE] = scaleMix;
      this.frames[frameIndex + TransformConstraintTimeline4.SHEAR] = shearMix;
    };
    TransformConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (time < frames[0]) {
        var data = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = data.rotateMix;
            constraint.translateMix = data.translateMix;
            constraint.scaleMix = data.scaleMix;
            constraint.shearMix = data.shearMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
        }
        return;
      }
      var rotate = 0, translate = 0, scale = 0, shear = 0;
      if (time >= frames[frames.length - TransformConstraintTimeline4.ENTRIES]) {
        var i = frames.length;
        rotate = frames[i + TransformConstraintTimeline4.PREV_ROTATE];
        translate = frames[i + TransformConstraintTimeline4.PREV_TRANSLATE];
        scale = frames[i + TransformConstraintTimeline4.PREV_SCALE];
        shear = frames[i + TransformConstraintTimeline4.PREV_SHEAR];
      } else {
        var frame = Animation2.binarySearch(frames, time, TransformConstraintTimeline4.ENTRIES);
        rotate = frames[frame + TransformConstraintTimeline4.PREV_ROTATE];
        translate = frames[frame + TransformConstraintTimeline4.PREV_TRANSLATE];
        scale = frames[frame + TransformConstraintTimeline4.PREV_SCALE];
        shear = frames[frame + TransformConstraintTimeline4.PREV_SHEAR];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / TransformConstraintTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline4.PREV_TIME] - frameTime));
        rotate += (frames[frame + TransformConstraintTimeline4.ROTATE] - rotate) * percent;
        translate += (frames[frame + TransformConstraintTimeline4.TRANSLATE] - translate) * percent;
        scale += (frames[frame + TransformConstraintTimeline4.SCALE] - scale) * percent;
        shear += (frames[frame + TransformConstraintTimeline4.SHEAR] - shear) * percent;
      }
      if (blend == MixBlend.setup) {
        var data = constraint.data;
        constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
        constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
        constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
        constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
        constraint.translateMix += (translate - constraint.translateMix) * alpha;
        constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
        constraint.shearMix += (shear - constraint.shearMix) * alpha;
      }
    };
    TransformConstraintTimeline4.ENTRIES = 5;
    TransformConstraintTimeline4.PREV_TIME = -5;
    TransformConstraintTimeline4.PREV_ROTATE = -4;
    TransformConstraintTimeline4.PREV_TRANSLATE = -3;
    TransformConstraintTimeline4.PREV_SCALE = -2;
    TransformConstraintTimeline4.PREV_SHEAR = -1;
    TransformConstraintTimeline4.ROTATE = 1;
    TransformConstraintTimeline4.TRANSLATE = 2;
    TransformConstraintTimeline4.SCALE = 3;
    TransformConstraintTimeline4.SHEAR = 4;
    return TransformConstraintTimeline4;
  }(CurveTimeline2)
);
var PathConstraintPositionTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(PathConstraintPositionTimeline4, _super);
    function PathConstraintPositionTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline4.ENTRIES);
      return _this;
    }
    PathConstraintPositionTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    PathConstraintPositionTimeline4.prototype.setFrame = function(frameIndex, time, value) {
      frameIndex *= PathConstraintPositionTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintPositionTimeline4.VALUE] = value;
    };
    PathConstraintPositionTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha;
        }
        return;
      }
      var position = 0;
      if (time >= frames[frames.length - PathConstraintPositionTimeline4.ENTRIES])
        position = frames[frames.length + PathConstraintPositionTimeline4.PREV_VALUE];
      else {
        var frame = Animation2.binarySearch(frames, time, PathConstraintPositionTimeline4.ENTRIES);
        position = frames[frame + PathConstraintPositionTimeline4.PREV_VALUE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline4.PREV_TIME] - frameTime));
        position += (frames[frame + PathConstraintPositionTimeline4.VALUE] - position) * percent;
      }
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
      else
        constraint.position += (position - constraint.position) * alpha;
    };
    PathConstraintPositionTimeline4.ENTRIES = 2;
    PathConstraintPositionTimeline4.PREV_TIME = -2;
    PathConstraintPositionTimeline4.PREV_VALUE = -1;
    PathConstraintPositionTimeline4.VALUE = 1;
    return PathConstraintPositionTimeline4;
  }(CurveTimeline2)
);
var PathConstraintSpacingTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(PathConstraintSpacingTimeline4, _super);
    function PathConstraintSpacingTimeline4(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    PathConstraintSpacingTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    PathConstraintSpacingTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
        }
        return;
      }
      var spacing = 0;
      if (time >= frames[frames.length - PathConstraintSpacingTimeline4.ENTRIES])
        spacing = frames[frames.length + PathConstraintSpacingTimeline4.PREV_VALUE];
      else {
        var frame = Animation2.binarySearch(frames, time, PathConstraintSpacingTimeline4.ENTRIES);
        spacing = frames[frame + PathConstraintSpacingTimeline4.PREV_VALUE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline4.PREV_TIME] - frameTime));
        spacing += (frames[frame + PathConstraintSpacingTimeline4.VALUE] - spacing) * percent;
      }
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha;
    };
    return PathConstraintSpacingTimeline4;
  }(PathConstraintPositionTimeline2)
);
var PathConstraintMixTimeline2 = (
  /** @class */
  function(_super) {
    __extends3(PathConstraintMixTimeline4, _super);
    function PathConstraintMixTimeline4(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline4.ENTRIES);
      return _this;
    }
    PathConstraintMixTimeline4.prototype.getPropertyId = function() {
      return (TimelineType2.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    PathConstraintMixTimeline4.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
      frameIndex *= PathConstraintMixTimeline4.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintMixTimeline4.ROTATE] = rotateMix;
      this.frames[frameIndex + PathConstraintMixTimeline4.TRANSLATE] = translateMix;
    };
    PathConstraintMixTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = constraint.data.rotateMix;
            constraint.translateMix = constraint.data.translateMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
        }
        return;
      }
      var rotate = 0, translate = 0;
      if (time >= frames[frames.length - PathConstraintMixTimeline4.ENTRIES]) {
        rotate = frames[frames.length + PathConstraintMixTimeline4.PREV_ROTATE];
        translate = frames[frames.length + PathConstraintMixTimeline4.PREV_TRANSLATE];
      } else {
        var frame = Animation2.binarySearch(frames, time, PathConstraintMixTimeline4.ENTRIES);
        rotate = frames[frame + PathConstraintMixTimeline4.PREV_ROTATE];
        translate = frames[frame + PathConstraintMixTimeline4.PREV_TRANSLATE];
        var frameTime = frames[frame];
        var percent = this.getCurvePercent(frame / PathConstraintMixTimeline4.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline4.PREV_TIME] - frameTime));
        rotate += (frames[frame + PathConstraintMixTimeline4.ROTATE] - rotate) * percent;
        translate += (frames[frame + PathConstraintMixTimeline4.TRANSLATE] - translate) * percent;
      }
      if (blend == MixBlend.setup) {
        constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
        constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
        constraint.translateMix += (translate - constraint.translateMix) * alpha;
      }
    };
    PathConstraintMixTimeline4.ENTRIES = 3;
    PathConstraintMixTimeline4.PREV_TIME = -3;
    PathConstraintMixTimeline4.PREV_ROTATE = -2;
    PathConstraintMixTimeline4.PREV_TRANSLATE = -1;
    PathConstraintMixTimeline4.ROTATE = 1;
    PathConstraintMixTimeline4.TRANSLATE = 2;
    return PathConstraintMixTimeline4;
  }(CurveTimeline2)
);
var AnimationState2 = (
  /** @class */
  function() {
    function AnimationState4(data) {
      this.tracks = new Array();
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue2(this);
      this.propertyIDs = new IntSet();
      this.animationsChanged = false;
      this.timeScale = 1;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry2();
      });
      this.data = data;
    }
    AnimationState4.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i = 0, n = tracks.length; i < n; i++) {
        var current = tracks[i];
        if (current == null)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next = current.next;
        if (next != null) {
          var nextTime = current.trackLast - next.delay;
          if (nextTime >= 0) {
            next.delay = 0;
            next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i, next, true);
            while (next.mixingFrom != null) {
              next.mixTime += delta;
              next = next.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
          tracks[i] = null;
          this.queue.end(current);
          this.disposeNext(current);
          continue;
        }
        if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
          var from = current.mixingFrom;
          current.mixingFrom = null;
          if (from != null)
            from.mixingTo = null;
          while (from != null) {
            this.queue.end(from);
            from = from.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState4.prototype.updateMixingFrom = function(to, delta) {
      var from = to.mixingFrom;
      if (from == null)
        return true;
      var finished = this.updateMixingFrom(from, delta);
      from.animationLast = from.nextAnimationLast;
      from.trackLast = from.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from.mixingFrom;
          if (from.mixingFrom != null)
            from.mixingFrom.mixingTo = to;
          to.interruptAlpha = from.interruptAlpha;
          this.queue.end(from);
        }
        return finished;
      }
      from.trackTime += delta * from.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState4.prototype.apply = function(skeleton) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i = 0, n = tracks.length; i < n; i++) {
        var current = tracks[i];
        if (current == null || current.delay > 0)
          continue;
        applied = true;
        var blend = i == 0 ? MixBlend.first : current.mixBlend;
        var mix = current.alpha;
        if (current.mixingFrom != null)
          mix *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && current.next == null)
          mix = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime();
        var timelineCount = current.animation.timelines.length;
        var timelines = current.animation.timelines;
        if (i == 0 && mix == 1 || blend == MixBlend.add) {
          for (var ii = 0; ii < timelineCount; ii++) {
            Utils.webkit602BugfixHelper(mix, blend);
            timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var firstFrame = current.timelinesRotation.length == 0;
          if (firstFrame)
            Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = current.timelinesRotation;
          for (var ii = 0; ii < timelineCount; ii++) {
            var timeline = timelines[ii];
            var timelineBlend = timelineMode[ii] == AnimationState4.SUBSEQUENT ? blend : MixBlend.setup;
            if (timeline instanceof RotateTimeline2) {
              this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
            } else {
              Utils.webkit602BugfixHelper(mix, blend);
              timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      this.queue.drain();
      return applied;
    };
    AnimationState4.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from = to.mixingFrom;
      if (from.mixingFrom != null)
        this.applyMixingFrom(from, skeleton, blend);
      var mix = 0;
      if (to.mixDuration == 0) {
        mix = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix = to.mixTime / to.mixDuration;
        if (mix > 1)
          mix = 1;
        if (blend != MixBlend.first)
          blend = from.mixBlend;
      }
      var events = mix < from.eventThreshold ? this.events : null;
      var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
      var animationLast = from.animationLast, animationTime = from.getAnimationTime();
      var timelineCount = from.animation.timelines.length;
      var timelines = from.animation.timelines;
      var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
      if (blend == MixBlend.add) {
        for (var i = 0; i < timelineCount; i++)
          timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from.timelineMode;
        var timelineHoldMix = from.timelineHoldMix;
        var firstFrame = from.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
        var timelinesRotation = from.timelinesRotation;
        from.totalAlpha = 0;
        for (var i = 0; i < timelineCount; i++) {
          var timeline = timelines[i];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha = 0;
          switch (timelineMode[i]) {
            case AnimationState4.SUBSEQUENT:
              if (!attachments && timeline instanceof AttachmentTimeline2)
                continue;
              if (!drawOrder && timeline instanceof DrawOrderTimeline2)
                continue;
              timelineBlend = blend;
              alpha = alphaMix;
              break;
            case AnimationState4.FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaMix;
              break;
            case AnimationState4.HOLD:
              timelineBlend = MixBlend.setup;
              alpha = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i];
              alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from.totalAlpha += alpha;
          if (timeline instanceof RotateTimeline2)
            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
          else {
            Utils.webkit602BugfixHelper(alpha, blend);
            if (timelineBlend == MixBlend.setup) {
              if (timeline instanceof AttachmentTimeline2) {
                if (attachments)
                  direction = MixDirection.mixOut;
              } else if (timeline instanceof DrawOrderTimeline2) {
                if (drawOrder)
                  direction = MixDirection.mixOut;
              }
            }
            timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from, animationTime);
      this.events.length = 0;
      from.nextAnimationLast = animationTime;
      from.nextTrackLast = from.trackTime;
      return mix;
    };
    AnimationState4.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
      if (firstFrame)
        timelinesRotation[i] = 0;
      if (alpha == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var rotateTimeline = timeline;
      var frames = rotateTimeline.frames;
      var bone = skeleton.bones[rotateTimeline.boneIndex];
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        if (time >= frames[frames.length - RotateTimeline2.ENTRIES])
          r2 = bone.data.rotation + frames[frames.length + RotateTimeline2.PREV_ROTATION];
        else {
          var frame = Animation2.binarySearch(frames, time, RotateTimeline2.ENTRIES);
          var prevRotation = frames[frame + RotateTimeline2.PREV_ROTATION];
          var frameTime = frames[frame];
          var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline2.PREV_TIME] - frameTime));
          r2 = frames[frame + RotateTimeline2.ROTATION] - prevRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          r2 = prevRotation + r2 * percent + bone.data.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        }
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i];
          lastDiff = timelinesRotation[i + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i] = total;
      }
      timelinesRotation[i + 1] = diff;
      r1 += total * alpha;
      bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
    };
    AnimationState4.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i = 0, n = events.length;
      for (; i < n; i++) {
        var event_1 = events[i];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i < n; i++) {
        var event_2 = events[i];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, events[i]);
      }
    };
    AnimationState4.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++)
        this.clearTrack(i);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (current == null)
        return;
      this.queue.end(current);
      this.disposeNext(current);
      var entry = current;
      while (true) {
        var from = entry.mixingFrom;
        if (from == null)
          break;
        this.queue.end(from);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState4.prototype.setCurrent = function(index, current, interrupt) {
      var from = this.expandToIndex(index);
      this.tracks[index] = current;
      if (from != null) {
        if (interrupt)
          this.queue.interrupt(from);
        current.mixingFrom = from;
        from.mixingTo = current;
        current.mixTime = 0;
        if (from.mixingFrom != null && from.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
        from.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState4.prototype.setAnimation = function(trackIndex, animationName, loop) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (animation == null)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation, loop);
    };
    AnimationState4.prototype.setAnimationWith = function(trackIndex, animation, loop) {
      if (animation == null)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current != null) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.disposeNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.disposeNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState4.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (animation == null)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation, loop, delay);
    };
    AnimationState4.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
      if (animation == null)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last != null) {
        while (last.next != null)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation, loop, last);
      if (last == null) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        if (delay <= 0) {
          var duration = last.animationEnd - last.animationStart;
          if (duration != 0) {
            if (last.loop)
              delay += duration * (1 + (last.trackTime / duration | 0));
            else
              delay += Math.max(duration, last.trackTime);
            delay -= this.data.getMix(last.animation, animation);
          } else
            delay = last.trackTime;
        }
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      var entry = this.setAnimationWith(trackIndex, AnimationState4.emptyAnimation, false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (delay <= 0)
        delay -= mixDuration;
      var entry = this.addAnimationWith(trackIndex, AnimationState4.emptyAnimation, false, delay);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimations = function(mixDuration) {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++) {
        var current = this.tracks[i];
        if (current != null)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.expandToIndex = function(index) {
      if (index < this.tracks.length)
        return this.tracks[index];
      Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
      this.tracks.length = index + 1;
      return null;
    };
    AnimationState4.prototype.trackEntry = function(trackIndex, animation, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.trackIndex = trackIndex;
      entry.animation = animation;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.interruptAlpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
      return entry;
    };
    AnimationState4.prototype.disposeNext = function(entry) {
      var next = entry.next;
      while (next != null) {
        this.queue.dispose(next);
        next = next.next;
      }
      entry.next = null;
    };
    AnimationState4.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      for (var i = 0, n = this.tracks.length; i < n; i++) {
        var entry = this.tracks[i];
        if (entry == null)
          continue;
        while (entry.mixingFrom != null)
          entry = entry.mixingFrom;
        do {
          if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
            this.setTimelineModes(entry);
          entry = entry.mixingTo;
        } while (entry != null);
      }
    };
    AnimationState4.prototype.setTimelineModes = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
      entry.timelineHoldMix.length = 0;
      var timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
      var propertyIDs = this.propertyIDs;
      if (to != null && to.holdPrevious) {
        for (var i = 0; i < timelinesCount; i++) {
          propertyIDs.add(timelines[i].getPropertyId());
          timelineMode[i] = AnimationState4.HOLD;
        }
        return;
      }
      outer: for (var i = 0; i < timelinesCount; i++) {
        var id = timelines[i].getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = AnimationState4.SUBSEQUENT;
        else if (to == null || !this.hasTimeline(to, id))
          timelineMode[i] = AnimationState4.FIRST;
        else {
          for (var next = to.mixingTo; next != null; next = next.mixingTo) {
            if (this.hasTimeline(next, id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = AnimationState4.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = AnimationState4.HOLD;
        }
      }
    };
    AnimationState4.prototype.hasTimeline = function(entry, id) {
      var timelines = entry.animation.timelines;
      for (var i = 0, n = timelines.length; i < n; i++)
        if (timelines[i].getPropertyId() == id)
          return true;
      return false;
    };
    AnimationState4.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState4.prototype.addListener = function(listener) {
      if (listener == null)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState4.prototype.removeListener = function(listener) {
      var index = this.listeners.indexOf(listener);
      if (index >= 0)
        this.listeners.splice(index, 1);
    };
    AnimationState4.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState4.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState4.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState4.deprecatedWarning1) {
        AnimationState4.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState4.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState4.deprecatedWarning2) {
        AnimationState4.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState4.prototype.hasAnimation = function(animationName) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      return animation !== null;
    };
    AnimationState4.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState4.deprecatedWarning3) {
        AnimationState4.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState4.emptyAnimation = new Animation2("<empty>", [], 0);
    AnimationState4.SUBSEQUENT = 0;
    AnimationState4.FIRST = 1;
    AnimationState4.HOLD = 2;
    AnimationState4.HOLD_MIX = 3;
    AnimationState4.deprecatedWarning1 = false;
    AnimationState4.deprecatedWarning2 = false;
    AnimationState4.deprecatedWarning3 = false;
    return AnimationState4;
  }()
);
var TrackEntry2 = (
  /** @class */
  function() {
    function TrackEntry4() {
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry4.prototype.reset = function() {
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry4.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry4.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry4.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry4.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    Object.defineProperty(TrackEntry4.prototype, "time", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry4.prototype, "endTime", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry4.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry4.deprecatedWarning1 = false;
    TrackEntry4.deprecatedWarning2 = false;
    return TrackEntry4;
  }()
);
var EventQueue2 = (
  /** @class */
  function() {
    function EventQueue4(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue4.prototype.start = function(entry) {
      this.objects.push(EventType2.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.interrupt = function(entry) {
      this.objects.push(EventType2.interrupt);
      this.objects.push(entry);
    };
    EventQueue4.prototype.end = function(entry) {
      this.objects.push(EventType2.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.dispose = function(entry) {
      this.objects.push(EventType2.dispose);
      this.objects.push(entry);
    };
    EventQueue4.prototype.complete = function(entry) {
      this.objects.push(EventType2.complete);
      this.objects.push(entry);
    };
    EventQueue4.prototype.event = function(entry, event) {
      this.objects.push(EventType2.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue4.prototype.deprecateStuff = function() {
      if (!EventQueue4.deprecatedWarning1) {
        EventQueue4.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'");
      }
      return true;
    };
    EventQueue4.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i = 0; i < objects.length; i += 2) {
        var type = objects[i];
        var entry = objects[i + 1];
        switch (type) {
          case EventType2.start:
            if (entry.listener != null && entry.listener.start)
              entry.listener.start(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].start)
                listeners[ii].start(entry);
            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
            break;
          case EventType2.interrupt:
            if (entry.listener != null && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].interrupt)
                listeners[ii].interrupt(entry);
            break;
          case EventType2.end:
            if (entry.listener != null && entry.listener.end)
              entry.listener.end(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].end)
                listeners[ii].end(entry);
            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
          case EventType2.dispose:
            if (entry.listener != null && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].dispose)
                listeners[ii].dispose(entry);
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType2.complete:
            if (entry.listener != null && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].complete)
                listeners[ii].complete(entry);
            var count = MathUtils.toInt(entry.loopsCount());
            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
            break;
          case EventType2.event:
            var event_3 = objects[i++ + 2];
            if (entry.listener != null && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii = 0; ii < listeners.length; ii++)
              if (listeners[ii].event)
                listeners[ii].event(entry, event_3);
            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue4.prototype.clear = function() {
      this.objects.length = 0;
    };
    EventQueue4.deprecatedWarning1 = false;
    return EventQueue4;
  }()
);
var EventType2;
(function(EventType4) {
  EventType4[EventType4["start"] = 0] = "start";
  EventType4[EventType4["interrupt"] = 1] = "interrupt";
  EventType4[EventType4["end"] = 2] = "end";
  EventType4[EventType4["dispose"] = 3] = "dispose";
  EventType4[EventType4["complete"] = 4] = "complete";
  EventType4[EventType4["event"] = 5] = "event";
})(EventType2 || (EventType2 = {}));
var AnimationStateAdapter2 = (
  /** @class */
  function() {
    function AnimationStateAdapter22() {
    }
    AnimationStateAdapter22.prototype.start = function(entry) {
    };
    AnimationStateAdapter22.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter22.prototype.end = function(entry) {
    };
    AnimationStateAdapter22.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter22.prototype.complete = function(entry) {
    };
    AnimationStateAdapter22.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter22;
  }()
);
var AnimationStateData2 = (
  /** @class */
  function() {
    function AnimationStateData4(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (skeletonData == null)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData4.prototype.setMix = function(fromName, toName, duration) {
      var from = this.skeletonData.findAnimation(fromName);
      if (from == null)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (to == null)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from, to, duration);
    };
    AnimationStateData4.prototype.setMixByName = function(fromName, toName, duration) {
      if (!AnimationStateData4.deprecatedWarning1) {
        AnimationStateData4.deprecatedWarning1 = true;
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
      }
      this.setMix(fromName, toName, duration);
    };
    AnimationStateData4.prototype.setMixWith = function(from, to, duration) {
      if (from == null)
        throw new Error("from cannot be null.");
      if (to == null)
        throw new Error("to cannot be null.");
      var key = from.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData4.prototype.getMix = function(from, to) {
      var key = from.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    AnimationStateData4.deprecatedWarning1 = false;
    return AnimationStateData4;
  }()
);
var AtlasAttachmentLoader2 = (
  /** @class */
  function() {
    function AtlasAttachmentLoader4(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader4.prototype.newRegionAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
      var attachment = new RegionAttachment2(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newMeshAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
      var attachment = new MeshAttachment2(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment2(name);
    };
    AtlasAttachmentLoader4.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment2(name);
    };
    AtlasAttachmentLoader4.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment2(name);
    };
    AtlasAttachmentLoader4.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment2(name);
    };
    return AtlasAttachmentLoader4;
  }()
);
var Bone2 = (
  /** @class */
  function() {
    function Bone4(data, skeleton, parent) {
      this.matrix = new Matrix();
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.appliedValid = false;
      this.sorted = false;
      this.active = true;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone4.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone4.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone4.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone4.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone4.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      this.appliedValid = true;
      var parent = this.parent;
      var m = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
      if (parent == null) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m.tx = x * sx + skeleton.x;
        m.ty = y * sy + skeleton.y;
        return;
      }
      var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
      m.tx = pa * x + pb * y + parent.matrix.tx;
      m.ty = pc * x + pd * y + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb = MathUtils.cosDeg(rotationY) * scaleY;
          var lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld = MathUtils.sinDeg(rotationY) * scaleY;
          m.a = pa * la + pb * lc;
          m.c = pa * lb + pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m.c = MathUtils.cosDeg(rotationY) * scaleY;
          m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s = pa * pa + pc * pc;
          var prx = 0;
          if (s > 1e-4) {
            s = Math.abs(pa * pd - pb * pc) / s;
            pb = pc * s;
            pd = pa * s;
            prx = Math.atan2(pc, pa) * MathUtils.radDeg;
          } else {
            pa = 0;
            pc = 0;
            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la = MathUtils.cosDeg(rx) * scaleX;
          var lb = MathUtils.cosDeg(ry) * scaleY;
          var lc = MathUtils.sinDeg(rx) * scaleX;
          var ld = MathUtils.sinDeg(ry) * scaleY;
          m.a = pa * la - pb * lc;
          m.c = pa * lb - pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za = (pa * cos + pb * sin) / sx;
          var zc = (pc * cos + pd * sin) / sy;
          var s = Math.sqrt(za * za + zc * zc);
          if (s > 1e-5)
            s = 1 / s;
          za *= s;
          zc *= s;
          s = Math.sqrt(za * za + zc * zc);
          if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
            s = -s;
          var r = Math.PI / 2 + Math.atan2(zc, za);
          var zb = Math.cos(r) * s;
          var zd = Math.sin(r) * s;
          var la = MathUtils.cosDeg(shearX) * scaleX;
          var lb = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc = MathUtils.sinDeg(shearX) * scaleX;
          var ld = MathUtils.sinDeg(90 + shearY) * scaleY;
          m.a = za * la + zb * lc;
          m.c = za * lb + zb * ld;
          m.b = zc * la + zd * lc;
          m.d = zc * lb + zd * ld;
          break;
        }
      }
      m.a *= sx;
      m.c *= sx;
      m.b *= sy;
      m.d *= sy;
    };
    Bone4.prototype.setToSetupPose = function() {
      var data = this.data;
      this.x = data.x;
      this.y = data.y;
      this.rotation = data.rotation;
      this.scaleX = data.scaleX;
      this.scaleY = data.scaleY;
      this.shearX = data.shearX;
      this.shearY = data.shearY;
    };
    Bone4.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldScaleX = function() {
      var m = this.matrix;
      return Math.sqrt(m.a * m.a + m.c * m.c);
    };
    Bone4.prototype.getWorldScaleY = function() {
      var m = this.matrix;
      return Math.sqrt(m.b * m.b + m.d * m.d);
    };
    Bone4.prototype.updateAppliedTransform = function() {
      this.appliedValid = true;
      var parent = this.parent;
      var m = this.matrix;
      if (parent == null) {
        this.ax = m.tx;
        this.ay = m.ty;
        this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
        this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m.tx - pm.tx, dy = m.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia = pid * pm.d;
      var id = pid * pm.a;
      var ib = pid * pm.c;
      var ic = pid * pm.b;
      var ra = ia * m.a - ib * m.b;
      var rb = ia * m.c - ib * m.d;
      var rc = id * m.b - ic * m.a;
      var rd = id * m.d - ic * m.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra * ra + rc * rc);
      if (this.ascaleX > 1e-4) {
        var det = ra * rd - rb * rc;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb * rb + rd * rd);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
      }
    };
    Bone4.prototype.worldToLocal = function(world) {
      var m = this.matrix;
      var a = m.a, b = m.c, c = m.b, d = m.d;
      var invDet = 1 / (a * d - b * c);
      var x = world.x - m.tx, y = world.y - m.ty;
      world.x = x * d * invDet - y * b * invDet;
      world.y = y * a * invDet - x * c * invDet;
      return world;
    };
    Bone4.prototype.localToWorld = function(local) {
      var m = this.matrix;
      var x = local.x, y = local.y;
      local.x = x * m.a + y * m.c + m.tx;
      local.y = x * m.b + y * m.d + m.ty;
      return local;
    };
    Bone4.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone4.prototype.localToWorldRotation = function(localRotation) {
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone4.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a - sin * c;
      mat.c = cos * b - sin * d;
      mat.b = sin * a + cos * c;
      mat.d = sin * b + cos * d;
      this.appliedValid = false;
    };
    return Bone4;
  }()
);
var BoneData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoneData4(index, name, parent) {
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      this.index = index;
      this.name = name;
      this.parent = parent;
    }
    return BoneData4;
  }()
);
var Event2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Event4(time, data) {
      if (data == null)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data;
    }
    return Event4;
  }()
);
var EventData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventData4(name) {
      this.name = name;
    }
    return EventData4;
  }()
);
var IkConstraint2 = (
  /** @class */
  function() {
    function IkConstraint4(data, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.mix = data.mix;
      this.bendDirection = data.bendDirection;
      this.compress = data.compress;
      this.stretch = data.stretch;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findBone(data.target.name);
    }
    IkConstraint4.prototype.getOrder = function() {
      return this.data.order;
    };
    IkConstraint4.prototype.apply = function() {
      this.update();
    };
    IkConstraint4.prototype.update = function() {
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);
          break;
      }
    };
    IkConstraint4.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha) {
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      var p = bone.parent.matrix;
      var id = 1 / (p.a * p.d - p.b * p.c);
      var x = targetX - p.tx, y = targetY - p.ty;
      var tx = (x * p.d - y * p.c) * id - bone.ax, ty = (y * p.a - x * p.b) * id - bone.ay;
      var rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd < b || stretch && dd > b && b > 1e-4) {
          var s = (dd / b - 1) * alpha + 1;
          sx *= s;
          if (uniform)
            sy *= s;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint4.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, alpha) {
      if (alpha == 0) {
        child.updateWorldTransform();
        return;
      }
      if (!parent.appliedValid)
        parent.updateAppliedTransform();
      if (!child.appliedValid)
        child.updateAppliedTransform();
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;
      var u = Math.abs(psx - psy) <= 1e-4;
      if (!u) {
        cy = 0;
        cwx = a * cx + pmat.tx;
        cwy = c * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a * cx + b * cy + pmat.tx;
        cwy = c * cx + d * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      a = pp.a;
      b = pp.c;
      c = pp.b;
      d = pp.d;
      var id = 1 / (a * d - b * c), x = targetX - pp.tx, y = targetY - pp.ty;
      var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py, dd = tx * tx + ty * ty;
      x = cwx - pp.tx;
      y = cwy - pp.ty;
      var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;
      outer: if (u) {
        l2 *= psx;
        var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch && l1 + l2 > 1e-4)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        var c1 = -2 * bb * l1, c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          var q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          var r0 = q / c2, r1 = c / q;
          var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        var minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
        var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
      rotation = child.arotation;
      a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a2 > 180)
        a2 -= 360;
      else if (a2 < -180)
        a2 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint4;
  }()
);
var IkConstraintData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function IkConstraintData4(name) {
      this.order = 0;
      this.bones = new Array();
      this.bendDirection = 1;
      this.compress = false;
      this.stretch = false;
      this.uniform = false;
      this.mix = 1;
      this.name = name;
    }
    return IkConstraintData4;
  }()
);
var PathConstraintData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathConstraintData4(name) {
      this.order = 0;
      this.bones = new Array();
      this.name = name;
    }
    return PathConstraintData4;
  }()
);
var SpacingMode2;
(function(SpacingMode4) {
  SpacingMode4[SpacingMode4["Length"] = 0] = "Length";
  SpacingMode4[SpacingMode4["Fixed"] = 1] = "Fixed";
  SpacingMode4[SpacingMode4["Percent"] = 2] = "Percent";
})(SpacingMode2 || (SpacingMode2 = {}));
var PathConstraint2 = (
  /** @class */
  function() {
    function PathConstraint4(data, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.rotateMix = 0;
      this.translateMix = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0, n = data.bones.length; i < n; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findSlot(data.target.name);
      this.position = data.position;
      this.spacing = data.spacing;
      this.rotateMix = data.rotateMix;
      this.translateMix = data.translateMix;
    }
    PathConstraint4.prototype.apply = function() {
      this.update();
    };
    PathConstraint4.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment2))
        return;
      var rotateMix = this.rotateMix, translateMix = this.translateMix;
      var translate = translateMix > 0, rotate = rotateMix > 0;
      if (!translate && !rotate)
        return;
      var data = this.data;
      var spacingMode = data.spacingMode;
      var lengthSpacing = spacingMode == SpacingMode2.Length;
      var rotateMode = data.rotateMode;
      var tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;
      var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var bones = this.bones;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = null;
      var spacing = this.spacing;
      if (scale || lengthSpacing) {
        if (scale)
          lengths = Utils.setArraySize(this.lengths, boneCount);
        for (var i = 0, n = spacesCount - 1; i < n; ) {
          var bone = bones[i];
          var setupLength = bone.data.length;
          if (setupLength < PathConstraint4.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = 0;
          } else {
            var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
            var length_1 = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length_1;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
          }
        }
      } else {
        for (var i = 1; i < spacesCount; i++)
          spaces[i] = spacing;
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == PositionMode.Percent, spacingMode == SpacingMode2.Percent);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
        var bone = bones[i];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * translateMix;
        mat.ty += (boneY - mat.ty) * translateMix;
        var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
        if (scale) {
          var length_2 = lengths[i];
          if (length_2 != 0) {
            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
            mat.a *= s;
            mat.b *= s;
          }
        }
        boneX = x;
        boneY = y;
        if (rotate) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
          r -= Math.atan2(c, a);
          if (tip) {
            cos = Math.cos(r);
            sin = Math.sin(r);
            var length_3 = bone.data.length;
            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
          } else {
            r += offsetRotation;
          }
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          cos = Math.cos(r);
          sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
        }
        bone.appliedValid = false;
      }
    };
    PathConstraint4.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
      var target = this.target;
      var position = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint4.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (percentPosition)
          position *= pathLength_1;
        if (percentSpacing) {
          for (var i = 0; i < spacesCount; i++)
            spaces[i] *= pathLength_1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
          var space = spaces[i];
          position += space;
          var p = position;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint4.BEFORE) {
              prevCurve = PathConstraint4.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint4.AFTER) {
              prevCurve = PathConstraint4.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o);
            continue;
          }
          for (; ; curve++) {
            var length_4 = lengths[curve];
            if (p > length_4)
              continue;
            if (curve == 0)
              p /= length_4;
            else {
              var prev = lengths[curve - 1];
              p = (p - prev) / (length_4 - prev);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
        cx1 = world[w];
        cy1 = world[w + 1];
        cx2 = world[w + 2];
        cy2 = world[w + 3];
        x2 = world[w + 4];
        y2 = world[w + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (percentPosition)
        position *= pathLength;
      if (percentSpacing) {
        for (var i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
        var space = spaces[i];
        position += space;
        var p = position;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
          continue;
        }
        for (; ; curve++) {
          var length_5 = curves[curve];
          if (p > length_5)
            continue;
          if (curve == 0)
            p /= length_5;
          else {
            var prev = curves[curve - 1];
            p = (p - prev) / (length_5 - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii = curve * 6;
          x1 = world[ii];
          y1 = world[ii + 1];
          cx1 = world[ii + 2];
          cy1 = world[ii + 3];
          cx2 = world[ii + 4];
          cy2 = world[ii + 5];
          x2 = world[ii + 6];
          y2 = world[ii + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii = 1; ii < 8; ii++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_6 = segments[segment];
          if (p > length_6)
            continue;
          if (segment == 0)
            p /= length_6;
          else {
            var prev = segments[segment - 1];
            p = segment + (p - prev) / (length_6 - prev);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
      }
      return out;
    };
    PathConstraint4.prototype.addBeforePosition = function(p, temp, i, out, o) {
      var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addAfterPosition = function(p, temp, i, out, o) {
      var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
      if (p == 0 || isNaN(p))
        p = 1e-4;
      var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
      var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o] = x;
      out[o + 1] = y;
      if (tangents)
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    };
    PathConstraint4.prototype.getOrder = function() {
      return this.data.order;
    };
    PathConstraint4.NONE = -1;
    PathConstraint4.BEFORE = -2;
    PathConstraint4.AFTER = -3;
    PathConstraint4.epsilon = 1e-5;
    return PathConstraint4;
  }()
);
var TransformConstraint2 = (
  /** @class */
  function() {
    function TransformConstraint4(data, skeleton) {
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.temp = new Vector2();
      if (data == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.rotateMix = data.rotateMix;
      this.translateMix = data.translateMix;
      this.scaleMix = data.scaleMix;
      this.shearMix = data.shearMix;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
      this.target = skeleton.findBone(data.target.name);
    }
    TransformConstraint4.prototype.apply = function() {
      this.update();
    };
    TransformConstraint4.prototype.update = function() {
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint4.prototype.applyAbsoluteWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
          modified = true;
        }
        if (translateMix != 0) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp.x - mat.tx) * translateMix;
          mat.ty += (temp.y - mat.ty) * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          var ts = Math.sqrt(ta * ta + tc * tc);
          if (s > 1e-5)
            s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
          mat.a *= s;
          mat.b *= s;
          s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          ts = Math.sqrt(tb * tb + td * td);
          if (s > 1e-5)
            s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
          mat.c *= s;
          mat.d *= s;
          modified = true;
        }
        if (shearMix > 0) {
          var b = mat.c, d = mat.d;
          var by = Math.atan2(d, b);
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r = by + (r + offsetShearY) * shearMix;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint4.prototype.applyRelativeWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= rotateMix;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
          modified = true;
        }
        if (translateMix != 0) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp.x * translateMix;
          mat.ty += temp.y * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
          mat.a *= s;
          mat.b *= s;
          s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
          mat.c *= s;
          mat.d *= s;
          modified = true;
        }
        if (shearMix > 0) {
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          var b = mat.c, d = mat.d;
          r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint4.prototype.applyAbsoluteLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0) {
          var r = target.arotation - rotation + this.data.offsetRotation;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          rotation += r * rotateMix;
        }
        var x = bone.ax, y = bone.ay;
        if (translateMix != 0) {
          x += (target.ax - x + this.data.offsetX) * translateMix;
          y += (target.ay - y + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
          if (scaleY > 1e-5)
            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0) {
          var r = target.ashearY - shearY + this.data.offsetShearY;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          bone.shearY += r * shearMix;
        }
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint4.prototype.applyRelativeLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0)
          rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
        var x = bone.ax, y = bone.ay;
        if (translateMix != 0) {
          x += (target.ax + this.data.offsetX) * translateMix;
          y += (target.ay + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
          if (scaleY > 1e-5)
            scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0)
          shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint4.prototype.getOrder = function() {
      return this.data.order;
    };
    return TransformConstraint4;
  }()
);
var Skeleton2 = (
  /** @class */
  function() {
    function Skeleton4(data) {
      this._updateCache = new Array();
      this.updateCacheReset = new Array();
      this.time = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (data == null)
        throw new Error("data cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++) {
        var boneData = data.bones[i];
        var bone = void 0;
        if (boneData.parent == null)
          bone = new Bone2(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone2(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i = 0; i < data.slots.length; i++) {
        var slotData = data.slots[i];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot2(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i = 0; i < data.ikConstraints.length; i++) {
        var ikConstraintData = data.ikConstraints[i];
        this.ikConstraints.push(new IkConstraint2(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i = 0; i < data.transformConstraints.length; i++) {
        var transformConstraintData = data.transformConstraints[i];
        this.transformConstraints.push(new TransformConstraint2(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i = 0; i < data.pathConstraints.length; i++) {
        var pathConstraintData = data.pathConstraints[i];
        this.pathConstraints.push(new PathConstraint2(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton4.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      this.updateCacheReset.length = 0;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        bones[i].sorted = false;
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer: for (var i = 0; i < constraintCount; i++) {
        for (var ii = 0; ii < ikCount; ii++) {
          var constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < transformCount; ii++) {
          var constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < pathCount; ii++) {
          var constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
      for (var i = 0, n = bones.length; i < n; i++)
        this.sortBone(bones[i]);
    };
    Skeleton4.prototype.sortIkConstraint = function(constraint) {
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length > 1) {
        var child = constrained[constrained.length - 1];
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      constrained[constrained.length - 1].sorted = true;
    };
    Skeleton4.prototype.sortPathConstraint = function(constraint) {
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin != null)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i = 0, n = this.data.skins.length; i < n; i++)
        this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment2)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i = 0; i < boneCount; i++)
        this.sortBone(constrained[i]);
      this._updateCache.push(constraint);
      for (var i = 0; i < boneCount; i++)
        this.sortReset(constrained[i].children);
      for (var i = 0; i < boneCount; i++)
        constrained[i].sorted = true;
    };
    Skeleton4.prototype.sortTransformConstraint = function(constraint) {
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i = 0; i < boneCount; i++) {
          var child = constrained[i];
          this.sortBone(child.parent);
          if (!(this._updateCache.indexOf(child) > -1))
            this.updateCacheReset.push(child);
        }
      } else {
        for (var i = 0; i < boneCount; i++) {
          this.sortBone(constrained[i]);
        }
      }
      this._updateCache.push(constraint);
      for (var ii = 0; ii < boneCount; ii++)
        this.sortReset(constrained[ii].children);
      for (var ii = 0; ii < boneCount; ii++)
        constrained[ii].sorted = true;
    };
    Skeleton4.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton4.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment2))
        return;
      var pathBones = attachment.bones;
      if (pathBones == null)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        var i = 0;
        while (i < pathBones.length) {
          var boneCount = pathBones[i++];
          for (var n = i + boneCount; i < n; i++) {
            var boneIndex = pathBones[i];
            this.sortBone(bones[boneIndex]);
          }
        }
      }
    };
    Skeleton4.prototype.sortBone = function(bone) {
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent != null)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton4.prototype.sortReset = function(bones) {
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton4.prototype.updateWorldTransform = function() {
      var updateCacheReset = this.updateCacheReset;
      for (var i = 0, n = updateCacheReset.length; i < n; i++) {
        var bone = updateCacheReset[i];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
        bone.appliedValid = true;
      }
      var updateCache = this._updateCache;
      for (var i = 0, n = updateCache.length; i < n; i++)
        updateCache[i].update();
    };
    Skeleton4.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton4.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        bones[i].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.mix = constraint.data.mix;
      }
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        var data = constraint.data;
        constraint.rotateMix = data.rotateMix;
        constraint.translateMix = data.translateMix;
        constraint.scaleMix = data.scaleMix;
        constraint.shearMix = data.shearMix;
      }
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        var data = constraint.data;
        constraint.position = data.position;
        constraint.spacing = data.spacing;
        constraint.rotateMix = data.rotateMix;
        constraint.translateMix = data.translateMix;
      }
    };
    Skeleton4.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i = 0, n = slots.length; i < n; i++)
        slots[i].setToSetupPose();
    };
    Skeleton4.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton4.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton4.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].data.name == boneName)
          return i;
      return -1;
    };
    Skeleton4.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton4.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].data.name == slotName)
          return i;
      return -1;
    };
    Skeleton4.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (skin == null)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton4.prototype.setSkin = function(newSkin) {
      if (newSkin != null) {
        if (this.skin != null)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            var name_1 = slot.data.attachmentName;
            if (name_1 != null) {
              var attachment = newSkin.getAttachment(i, name_1);
              if (attachment != null)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
    };
    Skeleton4.prototype.getAttachmentByName = function(slotName, attachmentName) {
      return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
    };
    Skeleton4.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (attachmentName == null)
        throw new Error("attachmentName cannot be null.");
      if (this.skin != null) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.defaultSkin != null)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton4.prototype.setAttachment = function(slotName, attachmentName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName != null) {
            attachment = this.getAttachment(i, attachmentName);
            if (attachment == null)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton4.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var ikConstraint = ikConstraints[i];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton4.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.getBounds = function(offset, size, temp) {
      if (offset == null)
        throw new Error("offset cannot be null.");
      if (size == null)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment2) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment2) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices != null) {
          for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
            var x = vertices[ii], y = vertices[ii + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Skeleton4.prototype.update = function(delta) {
      this.time += delta;
    };
    Object.defineProperty(Skeleton4.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton4.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton4.deprecatedWarning1 = false;
    return Skeleton4;
  }()
);
var SkeletonBounds2 = (
  /** @class */
  function(_super) {
    __extends3(SkeletonBounds4, _super);
    function SkeletonBounds4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds4;
  }(SkeletonBoundsBase)
);
var SkeletonData2 = (
  /** @class */
  function() {
    function SkeletonData4() {
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.fps = 0;
    }
    SkeletonData4.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData4.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].name == boneName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData4.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].name == slotName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSkin = function(skinName) {
      if (skinName == null)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i = 0, n = skins.length; i < n; i++) {
        var skin = skins[i];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData4.prototype.findEvent = function(eventDataName) {
      if (eventDataName == null)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i = 0, n = events.length; i < n; i++) {
        var event_1 = events[i];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData4.prototype.findAnimation = function(animationName) {
      if (animationName == null)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i = 0, n = animations.length; i < n; i++) {
        var animation = animations[i];
        if (animation.name == animationName)
          return animation;
      }
      return null;
    };
    SkeletonData4.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++)
        if (pathConstraints[i].name == pathConstraintName)
          return i;
      return -1;
    };
    return SkeletonData4;
  }()
);
var SlotData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function SlotData4(index, name, boneData) {
      this.color = new Color(1, 1, 1, 1);
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      if (boneData == null)
        throw new Error("boneData cannot be null.");
      this.index = index;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData4;
  }()
);
var TransformConstraintData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function TransformConstraintData4(name) {
      this.order = 0;
      this.bones = new Array();
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.offsetRotation = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.offsetScaleX = 0;
      this.offsetScaleY = 0;
      this.offsetShearY = 0;
      this.relative = false;
      this.local = false;
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return TransformConstraintData4;
  }()
);
var Skin2 = (
  /** @class */
  function() {
    function Skin4(name) {
      this.attachments = new Array();
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin4.prototype.addAttachment = function(slotIndex, name, attachment) {
      if (attachment == null)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin4.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin4.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i = 0; i < skeleton.slots.length; i++) {
        var slot = skeleton.slots[i];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment != null)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin4;
  }()
);
var SkeletonJson2 = (
  /** @class */
  function() {
    function SkeletonJson4(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson4.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData2();
      var root = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root.skeleton;
      if (skeletonMap != null) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root.bones) {
        for (var i = 0; i < root.bones.length; i++) {
          var boneMap = root.bones[i];
          var parent_1 = null;
          var parentName = this.getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data = new BoneData2(skeletonData.bones.length, boneMap.name, parent_1);
          data.length = this.getValue(boneMap, "length", 0) * scale;
          data.x = this.getValue(boneMap, "x", 0) * scale;
          data.y = this.getValue(boneMap, "y", 0) * scale;
          data.rotation = this.getValue(boneMap, "rotation", 0);
          data.scaleX = this.getValue(boneMap, "scaleX", 1);
          data.scaleY = this.getValue(boneMap, "scaleY", 1);
          data.shearX = this.getValue(boneMap, "shearX", 0);
          data.shearY = this.getValue(boneMap, "shearY", 0);
          data.transformMode = SkeletonJson4.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
          skeletonData.bones.push(data);
        }
      }
      if (root.slots) {
        for (var i = 0; i < root.slots.length; i++) {
          var slotMap = root.slots[i];
          var slotName = slotMap.name;
          var boneName = slotMap.bone;
          var boneData = skeletonData.findBone(boneName);
          if (boneData == null)
            throw new Error("Slot bone not found: " + boneName);
          var data = new SlotData2(skeletonData.slots.length, slotName, boneData);
          var color = this.getValue(slotMap, "color", null);
          if (color != null)
            data.color.setFromString(color);
          var dark = this.getValue(slotMap, "dark", null);
          if (dark != null) {
            data.darkColor = new Color(1, 1, 1, 1);
            data.darkColor.setFromString(dark);
          }
          data.attachmentName = this.getValue(slotMap, "attachment", null);
          data.blendMode = SkeletonJson4.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data);
        }
      }
      if (root.ik) {
        for (var i = 0; i < root.ik.length; i++) {
          var constraintMap = root.ik[i];
          var data = new IkConstraintData2(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findBone(targetName);
          if (data.target == null)
            throw new Error("IK target bone not found: " + targetName);
          data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data.mix = this.getValue(constraintMap, "mix", 1);
          skeletonData.ikConstraints.push(data);
        }
      }
      if (root.transform) {
        for (var i = 0; i < root.transform.length; i++) {
          var constraintMap = root.transform[i];
          var data = new TransformConstraintData2(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findBone(targetName);
          if (data.target == null)
            throw new Error("Transform constraint target bone not found: " + targetName);
          data.local = this.getValue(constraintMap, "local", false);
          data.relative = this.getValue(constraintMap, "relative", false);
          data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
          data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
          data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
          data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
          data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
          data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data.translateMix = this.getValue(constraintMap, "translateMix", 1);
          data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
          data.shearMix = this.getValue(constraintMap, "shearMix", 1);
          skeletonData.transformConstraints.push(data);
        }
      }
      if (root.path) {
        for (var i = 0; i < root.path.length; i++) {
          var constraintMap = root.path[i];
          var data = new PathConstraintData2(constraintMap.name);
          data.order = this.getValue(constraintMap, "order", 0);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data.target = skeletonData.findSlot(targetName);
          if (data.target == null)
            throw new Error("Path target slot not found: " + targetName);
          data.positionMode = SkeletonJson4.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
          data.spacingMode = SkeletonJson4.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
          data.rotateMode = SkeletonJson4.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
          data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data.position = this.getValue(constraintMap, "position", 0);
          if (data.positionMode == PositionMode.Fixed)
            data.position *= scale;
          data.spacing = this.getValue(constraintMap, "spacing", 0);
          if (data.spacingMode == SpacingMode2.Length || data.spacingMode == SpacingMode2.Fixed)
            data.spacing *= scale;
          data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data.translateMix = this.getValue(constraintMap, "translateMix", 1);
          skeletonData.pathConstraints.push(data);
        }
      }
      if (root.skins) {
        for (var skinName in root.skins) {
          var skinMap = root.skins[skinName];
          var skin = new Skin2(skinName);
          for (var slotName in skinMap) {
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotName);
            var slotMap = skinMap[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
              if (attachment != null)
                skin.addAttachment(slotIndex, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
        var linkedMesh = this.linkedMeshes[i];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root.events) {
        for (var eventName in root.events) {
          var eventMap = root.events[eventName];
          var data = new EventData2(eventName);
          data.intValue = this.getValue(eventMap, "int", 0);
          data.floatValue = this.getValue(eventMap, "float", 0);
          data.stringValue = this.getValue(eventMap, "string", "");
          data.audioPath = this.getValue(eventMap, "audio", null);
          if (data.audioPath != null) {
            data.volume = this.getValue(eventMap, "volume", 1);
            data.balance = this.getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data);
        }
      }
      if (root.animations) {
        for (var animationName in root.animations) {
          var animationMap = root.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson4.prototype.readAttachment = function(map, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = this.getValue(map, "name", name);
      var type = this.getValue(map, "type", "region");
      switch (type) {
        case "region": {
          var path = this.getValue(map, "path", name);
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = this.getValue(map, "x", 0) * scale;
          region.y = this.getValue(map, "y", 0) * scale;
          region.scaleX = this.getValue(map, "scaleX", 1);
          region.scaleY = this.getValue(map, "scaleY", 1);
          region.rotation = this.getValue(map, "rotation", 0);
          region.width = map.width * scale;
          region.height = map.height * scale;
          var color = this.getValue(map, "color", null);
          if (color != null)
            region.color.setFromString(color);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          this.readVertices(map, box, map.vertexCount << 1);
          var color = this.getValue(map, "color", null);
          if (color != null)
            box.color.setFromString(color);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = this.getValue(map, "path", name);
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          var color = this.getValue(map, "color", null);
          if (color != null)
            mesh.color.setFromString(color);
          var parent_3 = this.getValue(map, "parent", null);
          if (parent_3 != null) {
            mesh.inheritDeform = this.getValue(map, "deform", true);
            this.linkedMeshes.push(new LinkedMesh2(mesh, this.getValue(map, "skin", null), slotIndex, parent_3));
            return mesh;
          }
          var uvs = map.uvs;
          this.readVertices(map, mesh, uvs.length);
          mesh.triangles = map.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = this.getValue(map, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = this.getValue(map, "closed", false);
          path.constantSpeed = this.getValue(map, "constantSpeed", true);
          var vertexCount = map.vertexCount;
          this.readVertices(map, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i = 0; i < map.lengths.length; i++)
            lengths[i] = map.lengths[i] * scale;
          path.lengths = lengths;
          var color = this.getValue(map, "color", null);
          if (color != null)
            path.color.setFromString(color);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = this.getValue(map, "x", 0) * scale;
          point.y = this.getValue(map, "y", 0) * scale;
          point.rotation = this.getValue(map, "rotation", 0);
          var color = this.getValue(map, "color", null);
          if (color != null)
            point.color.setFromString(color);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          var end = this.getValue(map, "end", null);
          if (end != null) {
            var slot = skeletonData.findSlot(end);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end);
            clip.endSlot = slot;
          }
          var vertexCount = map.vertexCount;
          this.readVertices(map, clip, vertexCount << 1);
          var color = this.getValue(map, "color", null);
          if (color != null)
            clip.color.setFromString(color);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson4.prototype.readVertices = function(map, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i = 0, n = vertices.length; i < n; i++)
            scaledVertices[i] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i = 0, n = vertices.length; i < n; ) {
        var boneCount = vertices[i++];
        bones.push(boneCount);
        for (var nn = i + boneCount * 4; i < nn; i += 4) {
          bones.push(vertices[i]);
          weights.push(vertices[i + 1] * scale);
          weights.push(vertices[i + 2] * scale);
          weights.push(vertices[i + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson4.prototype.readAnimation = function(map, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      var duration = 0;
      if (map.slots) {
        for (var slotName in map.slots) {
          var slotMap = map.slots[slotName];
          var slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error("Slot not found: " + slotName);
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            } else if (timelineName == "color") {
              var timeline = new ColorTimeline2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var color = new Color();
                color.setFromString(valueMap.color || "ffffffff");
                timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline2.ENTRIES]);
            } else if (timelineName == "twoColor") {
              var timeline = new TwoColorTimeline2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var light = new Color();
                var dark = new Color();
                light.setFromString(valueMap.light);
                dark.setFromString(valueMap.dark);
                timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline2.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
          }
        }
      }
      if (map.bones) {
        for (var boneName in map.bones) {
          var boneMap = map.bones[boneName];
          var boneIndex = skeletonData.findBoneIndex(boneName);
          if (boneIndex == -1)
            throw new Error("Bone not found: " + boneName);
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            if (timelineName === "rotate") {
              var timeline = new RotateTimeline2(timelineMap.length);
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline2.ENTRIES]);
            } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "scale")
                timeline = new ScaleTimeline2(timelineMap.length);
              else if (timelineName === "shear")
                timeline = new ShearTimeline2(timelineMap.length);
              else {
                timeline = new TranslateTimeline2(timelineMap.length);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                var x = this.getValue(valueMap, "x", 0), y = this.getValue(valueMap, "y", 0);
                timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline2.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
          }
        }
      }
      if (map.ik) {
        for (var constraintName in map.ik) {
          var constraintMap = map.ik[constraintName];
          var constraint = skeletonData.findIkConstraint(constraintName);
          var timeline = new IkConstraintTimeline2(constraintMap.length);
          timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline2.ENTRIES]);
        }
      }
      if (map.transform) {
        for (var constraintName in map.transform) {
          var constraintMap = map.transform[constraintName];
          var constraint = skeletonData.findTransformConstraint(constraintName);
          var timeline = new TransformConstraintTimeline2(constraintMap.length);
          timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline2.ENTRIES]);
        }
      }
      if (map.paths) {
        for (var constraintName in map.paths) {
          var constraintMap = map.paths[constraintName];
          var index = skeletonData.findPathConstraintIndex(constraintName);
          if (index == -1)
            throw new Error("Path constraint not found: " + constraintName);
          var data = skeletonData.pathConstraints[index];
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            if (timelineName === "position" || timelineName === "spacing") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "spacing") {
                timeline = new PathConstraintSpacingTimeline2(timelineMap.length);
                if (data.spacingMode == SpacingMode2.Length || data.spacingMode == SpacingMode2.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline2(timelineMap.length);
                if (data.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline2.ENTRIES]);
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline2(timelineMap.length);
              timeline.pathConstraintIndex = index;
              var frameIndex = 0;
              for (var i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline2.ENTRIES]);
            }
          }
        }
      }
      if (map.deform) {
        for (var deformName in map.deform) {
          var deformMap = map.deform[deformName];
          var skin = skeletonData.findSkin(deformName);
          if (skin == null) {
            if (settings.FAIL_ON_NON_EXISTING_SKIN) {
              throw new Error("Skin not found: " + deformName);
            } else {
              continue;
            }
          }
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotMap.name);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName];
              var attachment = skin.getAttachment(slotIndex, timelineName);
              if (attachment == null)
                throw new Error("Deform attachment not found: " + timelineMap.name);
              var weighted = attachment.bones != null;
              var vertices = attachment.vertices;
              var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              var timeline = new DeformTimeline2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              timeline.attachment = attachment;
              var frameIndex = 0;
              for (var j = 0; j < timelineMap.length; j++) {
                var valueMap = timelineMap[j];
                var deform = void 0;
                var verticesValue = this.getValue(valueMap, "vertices", null);
                if (verticesValue == null)
                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils.newFloatArray(deformLength);
                  var start = this.getValue(valueMap, "offset", 0);
                  Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                  if (scale != 1) {
                    for (var i = start, n = i + verticesValue.length; i < n; i++)
                      deform[i] *= scale;
                  }
                  if (!weighted) {
                    for (var i = 0; i < deformLength; i++)
                      deform[i] += vertices[i];
                  }
                }
                timeline.setFrame(frameIndex, valueMap.time, deform);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            }
          }
        }
      }
      var drawOrderNode = map.drawOrder;
      if (drawOrderNode == null)
        drawOrderNode = map.draworder;
      if (drawOrderNode != null) {
        var timeline = new DrawOrderTimeline2(drawOrderNode.length);
        var slotCount = skeletonData.slots.length;
        var frameIndex = 0;
        for (var j = 0; j < drawOrderNode.length; j++) {
          var drawOrderMap = drawOrderNode[j];
          var drawOrder = null;
          var offsets = this.getValue(drawOrderMap, "offsets", null);
          if (offsets != null) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var i = 0; i < offsets.length; i++) {
              var offsetMap = offsets[i];
              var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
              if (slotIndex == -1)
                throw new Error("Slot not found: " + offsetMap.slot);
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var i = slotCount - 1; i >= 0; i--)
              if (drawOrder[i] == -1)
                drawOrder[i] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (map.events) {
        var timeline = new EventTimeline2(map.events.length);
        var frameIndex = 0;
        for (var i = 0; i < map.events.length; i++) {
          var eventMap = map.events[i];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (eventData == null)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event2(Utils.toSinglePrecision(eventMap.time), eventData);
          event_1.intValue = this.getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath != null) {
            event_1.volume = this.getValue(eventMap, "volume", 1);
            event_1.balance = this.getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frameIndex++, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation2(name, timelines, duration));
    };
    SkeletonJson4.prototype.readCurve = function(map, timeline, frameIndex) {
      if (!map.curve)
        return;
      if (map.curve === "stepped")
        timeline.setStepped(frameIndex);
      else if (Object.prototype.toString.call(map.curve) === "[object Array]") {
        var curve = map.curve;
        timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
      }
    };
    SkeletonJson4.prototype.getValue = function(map, prop, defaultValue) {
      return map[prop] !== void 0 ? map[prop] : defaultValue;
    };
    SkeletonJson4.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES.NORMAL;
      if (str == "additive")
        return BLEND_MODES.ADD;
      if (str == "multiply")
        return BLEND_MODES.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    SkeletonJson4.positionModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "fixed")
        return PositionMode.Fixed;
      if (str == "percent")
        return PositionMode.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson4.spacingModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "length")
        return SpacingMode2.Length;
      if (str == "fixed")
        return SpacingMode2.Fixed;
      if (str == "percent")
        return SpacingMode2.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson4.rotateModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "tangent")
        return RotateMode.Tangent;
      if (str == "chain")
        return RotateMode.Chain;
      if (str == "chainscale")
        return RotateMode.ChainScale;
      throw new Error("Unknown rotate mode: " + str);
    };
    SkeletonJson4.transformModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return TransformMode.Normal;
      if (str == "onlytranslation")
        return TransformMode.OnlyTranslation;
      if (str == "norotationorreflection")
        return TransformMode.NoRotationOrReflection;
      if (str == "noscale")
        return TransformMode.NoScale;
      if (str == "noscaleorreflection")
        return TransformMode.NoScaleOrReflection;
      throw new Error("Unknown transform mode: " + str);
    };
    return SkeletonJson4;
  }()
);
var LinkedMesh2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function LinkedMesh4(mesh, skin, slotIndex, parent) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
    }
    return LinkedMesh4;
  }()
);
var Spine2 = (
  /** @class */
  function(_super) {
    __extends3(Spine5, _super);
    function Spine5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine5.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton2(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData2(spineData);
      this.state = new AnimationState2(this.stateData);
    };
    return Spine5;
  }(SpineBase)
);

// node_modules/@pixi-spine/runtime-4.1/lib/runtime-4.1.es.js
var runtime_4_1_es_exports = {};
__export(runtime_4_1_es_exports, {
  AlphaTimeline: () => AlphaTimeline,
  Animation: () => Animation3,
  AnimationState: () => AnimationState3,
  AnimationStateAdapter: () => AnimationStateAdapter3,
  AnimationStateData: () => AnimationStateData3,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader3,
  Attachment: () => Attachment3,
  AttachmentTimeline: () => AttachmentTimeline3,
  Bone: () => Bone3,
  BoneData: () => BoneData3,
  BoundingBoxAttachment: () => BoundingBoxAttachment3,
  ClippingAttachment: () => ClippingAttachment3,
  ConstraintData: () => ConstraintData2,
  CurveTimeline: () => CurveTimeline3,
  CurveTimeline1: () => CurveTimeline1,
  CurveTimeline2: () => CurveTimeline22,
  DeformTimeline: () => DeformTimeline3,
  DrawOrderTimeline: () => DrawOrderTimeline3,
  Event: () => Event3,
  EventData: () => EventData3,
  EventQueue: () => EventQueue3,
  EventTimeline: () => EventTimeline3,
  EventType: () => EventType3,
  IkConstraint: () => IkConstraint3,
  IkConstraintData: () => IkConstraintData3,
  IkConstraintTimeline: () => IkConstraintTimeline3,
  MeshAttachment: () => MeshAttachment3,
  PathAttachment: () => PathAttachment3,
  PathConstraint: () => PathConstraint3,
  PathConstraintData: () => PathConstraintData3,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline3,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline3,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline3,
  PointAttachment: () => PointAttachment3,
  RGB2Timeline: () => RGB2Timeline,
  RGBA2Timeline: () => RGBA2Timeline,
  RGBATimeline: () => RGBATimeline,
  RGBTimeline: () => RGBTimeline,
  RegionAttachment: () => RegionAttachment3,
  RotateTimeline: () => RotateTimeline3,
  ScaleTimeline: () => ScaleTimeline3,
  ScaleXTimeline: () => ScaleXTimeline,
  ScaleYTimeline: () => ScaleYTimeline,
  Sequence: () => Sequence,
  SequenceMode: () => SequenceMode,
  SequenceModeValues: () => SequenceModeValues,
  SequenceTimeline: () => SequenceTimeline,
  ShearTimeline: () => ShearTimeline3,
  ShearXTimeline: () => ShearXTimeline,
  ShearYTimeline: () => ShearYTimeline,
  Skeleton: () => Skeleton3,
  SkeletonBinary: () => SkeletonBinary2,
  SkeletonBounds: () => SkeletonBounds3,
  SkeletonData: () => SkeletonData3,
  SkeletonJson: () => SkeletonJson3,
  Skin: () => Skin3,
  SkinEntry: () => SkinEntry2,
  Slot: () => Slot3,
  SlotData: () => SlotData3,
  SpacingMode: () => SpacingMode3,
  Spine: () => Spine3,
  Timeline: () => Timeline,
  TrackEntry: () => TrackEntry3,
  TransformConstraint: () => TransformConstraint3,
  TransformConstraintData: () => TransformConstraintData3,
  TransformConstraintTimeline: () => TransformConstraintTimeline3,
  TranslateTimeline: () => TranslateTimeline3,
  TranslateXTimeline: () => TranslateXTimeline,
  TranslateYTimeline: () => TranslateYTimeline,
  VertexAttachment: () => VertexAttachment3
});
var extendStatics4 = function(d, b) {
  extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics4(d, b);
};
function __extends4(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Attachment3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Attachment4(name) {
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment4;
  }()
);
var VertexAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(VertexAttachment4, _super);
    function VertexAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.id = VertexAttachment4.nextID++;
      _this.bones = null;
      _this.vertices = [];
      _this.worldVerticesLength = 0;
      _this.timelineAttachment = _this;
      return _this;
    }
    VertexAttachment4.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment4.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.deform;
      var vertices = this.vertices;
      var bones = this.bones;
      if (!bones) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y = mat.ty;
        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
        for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
          var vx = vertices[v_1], vy = vertices[v_1 + 1];
          worldVertices[w] = vx * a + vy * b + x;
          worldVertices[w + 1] = vx * c + vy * d + y;
        }
        return;
      }
      var v = 0, skip = 0;
      for (var i = 0; i < start; i += 2) {
        var n = bones[v];
        v += n + 1;
        skip += n;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w = offset, b = skip * 3; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
          var wx = 0, wy = 0;
          var n = bones[v++];
          n += v;
          for (; v < n; v++, b += 3, f += 2) {
            var mat = skeletonBones[bones[v]].matrix;
            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
          }
          worldVertices[w] = wx;
          worldVertices[w + 1] = wy;
        }
      }
    };
    VertexAttachment4.prototype.copyTo = function(attachment) {
      if (this.bones) {
        attachment.bones = new Array(this.bones.length);
        Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
      } else
        attachment.bones = null;
      if (this.vertices) {
        attachment.vertices = Utils.newFloatArray(this.vertices.length);
        Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
      }
      attachment.worldVerticesLength = this.worldVerticesLength;
      attachment.timelineAttachment = this.timelineAttachment;
    };
    VertexAttachment4.nextID = 0;
    return VertexAttachment4;
  }(Attachment3)
);
var BoundingBoxAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(BoundingBoxAttachment4, _super);
    function BoundingBoxAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    BoundingBoxAttachment4.prototype.copy = function() {
      var copy = new BoundingBoxAttachment4(this.name);
      this.copyTo(copy);
      copy.color.setFromColor(this.color);
      return copy;
    };
    return BoundingBoxAttachment4;
  }(VertexAttachment3)
);
var ClippingAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(ClippingAttachment4, _super);
    function ClippingAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.endSlot = null;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    ClippingAttachment4.prototype.copy = function() {
      var copy = new ClippingAttachment4(this.name);
      this.copyTo(copy);
      copy.endSlot = this.endSlot;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return ClippingAttachment4;
  }(VertexAttachment3)
);
var MeshAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(MeshAttachment4, _super);
    function MeshAttachment4(name, path) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.region = null;
      _this.triangles = [];
      _this.color = new Color(1, 1, 1, 1);
      _this.width = 0;
      _this.height = 0;
      _this.hullLength = 0;
      _this.edges = [];
      _this.parentMesh = null;
      _this.sequence = null;
      _this.tempColor = new Color(0, 0, 0, 0);
      _this.path = path;
      return _this;
    }
    MeshAttachment4.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment4.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    MeshAttachment4.prototype.copy = function() {
      if (this.parentMesh)
        return this.newLinkedMesh();
      var copy = new MeshAttachment4(this.name, this.path);
      copy.region = this.region;
      copy.color.setFromColor(this.color);
      this.copyTo(copy);
      copy.regionUVs = new Float32Array(this.regionUVs.length);
      Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
      copy.triangles = new Array(this.triangles.length);
      Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
      copy.hullLength = this.hullLength;
      copy.sequence = this.sequence != null ? this.sequence.copy() : null;
      if (this.edges) {
        copy.edges = new Array(this.edges.length);
        Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
      }
      copy.width = this.width;
      copy.height = this.height;
      return copy;
    };
    MeshAttachment4.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      _super.prototype.computeWorldVertices.call(this, slot, start, count, worldVertices, offset, stride);
    };
    MeshAttachment4.prototype.newLinkedMesh = function() {
      var copy = new MeshAttachment4(this.name, this.path);
      copy.region = this.region;
      copy.color.setFromColor(this.color);
      copy.timelineAttachment = this.timelineAttachment;
      copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
      return copy;
    };
    return MeshAttachment4;
  }(VertexAttachment3)
);
var PathAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(PathAttachment4, _super);
    function PathAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.lengths = [];
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    PathAttachment4.prototype.copy = function() {
      var copy = new PathAttachment4(this.name);
      this.copyTo(copy);
      copy.lengths = new Array(this.lengths.length);
      Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
      copy.closed = closed;
      copy.constantSpeed = this.constantSpeed;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return PathAttachment4;
  }(VertexAttachment3)
);
var PointAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(PointAttachment4, _super);
    function PointAttachment4(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.x = 0;
      _this.y = 0;
      _this.rotation = 0;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment4.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment4.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y = cos * mat.b + sin * mat.d;
      return Math.atan2(y, x) * MathUtils.radDeg;
    };
    PointAttachment4.prototype.copy = function() {
      var copy = new PointAttachment4(this.name);
      copy.x = this.x;
      copy.y = this.y;
      copy.rotation = this.rotation;
      copy.color.setFromColor(this.color);
      return copy;
    };
    return PointAttachment4;
  }(VertexAttachment3)
);
var RegionAttachment3 = (
  /** @class */
  function(_super) {
    __extends4(RegionAttachment4, _super);
    function RegionAttachment4(name, path) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.rendererObject = null;
      _this.region = null;
      _this.sequence = null;
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      _this.path = path;
      return _this;
    }
    RegionAttachment4.prototype.updateRegion = function() {
      if (!this.region)
        throw new Error("Region not set.");
      var region = this.region;
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var x = this.x, y = this.y;
      var localXCos = localX * cos + x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + y;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + y;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[0] = localXCos - localYSin;
      offset[1] = localYCos + localXSin;
      offset[2] = localXCos - localY2Sin;
      offset[3] = localY2Cos + localXSin;
      offset[4] = localX2Cos - localY2Sin;
      offset[5] = localY2Cos + localX2Sin;
      offset[6] = localX2Cos - localYSin;
      offset[7] = localYCos + localX2Sin;
      var uvs = this.uvs;
      if (region.degrees == 90) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment4.prototype.computeWorldVertices = function(slot, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      var bone = slot.bone;
      var vertexOffset = this.offset;
      var mat = bone.matrix;
      var x = mat.tx, y = mat.ty;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[0];
      offsetY = vertexOffset[1];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[2];
      offsetY = vertexOffset[3];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[4];
      offsetY = vertexOffset[5];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      offset += stride;
      offsetX = vertexOffset[6];
      offsetY = vertexOffset[7];
      worldVertices[offset] = offsetX * a + offsetY * b + x;
      worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    };
    RegionAttachment4.prototype.copy = function() {
      var copy = new RegionAttachment4(this.name, this.path);
      copy.region = this.region;
      copy.rendererObject = this.rendererObject;
      copy.x = this.x;
      copy.y = this.y;
      copy.scaleX = this.scaleX;
      copy.scaleY = this.scaleY;
      copy.rotation = this.rotation;
      copy.width = this.width;
      copy.height = this.height;
      Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
      Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
      copy.color.setFromColor(this.color);
      copy.sequence = this.sequence != null ? this.sequence.copy() : null;
      return copy;
    };
    RegionAttachment4.X1 = 0;
    RegionAttachment4.Y1 = 1;
    RegionAttachment4.C1R = 2;
    RegionAttachment4.C1G = 3;
    RegionAttachment4.C1B = 4;
    RegionAttachment4.C1A = 5;
    RegionAttachment4.U1 = 6;
    RegionAttachment4.V1 = 7;
    RegionAttachment4.X2 = 8;
    RegionAttachment4.Y2 = 9;
    RegionAttachment4.C2R = 10;
    RegionAttachment4.C2G = 11;
    RegionAttachment4.C2B = 12;
    RegionAttachment4.C2A = 13;
    RegionAttachment4.U2 = 14;
    RegionAttachment4.V2 = 15;
    RegionAttachment4.X3 = 16;
    RegionAttachment4.Y3 = 17;
    RegionAttachment4.C3R = 18;
    RegionAttachment4.C3G = 19;
    RegionAttachment4.C3B = 20;
    RegionAttachment4.C3A = 21;
    RegionAttachment4.U3 = 22;
    RegionAttachment4.V3 = 23;
    RegionAttachment4.X4 = 24;
    RegionAttachment4.Y4 = 25;
    RegionAttachment4.C4R = 26;
    RegionAttachment4.C4G = 27;
    RegionAttachment4.C4B = 28;
    RegionAttachment4.C4A = 29;
    RegionAttachment4.U4 = 30;
    RegionAttachment4.V4 = 31;
    return RegionAttachment4;
  }(Attachment3)
);
var Sequence = (
  /** @class */
  function() {
    function Sequence2(count) {
      this.id = Sequence2.nextID();
      this.start = 0;
      this.digits = 0;
      this.setupIndex = 0;
      this.regions = new Array(count);
    }
    Sequence2.prototype.copy = function() {
      var copy = new Sequence2(this.regions.length);
      Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
      copy.start = this.start;
      copy.digits = this.digits;
      copy.setupIndex = this.setupIndex;
      return copy;
    };
    Sequence2.prototype.apply = function(slot, attachment) {
      var index = slot.sequenceIndex;
      if (index == -1)
        index = this.setupIndex;
      if (index >= this.regions.length)
        index = this.regions.length - 1;
      var region = this.regions[index];
      if (attachment.region != region) {
        attachment.region = region;
      }
    };
    Sequence2.prototype.getPath = function(basePath, index) {
      var result = basePath;
      var frame = (this.start + index).toString();
      for (var i = this.digits - frame.length; i > 0; i--)
        result += "0";
      result += frame;
      return result;
    };
    Sequence2.nextID = function() {
      return Sequence2._nextID++;
    };
    Sequence2._nextID = 0;
    return Sequence2;
  }()
);
var SequenceMode;
(function(SequenceMode2) {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
})(SequenceMode || (SequenceMode = {}));
var SequenceModeValues = [
  SequenceMode.hold,
  SequenceMode.once,
  SequenceMode.loop,
  SequenceMode.pingpong,
  SequenceMode.onceReverse,
  SequenceMode.loopReverse,
  SequenceMode.pingpongReverse
];
var Animation3 = (
  /** @class */
  function() {
    function Animation4(name, timelines, duration) {
      this.timelines = [];
      this.timelineIds = new StringSet();
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
      this.setTimelines(timelines);
      this.duration = duration;
    }
    Animation4.prototype.setTimelines = function(timelines) {
      if (!timelines)
        throw new Error("timelines cannot be null.");
      this.timelines = timelines;
      this.timelineIds.clear();
      for (var i = 0; i < timelines.length; i++)
        this.timelineIds.addAll(timelines[i].getPropertyIds());
    };
    Animation4.prototype.hasTimeline = function(ids) {
      for (var i = 0; i < ids.length; i++)
        if (this.timelineIds.contains(ids[i]))
          return true;
      return false;
    };
    Animation4.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime > 0)
          lastTime %= this.duration;
      }
      var timelines = this.timelines;
      for (var i = 0, n = timelines.length; i < n; i++)
        timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
    };
    return Animation4;
  }()
);
var Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
var Timeline = (
  /** @class */
  function() {
    function Timeline2(frameCount, propertyIds) {
      this.propertyIds = propertyIds;
      this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());
    }
    Timeline2.prototype.getPropertyIds = function() {
      return this.propertyIds;
    };
    Timeline2.prototype.getFrameEntries = function() {
      return 1;
    };
    Timeline2.prototype.getFrameCount = function() {
      return this.frames.length / this.getFrameEntries();
    };
    Timeline2.prototype.getDuration = function() {
      return this.frames[this.frames.length - this.getFrameEntries()];
    };
    Timeline2.search1 = function(frames, time) {
      var n = frames.length;
      for (var i = 1; i < n; i++)
        if (frames[i] > time)
          return i - 1;
      return n - 1;
    };
    Timeline2.search = function(frames, time, step) {
      var n = frames.length;
      for (var i = step; i < n; i += step)
        if (frames[i] > time)
          return i - step;
      return n - step;
    };
    return Timeline2;
  }()
);
var CurveTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(CurveTimeline4, _super);
    function CurveTimeline4(frameCount, bezierCount, propertyIds) {
      var _this = _super.call(this, frameCount, propertyIds) || this;
      _this.curves = Utils.newFloatArray(
        frameCount + bezierCount * 18
        /*BEZIER_SIZE*/
      );
      _this.curves[frameCount - 1] = 1;
      return _this;
    }
    CurveTimeline4.prototype.setLinear = function(frame) {
      this.curves[frame] = 0;
    };
    CurveTimeline4.prototype.setStepped = function(frame) {
      this.curves[frame] = 1;
    };
    CurveTimeline4.prototype.shrink = function(bezierCount) {
      var size = this.getFrameCount() + bezierCount * 18;
      if (this.curves.length > size) {
        var newCurves = Utils.newFloatArray(size);
        Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
        this.curves = newCurves;
      }
    };
    CurveTimeline4.prototype.setBezier = function(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      var curves = this.curves;
      var i = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame] = 2 + i;
      var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
      var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
      var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
      var x = time1 + dx, y = value1 + dy;
      for (var n = i + 18; i < n; i += 2) {
        curves[i] = x;
        curves[i + 1] = y;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x += dx;
        y += dy;
      }
    };
    CurveTimeline4.prototype.getBezierValue = function(time, frameIndex, valueOffset, i) {
      var curves = this.curves;
      if (curves[i] > time) {
        var x_1 = this.frames[frameIndex], y_1 = this.frames[frameIndex + valueOffset];
        return y_1 + (time - x_1) / (curves[i] - x_1) * (curves[i + 1] - y_1);
      }
      var n = i + 18;
      for (i += 2; i < n; i += 2) {
        if (curves[i] >= time) {
          var x_2 = curves[i - 2], y_2 = curves[i - 1];
          return y_2 + (time - x_2) / (curves[i] - x_2) * (curves[i + 1] - y_2);
        }
      }
      frameIndex += this.getFrameEntries();
      var x = curves[n - 2], y = curves[n - 1];
      return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);
    };
    return CurveTimeline4;
  }(Timeline)
);
var CurveTimeline1 = (
  /** @class */
  function(_super) {
    __extends4(CurveTimeline12, _super);
    function CurveTimeline12(frameCount, bezierCount, propertyId) {
      return _super.call(this, frameCount, bezierCount, [propertyId]) || this;
    }
    CurveTimeline12.prototype.getFrameEntries = function() {
      return 2;
    };
    CurveTimeline12.prototype.setFrame = function(frame, time, value) {
      frame <<= 1;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*VALUE*/
      ] = value;
    };
    CurveTimeline12.prototype.getCurveValue = function(time) {
      var frames = this.frames;
      var i = frames.length - 2;
      for (var ii = 2; ii <= i; ii += 2) {
        if (frames[ii] > time) {
          i = ii - 2;
          break;
        }
      }
      var curveType = this.curves[i >> 1];
      switch (curveType) {
        case 0:
          var before = frames[i], value = frames[
            i + 1
            /*VALUE*/
          ];
          return value + (time - before) / (frames[
            i + 2
            /*ENTRIES*/
          ] - before) * (frames[
            i + 2 + 1
            /*VALUE*/
          ] - value);
        case 1:
          return frames[
            i + 1
            /*VALUE*/
          ];
      }
      return this.getBezierValue(
        time,
        i,
        1,
        curveType - 2
        /*BEZIER*/
      );
    };
    return CurveTimeline12;
  }(CurveTimeline3)
);
var CurveTimeline22 = (
  /** @class */
  function(_super) {
    __extends4(CurveTimeline23, _super);
    function CurveTimeline23(frameCount, bezierCount, propertyId1, propertyId2) {
      return _super.call(this, frameCount, bezierCount, [propertyId1, propertyId2]) || this;
    }
    CurveTimeline23.prototype.getFrameEntries = function() {
      return 3;
    };
    CurveTimeline23.prototype.setFrame = function(frame, time, value1, value2) {
      frame *= 3;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*VALUE1*/
      ] = value1;
      this.frames[
        frame + 2
        /*VALUE2*/
      ] = value2;
    };
    return CurveTimeline23;
  }(CurveTimeline3)
);
var RotateTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(RotateTimeline4, _super);
    function RotateTimeline4(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.rotate + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    RotateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
        }
        return;
      }
      var r = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + r * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += r * alpha;
      }
    };
    return RotateTimeline4;
  }(CurveTimeline1)
);
var TranslateTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(TranslateTimeline4, _super);
    function TranslateTimeline4(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.x + "|" + boneIndex, Property.y + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha;
            bone.y += (bone.data.y - bone.y) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      var i = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          var t = (time - before) / (frames[
            i + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i + 3 + 1
            /*VALUE1*/
          ] - x) * t;
          y += (frames[
            i + 3 + 2
            /*VALUE2*/
          ] - y) * t;
          break;
        case 1:
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha;
          bone.y = bone.data.y + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha;
          bone.y += (bone.data.y + y - bone.y) * alpha;
          break;
        case MixBlend.add:
          bone.x += x * alpha;
          bone.y += y * alpha;
      }
    };
    return TranslateTimeline4;
  }(CurveTimeline22)
);
var TranslateXTimeline = (
  /** @class */
  function(_super) {
    __extends4(TranslateXTimeline2, _super);
    function TranslateXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.x + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateXTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha;
        }
        return;
      }
      var x = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha;
          break;
        case MixBlend.add:
          bone.x += x * alpha;
      }
    };
    return TranslateXTimeline2;
  }(CurveTimeline1)
);
var TranslateYTimeline = (
  /** @class */
  function(_super) {
    __extends4(TranslateYTimeline2, _super);
    function TranslateYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.y + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateYTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.y += (bone.data.y - bone.y) * alpha;
        }
        return;
      }
      var y = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.y = bone.data.y + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.y += (bone.data.y + y - bone.y) * alpha;
          break;
        case MixBlend.add:
          bone.y += y * alpha;
      }
    };
    return TranslateYTimeline2;
  }(CurveTimeline1)
);
var ScaleTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(ScaleTimeline4, _super);
    function ScaleTimeline4(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleX + "|" + boneIndex, Property.scaleY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        return;
      }
      var x, y;
      var i = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          var t = (time - before) / (frames[
            i + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i + 3 + 1
            /*VALUE1*/
          ] - x) * t;
          y += (frames[
            i + 3 + 2
            /*VALUE2*/
          ] - y) * t;
          break;
        case 1:
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      x *= bone.data.scaleX;
      y *= bone.data.scaleY;
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha;
              bone.scaleY += (y - bone.data.scaleY) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y);
              bone.scaleX = bx + (x - bx) * alpha;
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha;
              bone.scaleY += (y - bone.data.scaleY) * alpha;
          }
        }
      }
    };
    return ScaleTimeline4;
  }(CurveTimeline22)
);
var ScaleXTimeline = (
  /** @class */
  function(_super) {
    __extends4(ScaleXTimeline2, _super);
    function ScaleXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleX + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleXTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
        }
        return;
      }
      var x = this.getCurveValue(time) * bone.data.scaleX;
      if (alpha == 1) {
        if (blend == MixBlend.add)
          bone.scaleX += x - bone.data.scaleX;
        else
          bone.scaleX = x;
      } else {
        var bx = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              bone.scaleX = bx + (x - bx) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              bone.scaleX = bx + (x - bx) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha;
          }
        }
      }
    };
    return ScaleXTimeline2;
  }(CurveTimeline1)
);
var ScaleYTimeline = (
  /** @class */
  function(_super) {
    __extends4(ScaleYTimeline2, _super);
    function ScaleYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleYTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        return;
      }
      var y = this.getCurveValue(time) * bone.data.scaleY;
      if (alpha == 1) {
        if (blend == MixBlend.add)
          bone.scaleY += y - bone.data.scaleY;
        else
          bone.scaleY = y;
      } else {
        var by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              by = bone.data.scaleY;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              by = bone.scaleY;
              bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleY += (y - bone.data.scaleY) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              by = Math.abs(bone.scaleY) * MathUtils.signum(y);
              bone.scaleY = by + (y - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleY += (y - bone.data.scaleY) * alpha;
          }
        }
      }
    };
    return ScaleYTimeline2;
  }(CurveTimeline1)
);
var ShearTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(ShearTimeline4, _super);
    function ShearTimeline4(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearX + "|" + boneIndex, Property.shearY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        return;
      }
      var x = 0, y = 0;
      var i = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          var t = (time - before) / (frames[
            i + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i + 3 + 1
            /*VALUE1*/
          ] - x) * t;
          y += (frames[
            i + 3 + 2
            /*VALUE2*/
          ] - y) * t;
          break;
        case 1:
          x = frames[
            i + 1
            /*VALUE1*/
          ];
          y = frames[
            i + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha;
          bone.shearY = bone.data.shearY + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha;
          bone.shearY += y * alpha;
      }
    };
    return ShearTimeline4;
  }(CurveTimeline22)
);
var ShearXTimeline = (
  /** @class */
  function(_super) {
    __extends4(ShearXTimeline2, _super);
    function ShearXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearX + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearXTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
        }
        return;
      }
      var x = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha;
      }
    };
    return ShearXTimeline2;
  }(CurveTimeline1)
);
var ShearYTimeline = (
  /** @class */
  function(_super) {
    __extends4(ShearYTimeline2, _super);
    function ShearYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearYTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        return;
      }
      var y = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.shearY = bone.data.shearY + y * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
          break;
        case MixBlend.add:
          bone.shearY += y * alpha;
      }
    };
    return ShearYTimeline2;
  }(CurveTimeline1)
);
var RGBATimeline = (
  /** @class */
  function(_super) {
    __extends4(RGBATimeline2, _super);
    function RGBATimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBATimeline2.prototype.getFrameEntries = function() {
      return 5;
    };
    RGBATimeline2.prototype.setFrame = function(frame, time, r, g, b, a) {
      frame *= 5;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r;
      this.frames[
        frame + 2
        /*G*/
      ] = g;
      this.frames[
        frame + 3
        /*B*/
      ] = b;
      this.frames[
        frame + 4
        /*A*/
      ] = a;
    };
    RGBATimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var color = slot.color;
      if (time < frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.setFromColor(setup);
            return;
          case MixBlend.first:
            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0;
      var i = Timeline.search(
        frames,
        time,
        5
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 5
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          a = frames[
            i + 4
            /*A*/
          ];
          var t = (time - before) / (frames[
            i + 5
            /*ENTRIES*/
          ] - before);
          r += (frames[
            i + 5 + 1
            /*R*/
          ] - r) * t;
          g += (frames[
            i + 5 + 2
            /*G*/
          ] - g) * t;
          b += (frames[
            i + 5 + 3
            /*B*/
          ] - b) * t;
          a += (frames[
            i + 5 + 4
            /*A*/
          ] - a) * t;
          break;
        case 1:
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          a = frames[
            i + 4
            /*A*/
          ];
          break;
        default:
          r = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a = this.getBezierValue(
            time,
            i,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1)
        color.set(r, g, b, a);
      else {
        if (blend == MixBlend.setup)
          color.setFromColor(slot.data.color);
        color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
      }
    };
    return RGBATimeline2;
  }(CurveTimeline3)
);
var RGBTimeline = (
  /** @class */
  function(_super) {
    __extends4(RGBTimeline2, _super);
    function RGBTimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBTimeline2.prototype.getFrameEntries = function() {
      return 4;
    };
    RGBTimeline2.prototype.setFrame = function(frame, time, r, g, b) {
      frame <<= 2;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r;
      this.frames[
        frame + 2
        /*G*/
      ] = g;
      this.frames[
        frame + 3
        /*B*/
      ] = b;
    };
    RGBTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var color = slot.color;
      if (time < frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.r = setup.r;
            color.g = setup.g;
            color.b = setup.b;
            return;
          case MixBlend.first:
            color.r += (setup.r - color.r) * alpha;
            color.g += (setup.g - color.g) * alpha;
            color.b += (setup.b - color.b) * alpha;
        }
        return;
      }
      var r = 0, g = 0, b = 0;
      var i = Timeline.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      var curveType = this.curves[i >> 2];
      switch (curveType) {
        case 0:
          var before = frames[i];
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          var t = (time - before) / (frames[
            i + 4
            /*ENTRIES*/
          ] - before);
          r += (frames[
            i + 4 + 1
            /*R*/
          ] - r) * t;
          g += (frames[
            i + 4 + 2
            /*G*/
          ] - g) * t;
          b += (frames[
            i + 4 + 3
            /*B*/
          ] - b) * t;
          break;
        case 1:
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          break;
        default:
          r = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        color.r = r;
        color.g = g;
        color.b = b;
      } else {
        if (blend == MixBlend.setup) {
          var setup = slot.data.color;
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
        }
        color.r += (r - color.r) * alpha;
        color.g += (g - color.g) * alpha;
        color.b += (b - color.b) * alpha;
      }
    };
    return RGBTimeline2;
  }(CurveTimeline3)
);
var AlphaTimeline = (
  /** @class */
  function(_super) {
    __extends4(AlphaTimeline2, _super);
    function AlphaTimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.alpha + "|" + slotIndex) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    AlphaTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var color = slot.color;
      if (time < this.frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.a = setup.a;
            return;
          case MixBlend.first:
            color.a += (setup.a - color.a) * alpha;
        }
        return;
      }
      var a = this.getCurveValue(time);
      if (alpha == 1)
        color.a = a;
      else {
        if (blend == MixBlend.setup)
          color.a = slot.data.color.a;
        color.a += (a - color.a) * alpha;
      }
    };
    return AlphaTimeline2;
  }(CurveTimeline1)
);
var RGBA2Timeline = (
  /** @class */
  function(_super) {
    __extends4(RGBA2Timeline2, _super);
    function RGBA2Timeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBA2Timeline2.prototype.getFrameEntries = function() {
      return 8;
    };
    RGBA2Timeline2.prototype.setFrame = function(frame, time, r, g, b, a, r2, g2, b2) {
      frame <<= 3;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r;
      this.frames[
        frame + 2
        /*G*/
      ] = g;
      this.frames[
        frame + 3
        /*B*/
      ] = b;
      this.frames[
        frame + 4
        /*A*/
      ] = a;
      this.frames[
        frame + 5
        /*R2*/
      ] = r2;
      this.frames[
        frame + 6
        /*G2*/
      ] = g2;
      this.frames[
        frame + 7
        /*B2*/
      ] = b2;
    };
    RGBA2Timeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        var setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.setFromColor(setupLight);
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
            dark.r += (setupDark.r - dark.r) * alpha;
            dark.g += (setupDark.g - dark.g) * alpha;
            dark.b += (setupDark.b - dark.b) * alpha;
        }
        return;
      }
      var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
      var i = Timeline.search(
        frames,
        time,
        8
        /*ENTRIES*/
      );
      var curveType = this.curves[i >> 3];
      switch (curveType) {
        case 0:
          var before = frames[i];
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          a = frames[
            i + 4
            /*A*/
          ];
          r2 = frames[
            i + 5
            /*R2*/
          ];
          g2 = frames[
            i + 6
            /*G2*/
          ];
          b2 = frames[
            i + 7
            /*B2*/
          ];
          var t = (time - before) / (frames[
            i + 8
            /*ENTRIES*/
          ] - before);
          r += (frames[
            i + 8 + 1
            /*R*/
          ] - r) * t;
          g += (frames[
            i + 8 + 2
            /*G*/
          ] - g) * t;
          b += (frames[
            i + 8 + 3
            /*B*/
          ] - b) * t;
          a += (frames[
            i + 8 + 4
            /*A*/
          ] - a) * t;
          r2 += (frames[
            i + 8 + 5
            /*R2*/
          ] - r2) * t;
          g2 += (frames[
            i + 8 + 6
            /*G2*/
          ] - g2) * t;
          b2 += (frames[
            i + 8 + 7
            /*B2*/
          ] - b2) * t;
          break;
        case 1:
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          a = frames[
            i + 4
            /*A*/
          ];
          r2 = frames[
            i + 5
            /*R2*/
          ];
          g2 = frames[
            i + 6
            /*G2*/
          ];
          b2 = frames[
            i + 7
            /*B2*/
          ];
          break;
        default:
          r = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a = this.getBezierValue(
            time,
            i,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          r2 = this.getBezierValue(
            time,
            i,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i,
            7,
            curveType + 18 * 6 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        light.set(r, g, b, a);
        dark.r = r2;
        dark.g = g2;
        dark.b = b2;
      } else {
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          var setupDark = slot.data.darkColor;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
        dark.r += (r2 - dark.r) * alpha;
        dark.g += (g2 - dark.g) * alpha;
        dark.b += (b2 - dark.b) * alpha;
      }
    };
    return RGBA2Timeline2;
  }(CurveTimeline3)
);
var RGB2Timeline = (
  /** @class */
  function(_super) {
    __extends4(RGB2Timeline2, _super);
    function RGB2Timeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGB2Timeline2.prototype.getFrameEntries = function() {
      return 7;
    };
    RGB2Timeline2.prototype.setFrame = function(frame, time, r, g, b, r2, g2, b2) {
      frame *= 7;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r;
      this.frames[
        frame + 2
        /*G*/
      ] = g;
      this.frames[
        frame + 3
        /*B*/
      ] = b;
      this.frames[
        frame + 4
        /*R2*/
      ] = r2;
      this.frames[
        frame + 5
        /*G2*/
      ] = g2;
      this.frames[
        frame + 6
        /*B2*/
      ] = b2;
    };
    RGB2Timeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        var setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.r = setupLight.r;
            light.g = setupLight.g;
            light.b = setupLight.b;
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.r += (setupLight.r - light.r) * alpha;
            light.g += (setupLight.g - light.g) * alpha;
            light.b += (setupLight.b - light.b) * alpha;
            dark.r += (setupDark.r - dark.r) * alpha;
            dark.g += (setupDark.g - dark.g) * alpha;
            dark.b += (setupDark.b - dark.b) * alpha;
        }
        return;
      }
      var r = 0, g = 0, b = 0, r2 = 0, g2 = 0, b2 = 0;
      var i = Timeline.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          r2 = frames[
            i + 4
            /*R2*/
          ];
          g2 = frames[
            i + 5
            /*G2*/
          ];
          b2 = frames[
            i + 6
            /*B2*/
          ];
          var t = (time - before) / (frames[
            i + 7
            /*ENTRIES*/
          ] - before);
          r += (frames[
            i + 7 + 1
            /*R*/
          ] - r) * t;
          g += (frames[
            i + 7 + 2
            /*G*/
          ] - g) * t;
          b += (frames[
            i + 7 + 3
            /*B*/
          ] - b) * t;
          r2 += (frames[
            i + 7 + 4
            /*R2*/
          ] - r2) * t;
          g2 += (frames[
            i + 7 + 5
            /*G2*/
          ] - g2) * t;
          b2 += (frames[
            i + 7 + 6
            /*B2*/
          ] - b2) * t;
          break;
        case 1:
          r = frames[
            i + 1
            /*R*/
          ];
          g = frames[
            i + 2
            /*G*/
          ];
          b = frames[
            i + 3
            /*B*/
          ];
          r2 = frames[
            i + 4
            /*R2*/
          ];
          g2 = frames[
            i + 5
            /*G2*/
          ];
          b2 = frames[
            i + 6
            /*B2*/
          ];
          break;
        default:
          r = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          r2 = this.getBezierValue(
            time,
            i,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        light.r = r;
        light.g = g;
        light.b = b;
        dark.r = r2;
        dark.g = g2;
        dark.b = b2;
      } else {
        if (blend == MixBlend.setup) {
          var setupLight = slot.data.color, setupDark = slot.data.darkColor;
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.r += (r - light.r) * alpha;
        light.g += (g - light.g) * alpha;
        light.b += (b - light.b) * alpha;
        dark.r += (r2 - dark.r) * alpha;
        dark.g += (g2 - dark.g) * alpha;
        dark.b += (b2 - dark.b) * alpha;
      }
    };
    return RGB2Timeline2;
  }(CurveTimeline3)
);
var AttachmentTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(AttachmentTimeline4, _super);
    function AttachmentTimeline4(frameCount, slotIndex) {
      var _this = _super.call(this, frameCount, [
        Property.attachment + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      _this.attachmentNames = new Array(frameCount);
      return _this;
    }
    AttachmentTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline4.prototype.setFrame = function(frame, time, attachmentName) {
      this.frames[frame] = time;
      this.attachmentNames[frame] = attachmentName;
    };
    AttachmentTimeline4.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
    };
    AttachmentTimeline4.prototype.setAttachment = function(skeleton, slot, attachmentName) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline4;
  }(Timeline)
);
var DeformTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(DeformTimeline4, _super);
    function DeformTimeline4(frameCount, bezierCount, slotIndex, attachment) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.deform + "|" + slotIndex + "|" + attachment.id
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      _this.attachment = attachment;
      _this.vertices = new Array(frameCount);
      return _this;
    }
    DeformTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DeformTimeline4.prototype.setFrame = function(frame, time, vertices) {
      this.frames[frame] = time;
      this.vertices[frame] = vertices;
    };
    DeformTimeline4.prototype.setBezier = function(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      var curves = this.curves;
      var i = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame] = 2 + i;
      var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;
      var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = (cy1 - cy2 + 0.33333333) * 0.018;
      var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
      var x = time1 + dx, y = dy;
      for (var n = i + 18; i < n; i += 2) {
        curves[i] = x;
        curves[i + 1] = y;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x += dx;
        y += dy;
      }
    };
    DeformTimeline4.prototype.getCurvePercent = function(time, frame) {
      var curves = this.curves;
      var i = curves[frame];
      switch (i) {
        case 0:
          var x_3 = this.frames[frame];
          return (time - x_3) / (this.frames[frame + this.getFrameEntries()] - x_3);
        case 1:
          return 0;
      }
      i -= 2;
      if (curves[i] > time) {
        var x_4 = this.frames[frame];
        return curves[i + 1] * (time - x_4) / (curves[i] - x_4);
      }
      var n = i + 18;
      for (i += 2; i < n; i += 2) {
        if (curves[i] >= time) {
          var x_5 = curves[i - 2], y_3 = curves[i - 1];
          return y_3 + (time - x_5) / (curves[i] - x_5) * (curves[i + 1] - y_3);
        }
      }
      var x = curves[n - 2], y = curves[n - 1];
      return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);
    };
    DeformTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.getAttachment();
      if (!slotAttachment)
        return;
      if (!(slotAttachment instanceof VertexAttachment3) || slotAttachment.timelineAttachment != this.attachment)
        return;
      var deform = slot.deform;
      if (deform.length == 0)
        blend = MixBlend.setup;
      var vertices = this.vertices;
      var vertexCount = vertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            deform.length = 0;
            return;
          case MixBlend.first:
            if (alpha == 1) {
              deform.length = 0;
              return;
            }
            deform.length = vertexCount;
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++)
                deform[i] += (setupVertices[i] - deform[i]) * alpha;
            } else {
              alpha = 1 - alpha;
              for (var i = 0; i < vertexCount; i++)
                deform[i] *= alpha;
            }
        }
        return;
      }
      deform.length = vertexCount;
      if (time >= frames[frames.length - 1]) {
        var lastVertices = vertices[frames.length - 1];
        if (alpha == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_1 = 0; i_1 < vertexCount; i_1++)
                deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
            } else {
              for (var i_2 = 0; i_2 < vertexCount; i_2++)
                deform[i_2] += lastVertices[i_2];
            }
          } else
            Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (!vertexAttachment_1.bones) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                  var setup = setupVertices[i_3];
                  deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;
                }
              } else {
                for (var i_4 = 0; i_4 < vertexCount; i_4++)
                  deform[i_4] = lastVertices[i_4] * alpha;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i_5 = 0; i_5 < vertexCount; i_5++)
                deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;
              break;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (!vertexAttachment.bones) {
                var setupVertices = vertexAttachment.vertices;
                for (var i_6 = 0; i_6 < vertexCount; i_6++)
                  deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;
              } else {
                for (var i_7 = 0; i_7 < vertexCount; i_7++)
                  deform[i_7] += lastVertices[i_7] * alpha;
              }
          }
        }
        return;
      }
      var frame = Timeline.search1(frames, time);
      var percent = this.getCurvePercent(time, frame);
      var prevVertices = vertices[frame];
      var nextVertices = vertices[frame + 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            var setupVertices = vertexAttachment.vertices;
            for (var i_8 = 0; i_8 < vertexCount; i_8++) {
              var prev = prevVertices[i_8];
              deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];
            }
          } else {
            for (var i_9 = 0; i_9 < vertexCount; i_9++) {
              var prev = prevVertices[i_9];
              deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;
            }
          }
        } else {
          for (var i_10 = 0; i_10 < vertexCount; i_10++) {
            var prev = prevVertices[i_10];
            deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (!vertexAttachment_2.bones) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i_11 = 0; i_11 < vertexCount; i_11++) {
                var prev = prevVertices[i_11], setup = setupVertices[i_11];
                deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;
              }
            } else {
              for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                var prev = prevVertices[i_12];
                deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i_13 = 0; i_13 < vertexCount; i_13++) {
              var prev = prevVertices[i_13];
              deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_14 = 0; i_14 < vertexCount; i_14++) {
                var prev = prevVertices[i_14];
                deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;
              }
            } else {
              for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                var prev = prevVertices[i_15];
                deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;
              }
            }
        }
      }
    };
    return DeformTimeline4;
  }(CurveTimeline3)
);
var EventTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(EventTimeline4, _super);
    function EventTimeline4(frameCount) {
      var _this = _super.call(this, frameCount, EventTimeline4.propertyIds) || this;
      _this.events = new Array(frameCount);
      return _this;
    }
    EventTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline4.prototype.setFrame = function(frame, event) {
      this.frames[frame] = event.time;
      this.events[frame] = event;
    };
    EventTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (!firedEvents)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
        lastTime = -1;
      } else if (lastTime >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var i = 0;
      if (lastTime < frames[0])
        i = 0;
      else {
        i = Timeline.search1(frames, lastTime) + 1;
        var frameTime = frames[i];
        while (i > 0) {
          if (frames[i - 1] != frameTime)
            break;
          i--;
        }
      }
      for (; i < frameCount && time >= frames[i]; i++)
        firedEvents.push(this.events[i]);
    };
    EventTimeline4.propertyIds = ["" + Property.event];
    return EventTimeline4;
  }(Timeline)
);
var DrawOrderTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(DrawOrderTimeline4, _super);
    function DrawOrderTimeline4(frameCount) {
      var _this = _super.call(this, frameCount, DrawOrderTimeline4.propertyIds) || this;
      _this.drawOrders = new Array(frameCount);
      return _this;
    }
    DrawOrderTimeline4.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline4.prototype.setFrame = function(frame, time, drawOrder) {
      this.frames[frame] = time;
      this.drawOrders[frame] = drawOrder;
    };
    DrawOrderTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var idx = Timeline.search1(this.frames, time);
      var drawOrderToSetupIndex = this.drawOrders[idx];
      if (!drawOrderToSetupIndex)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      else {
        var drawOrder = skeleton.drawOrder;
        var slots = skeleton.slots;
        for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
          drawOrder[i] = slots[drawOrderToSetupIndex[i]];
      }
    };
    DrawOrderTimeline4.propertyIds = ["" + Property.drawOrder];
    return DrawOrderTimeline4;
  }(Timeline)
);
var IkConstraintTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(IkConstraintTimeline4, _super);
    function IkConstraintTimeline4(frameCount, bezierCount, ikConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.ikConstraint + "|" + ikConstraintIndex
      ]) || this;
      _this.ikConstraintIndex = 0;
      _this.ikConstraintIndex = ikConstraintIndex;
      return _this;
    }
    IkConstraintTimeline4.prototype.getFrameEntries = function() {
      return 6;
    };
    IkConstraintTimeline4.prototype.setFrame = function(frame, time, mix, softness, bendDirection, compress, stretch) {
      frame *= 6;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*MIX*/
      ] = mix;
      this.frames[
        frame + 2
        /*SOFTNESS*/
      ] = softness;
      this.frames[
        frame + 3
        /*BEND_DIRECTION*/
      ] = bendDirection;
      this.frames[
        frame + 4
        /*COMPRESS*/
      ] = compress ? 1 : 0;
      this.frames[
        frame + 5
        /*STRETCH*/
      ] = stretch ? 1 : 0;
    };
    IkConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.softness = constraint.data.softness;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      var mix = 0, softness = 0;
      var i = Timeline.search(
        frames,
        time,
        6
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 6
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          mix = frames[
            i + 1
            /*MIX*/
          ];
          softness = frames[
            i + 2
            /*SOFTNESS*/
          ];
          var t = (time - before) / (frames[
            i + 6
            /*ENTRIES*/
          ] - before);
          mix += (frames[
            i + 6 + 1
            /*MIX*/
          ] - mix) * t;
          softness += (frames[
            i + 6 + 2
            /*SOFTNESS*/
          ] - softness) * t;
          break;
        case 1:
          mix = frames[
            i + 1
            /*MIX*/
          ];
          softness = frames[
            i + 2
            /*SOFTNESS*/
          ];
          break;
        default:
          mix = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          softness = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[
            i + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i + 5
            /*STRETCH*/
          ] != 0;
        }
      } else {
        constraint.mix += (mix - constraint.mix) * alpha;
        constraint.softness += (softness - constraint.softness) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[
            i + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i + 5
            /*STRETCH*/
          ] != 0;
        }
      }
    };
    return IkConstraintTimeline4;
  }(CurveTimeline3)
);
var TransformConstraintTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(TransformConstraintTimeline4, _super);
    function TransformConstraintTimeline4(frameCount, bezierCount, transformConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.transformConstraint + "|" + transformConstraintIndex
      ]) || this;
      _this.transformConstraintIndex = 0;
      _this.transformConstraintIndex = transformConstraintIndex;
      return _this;
    }
    TransformConstraintTimeline4.prototype.getFrameEntries = function() {
      return 7;
    };
    TransformConstraintTimeline4.prototype.setFrame = function(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
      var frames = this.frames;
      frame *= 7;
      frames[frame] = time;
      frames[
        frame + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame + 2
        /*X*/
      ] = mixX;
      frames[
        frame + 3
        /*Y*/
      ] = mixY;
      frames[
        frame + 4
        /*SCALEX*/
      ] = mixScaleX;
      frames[
        frame + 5
        /*SCALEY*/
      ] = mixScaleY;
      frames[
        frame + 6
        /*SHEARY*/
      ] = mixShearY;
    };
    TransformConstraintTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        var data = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = data.mixRotate;
            constraint.mixX = data.mixX;
            constraint.mixY = data.mixY;
            constraint.mixScaleX = data.mixScaleX;
            constraint.mixScaleY = data.mixScaleY;
            constraint.mixShearY = data.mixShearY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
            constraint.mixX += (data.mixX - constraint.mixX) * alpha;
            constraint.mixY += (data.mixY - constraint.mixY) * alpha;
            constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
            constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
            constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
        }
        return;
      }
      var rotate, x, y, scaleX, scaleY, shearY;
      var i = Timeline.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i];
          rotate = frames[
            i + 1
            /*ROTATE*/
          ];
          x = frames[
            i + 2
            /*X*/
          ];
          y = frames[
            i + 3
            /*Y*/
          ];
          scaleX = frames[
            i + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i + 6
            /*SHEARY*/
          ];
          var t = (time - before) / (frames[
            i + 7
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i + 7 + 1
            /*ROTATE*/
          ] - rotate) * t;
          x += (frames[
            i + 7 + 2
            /*X*/
          ] - x) * t;
          y += (frames[
            i + 7 + 3
            /*Y*/
          ] - y) * t;
          scaleX += (frames[
            i + 7 + 4
            /*SCALEX*/
          ] - scaleX) * t;
          scaleY += (frames[
            i + 7 + 5
            /*SCALEY*/
          ] - scaleY) * t;
          shearY += (frames[
            i + 7 + 6
            /*SHEARY*/
          ] - shearY) * t;
          break;
        case 1:
          rotate = frames[
            i + 1
            /*ROTATE*/
          ];
          x = frames[
            i + 2
            /*X*/
          ];
          y = frames[
            i + 3
            /*Y*/
          ];
          scaleX = frames[
            i + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i + 6
            /*SHEARY*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          scaleX = this.getBezierValue(
            time,
            i,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          scaleY = this.getBezierValue(
            time,
            i,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          shearY = this.getBezierValue(
            time,
            i,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        var data = constraint.data;
        constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
        constraint.mixX = data.mixX + (x - data.mixX) * alpha;
        constraint.mixY = data.mixY + (y - data.mixY) * alpha;
        constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
        constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
        constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
        constraint.mixX += (x - constraint.mixX) * alpha;
        constraint.mixY += (y - constraint.mixY) * alpha;
        constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
        constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
        constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
      }
    };
    return TransformConstraintTimeline4;
  }(CurveTimeline3)
);
var PathConstraintPositionTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(PathConstraintPositionTimeline4, _super);
    function PathConstraintPositionTimeline4(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.pathConstraintPosition + "|" + pathConstraintIndex) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintPositionTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha;
        }
        return;
      }
      var position = this.getCurveValue(time);
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
      else
        constraint.position += (position - constraint.position) * alpha;
    };
    return PathConstraintPositionTimeline4;
  }(CurveTimeline1)
);
var PathConstraintSpacingTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(PathConstraintSpacingTimeline4, _super);
    function PathConstraintSpacingTimeline4(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.pathConstraintSpacing + "|" + pathConstraintIndex) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintSpacingTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
        }
        return;
      }
      var spacing = this.getCurveValue(time);
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha;
    };
    return PathConstraintSpacingTimeline4;
  }(CurveTimeline1)
);
var PathConstraintMixTimeline3 = (
  /** @class */
  function(_super) {
    __extends4(PathConstraintMixTimeline4, _super);
    function PathConstraintMixTimeline4(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.pathConstraintMix + "|" + pathConstraintIndex
      ]) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintMixTimeline4.prototype.getFrameEntries = function() {
      return 4;
    };
    PathConstraintMixTimeline4.prototype.setFrame = function(frame, time, mixRotate, mixX, mixY) {
      var frames = this.frames;
      frame <<= 2;
      frames[frame] = time;
      frames[
        frame + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame + 2
        /*X*/
      ] = mixX;
      frames[
        frame + 3
        /*Y*/
      ] = mixY;
    };
    PathConstraintMixTimeline4.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = constraint.data.mixRotate;
            constraint.mixX = constraint.data.mixX;
            constraint.mixY = constraint.data.mixY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
            constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
            constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
        }
        return;
      }
      var rotate, x, y;
      var i = Timeline.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      var curveType = this.curves[i >> 2];
      switch (curveType) {
        case 0:
          var before = frames[i];
          rotate = frames[
            i + 1
            /*ROTATE*/
          ];
          x = frames[
            i + 2
            /*X*/
          ];
          y = frames[
            i + 3
            /*Y*/
          ];
          var t = (time - before) / (frames[
            i + 4
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i + 4 + 1
            /*ROTATE*/
          ] - rotate) * t;
          x += (frames[
            i + 4 + 2
            /*X*/
          ] - x) * t;
          y += (frames[
            i + 4 + 3
            /*Y*/
          ] - y) * t;
          break;
        case 1:
          rotate = frames[
            i + 1
            /*ROTATE*/
          ];
          x = frames[
            i + 2
            /*X*/
          ];
          y = frames[
            i + 3
            /*Y*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x = this.getBezierValue(
            time,
            i,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y = this.getBezierValue(
            time,
            i,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        var data = constraint.data;
        constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
        constraint.mixX = data.mixX + (x - data.mixX) * alpha;
        constraint.mixY = data.mixY + (y - data.mixY) * alpha;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
        constraint.mixX += (x - constraint.mixX) * alpha;
        constraint.mixY += (y - constraint.mixY) * alpha;
      }
    };
    return PathConstraintMixTimeline4;
  }(CurveTimeline3)
);
var SequenceTimeline = (
  /** @class */
  function(_super) {
    __extends4(SequenceTimeline2, _super);
    function SequenceTimeline2(frameCount, slotIndex, attachment) {
      var _this = _super.call(this, frameCount, [
        Property.sequence + "|" + slotIndex + "|" + attachment.sequence.id
      ]) || this;
      _this.slotIndex = slotIndex;
      _this.attachment = attachment;
      return _this;
    }
    SequenceTimeline2.prototype.getFrameEntries = function() {
      return SequenceTimeline2.ENTRIES;
    };
    SequenceTimeline2.prototype.getSlotIndex = function() {
      return this.slotIndex;
    };
    SequenceTimeline2.prototype.getAttachment = function() {
      return this.attachment;
    };
    SequenceTimeline2.prototype.setFrame = function(frame, time, mode, index, delay) {
      var frames = this.frames;
      frame *= SequenceTimeline2.ENTRIES;
      frames[frame] = time;
      frames[frame + SequenceTimeline2.MODE] = mode | index << 4;
      frames[frame + SequenceTimeline2.DELAY] = delay;
    };
    SequenceTimeline2.prototype.apply = function(skeleton, lastTime, time, events, alpha, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.attachment;
      var attachment = this.attachment;
      if (slotAttachment != attachment) {
        if (!(slotAttachment instanceof VertexAttachment3) || slotAttachment.timelineAttachment != attachment)
          return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          slot.sequenceIndex = -1;
        return;
      }
      var i = Timeline.search(frames, time, SequenceTimeline2.ENTRIES);
      var before = frames[i];
      var modeAndIndex = frames[i + SequenceTimeline2.MODE];
      var delay = frames[i + SequenceTimeline2.DELAY];
      if (!this.attachment.sequence)
        return;
      var index = modeAndIndex >> 4, count = this.attachment.sequence.regions.length;
      var mode = SequenceModeValues[modeAndIndex & 15];
      if (mode != SequenceMode.hold) {
        index += (time - before) / delay + 1e-5 | 0;
        switch (mode) {
          case SequenceMode.once:
            index = Math.min(count - 1, index);
            break;
          case SequenceMode.loop:
            index %= count;
            break;
          case SequenceMode.pingpong: {
            var n = (count << 1) - 2;
            index = n == 0 ? 0 : index % n;
            if (index >= count)
              index = n - index;
            break;
          }
          case SequenceMode.onceReverse:
            index = Math.max(count - 1 - index, 0);
            break;
          case SequenceMode.loopReverse:
            index = count - 1 - index % count;
            break;
          case SequenceMode.pingpongReverse: {
            var n = (count << 1) - 2;
            index = n == 0 ? 0 : (index + count - 1) % n;
            if (index >= count)
              index = n - index;
          }
        }
      }
      slot.sequenceIndex = index;
    };
    SequenceTimeline2.ENTRIES = 3;
    SequenceTimeline2.MODE = 1;
    SequenceTimeline2.DELAY = 2;
    return SequenceTimeline2;
  }(Timeline)
);
var AnimationState3 = (
  /** @class */
  function() {
    function AnimationState4(data) {
      this.tracks = new Array();
      this.timeScale = 1;
      this.unkeyedState = 0;
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue3(this);
      this.propertyIDs = new StringSet();
      this.animationsChanged = false;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry3();
      });
      this.data = data;
    }
    AnimationState4.emptyAnimation = function() {
      return AnimationState4._emptyAnimation;
    };
    AnimationState4.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i = 0, n = tracks.length; i < n; i++) {
        var current = tracks[i];
        if (!current)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next = current.next;
        if (next) {
          var nextTime = current.trackLast - next.delay;
          if (nextTime >= 0) {
            next.delay = 0;
            next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i, next, true);
            while (next.mixingFrom) {
              next.mixTime += delta;
              next = next.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
          tracks[i] = null;
          this.queue.end(current);
          this.clearNext(current);
          continue;
        }
        if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
          var from = current.mixingFrom;
          current.mixingFrom = null;
          if (from)
            from.mixingTo = null;
          while (from) {
            this.queue.end(from);
            from = from.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState4.prototype.updateMixingFrom = function(to, delta) {
      var from = to.mixingFrom;
      if (!from)
        return true;
      var finished = this.updateMixingFrom(from, delta);
      from.animationLast = from.nextAnimationLast;
      from.trackLast = from.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from.mixingFrom;
          if (from.mixingFrom)
            from.mixingFrom.mixingTo = to;
          to.interruptAlpha = from.interruptAlpha;
          this.queue.end(from);
        }
        return finished;
      }
      from.trackTime += delta * from.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState4.prototype.apply = function(skeleton) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i_1 = 0, n_1 = tracks.length; i_1 < n_1; i_1++) {
        var current = tracks[i_1];
        if (!current || current.delay > 0)
          continue;
        applied = true;
        var blend = i_1 == 0 ? MixBlend.first : current.mixBlend;
        var mix = current.alpha;
        if (current.mixingFrom)
          mix *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && !current.next)
          mix = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;
        var applyEvents = events;
        if (current.reverse) {
          applyTime = current.animation.duration - applyTime;
          applyEvents = null;
        }
        var timelines = current.animation.timelines;
        var timelineCount = timelines.length;
        if (i_1 == 0 && mix == 1 || blend == MixBlend.add) {
          for (var ii = 0; ii < timelineCount; ii++) {
            Utils.webkit602BugfixHelper(mix, blend);
            var timeline = timelines[ii];
            if (timeline instanceof AttachmentTimeline3)
              this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
            else
              timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var shortestRotation = current.shortestRotation;
          var firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
          if (firstFrame)
            current.timelinesRotation.length = timelineCount << 1;
          for (var ii = 0; ii < timelineCount; ii++) {
            var timeline_1 = timelines[ii];
            var timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;
            if (!shortestRotation && timeline_1 instanceof RotateTimeline3) {
              this.applyRotateTimeline(timeline_1, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
            } else if (timeline_1 instanceof AttachmentTimeline3) {
              this.applyAttachmentTimeline(timeline_1, skeleton, applyTime, blend, true);
            } else {
              Utils.webkit602BugfixHelper(mix, blend);
              timeline_1.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      var setupState = this.unkeyedState + SETUP;
      var slots = skeleton.slots;
      for (var i = 0, n = skeleton.slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.attachmentState == setupState) {
          var attachmentName = slot.data.attachmentName;
          slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
        }
      }
      this.unkeyedState += 2;
      this.queue.drain();
      return applied;
    };
    AnimationState4.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from = to.mixingFrom;
      if (from.mixingFrom)
        this.applyMixingFrom(from, skeleton, blend);
      var mix = 0;
      if (to.mixDuration == 0) {
        mix = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix = to.mixTime / to.mixDuration;
        if (mix > 1)
          mix = 1;
        if (blend != MixBlend.first)
          blend = from.mixBlend;
      }
      var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
      var timelines = from.animation.timelines;
      var timelineCount = timelines.length;
      var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
      var animationLast = from.animationLast, animationTime = from.getAnimationTime(), applyTime = animationTime;
      var events = null;
      if (from.reverse)
        applyTime = from.animation.duration - applyTime;
      else if (mix < from.eventThreshold)
        events = this.events;
      if (blend == MixBlend.add) {
        for (var i = 0; i < timelineCount; i++)
          timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from.timelineMode;
        var timelineHoldMix = from.timelineHoldMix;
        var shortestRotation = from.shortestRotation;
        var firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          from.timelinesRotation.length = timelineCount << 1;
        from.totalAlpha = 0;
        for (var i = 0; i < timelineCount; i++) {
          var timeline = timelines[i];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha = 0;
          switch (timelineMode[i]) {
            case SUBSEQUENT:
              if (!drawOrder && timeline instanceof DrawOrderTimeline3)
                continue;
              timelineBlend = blend;
              alpha = alphaMix;
              break;
            case FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaMix;
              break;
            case HOLD_SUBSEQUENT:
              timelineBlend = blend;
              alpha = alphaHold;
              break;
            case HOLD_FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i];
              alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from.totalAlpha += alpha;
          if (!shortestRotation && timeline instanceof RotateTimeline3)
            this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);
          else if (timeline instanceof AttachmentTimeline3)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
          else {
            Utils.webkit602BugfixHelper(alpha, blend);
            if (drawOrder && timeline instanceof DrawOrderTimeline3 && timelineBlend == MixBlend.setup)
              direction = MixDirection.mixIn;
            timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from, animationTime);
      this.events.length = 0;
      from.nextAnimationLast = animationTime;
      from.nextTrackLast = from.trackTime;
      return mix;
    };
    AnimationState4.prototype.applyAttachmentTimeline = function(timeline, skeleton, time, blend, attachments) {
      var slot = skeleton.slots[timeline.slotIndex];
      if (!slot.bone.active)
        return;
      if (time < timeline.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
      } else
        this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);
      if (slot.attachmentState <= this.unkeyedState)
        slot.attachmentState = this.unkeyedState + SETUP;
    };
    AnimationState4.prototype.setAttachment = function(skeleton, slot, attachmentName, attachments) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      if (attachments)
        slot.attachmentState = this.unkeyedState + CURRENT;
    };
    AnimationState4.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
      if (firstFrame)
        timelinesRotation[i] = 0;
      if (alpha == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var bone = skeleton.bones[timeline.boneIndex];
      if (!bone.active)
        return;
      var frames = timeline.frames;
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        r2 = bone.data.rotation + timeline.getCurveValue(time);
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i];
          lastDiff = timelinesRotation[i + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i] = total;
      }
      timelinesRotation[i + 1] = diff;
      bone.rotation = r1 + total * alpha;
    };
    AnimationState4.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i = 0, n = events.length;
      for (; i < n; i++) {
        var event_1 = events[i];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i < n; i++) {
        var event_2 = events[i];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, event_2);
      }
    };
    AnimationState4.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++)
        this.clearTrack(i);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (!current)
        return;
      this.queue.end(current);
      this.clearNext(current);
      var entry = current;
      while (true) {
        var from = entry.mixingFrom;
        if (!from)
          break;
        this.queue.end(from);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState4.prototype.setCurrent = function(index, current, interrupt) {
      var from = this.expandToIndex(index);
      this.tracks[index] = current;
      current.previous = null;
      if (from) {
        if (interrupt)
          this.queue.interrupt(from);
        current.mixingFrom = from;
        from.mixingTo = current;
        current.mixTime = 0;
        if (from.mixingFrom && from.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
        from.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState4.prototype.setAnimation = function(trackIndex, animationName, loop) {
      if (loop === void 0) {
        loop = false;
      }
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (!animation)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation, loop);
    };
    AnimationState4.prototype.setAnimationWith = function(trackIndex, animation, loop) {
      if (loop === void 0) {
        loop = false;
      }
      if (!animation)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.clearNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.clearNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState4.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      if (loop === void 0) {
        loop = false;
      }
      if (delay === void 0) {
        delay = 0;
      }
      var animation = this.data.skeletonData.findAnimation(animationName);
      if (!animation)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation, loop, delay);
    };
    AnimationState4.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
      if (loop === void 0) {
        loop = false;
      }
      if (delay === void 0) {
        delay = 0;
      }
      if (!animation)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last) {
        while (last.next)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation, loop, last);
      if (!last) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        entry.previous = last;
        if (delay <= 0)
          delay += last.getTrackComplete() - entry.mixDuration;
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      var entry = this.setAnimationWith(trackIndex, AnimationState4.emptyAnimation(), false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      if (delay === void 0) {
        delay = 0;
      }
      var entry = this.addAnimationWith(trackIndex, AnimationState4.emptyAnimation(), false, delay);
      if (delay <= 0)
        entry.delay += entry.mixDuration - mixDuration;
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState4.prototype.setEmptyAnimations = function(mixDuration) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i = 0, n = this.tracks.length; i < n; i++) {
        var current = this.tracks[i];
        if (current)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState4.prototype.expandToIndex = function(index) {
      if (index < this.tracks.length)
        return this.tracks[index];
      Utils.ensureArrayCapacity(this.tracks, index + 1, null);
      this.tracks.length = index + 1;
      return null;
    };
    AnimationState4.prototype.trackEntry = function(trackIndex, animation, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.reset();
      entry.trackIndex = trackIndex;
      entry.animation = animation;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.reverse = false;
      entry.shortestRotation = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
      entry.interruptAlpha = 1;
      entry.totalAlpha = 0;
      entry.mixBlend = MixBlend.replace;
      return entry;
    };
    AnimationState4.prototype.clearNext = function(entry) {
      var next = entry.next;
      while (next) {
        this.queue.dispose(next);
        next = next.next;
      }
      entry.next = null;
    };
    AnimationState4.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      var tracks = this.tracks;
      for (var i = 0, n = tracks.length; i < n; i++) {
        var entry = tracks[i];
        if (!entry)
          continue;
        while (entry.mixingFrom)
          entry = entry.mixingFrom;
        do {
          if (!entry.mixingTo || entry.mixBlend != MixBlend.add)
            this.computeHold(entry);
          entry = entry.mixingTo;
        } while (entry);
      }
    };
    AnimationState4.prototype.computeHold = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = entry.timelineMode;
      timelineMode.length = timelinesCount;
      var timelineHoldMix = entry.timelineHoldMix;
      timelineHoldMix.length = 0;
      var propertyIDs = this.propertyIDs;
      if (to && to.holdPrevious) {
        for (var i = 0; i < timelinesCount; i++)
          timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
        return;
      }
      outer: for (var i = 0; i < timelinesCount; i++) {
        var timeline = timelines[i];
        var ids = timeline.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i] = SUBSEQUENT;
        else if (!to || timeline instanceof AttachmentTimeline3 || timeline instanceof DrawOrderTimeline3 || timeline instanceof EventTimeline3 || !to.animation.hasTimeline(ids)) {
          timelineMode[i] = FIRST;
        } else {
          for (var next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = HOLD_MIX;
              timelineHoldMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = HOLD_FIRST;
        }
      }
    };
    AnimationState4.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState4.prototype.addListener = function(listener) {
      if (!listener)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState4.prototype.removeListener = function(listener) {
      var index = this.listeners.indexOf(listener);
      if (index >= 0)
        this.listeners.splice(index, 1);
    };
    AnimationState4.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState4.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState4.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState4.deprecatedWarning1) {
        AnimationState4.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState4.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState4.deprecatedWarning2) {
        AnimationState4.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState4.prototype.hasAnimation = function(animationName) {
      var animation = this.data.skeletonData.findAnimation(animationName);
      return animation !== null;
    };
    AnimationState4.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState4.deprecatedWarning3) {
        AnimationState4.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState4._emptyAnimation = new Animation3("<empty>", [], 0);
    AnimationState4.deprecatedWarning1 = false;
    AnimationState4.deprecatedWarning2 = false;
    AnimationState4.deprecatedWarning3 = false;
    return AnimationState4;
  }()
);
var TrackEntry3 = (
  /** @class */
  function() {
    function TrackEntry4() {
      this.animation = null;
      this.previous = null;
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.listener = null;
      this.trackIndex = 0;
      this.loop = false;
      this.holdPrevious = false;
      this.reverse = false;
      this.shortestRotation = false;
      this.eventThreshold = 0;
      this.attachmentThreshold = 0;
      this.drawOrderThreshold = 0;
      this.animationStart = 0;
      this.animationEnd = 0;
      this.animationLast = 0;
      this.nextAnimationLast = 0;
      this.delay = 0;
      this.trackTime = 0;
      this.trackLast = 0;
      this.nextTrackLast = 0;
      this.trackEnd = 0;
      this.timeScale = 0;
      this.alpha = 0;
      this.mixTime = 0;
      this.mixDuration = 0;
      this.interruptAlpha = 0;
      this.totalAlpha = 0;
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry4.prototype.reset = function() {
      this.next = null;
      this.previous = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry4.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry4.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry4.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry4.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    TrackEntry4.prototype.getTrackComplete = function() {
      var duration = this.animationEnd - this.animationStart;
      if (duration != 0) {
        if (this.loop)
          return duration * (1 + (this.trackTime / duration | 0));
        if (this.trackTime < duration)
          return duration;
      }
      return this.trackTime;
    };
    Object.defineProperty(TrackEntry4.prototype, "time", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning1) {
          TrackEntry4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry4.prototype, "endTime", {
      get: function() {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry4.deprecatedWarning2) {
          TrackEntry4.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry4.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry4.deprecatedWarning1 = false;
    TrackEntry4.deprecatedWarning2 = false;
    return TrackEntry4;
  }()
);
var EventQueue3 = (
  /** @class */
  function() {
    function EventQueue4(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue4.prototype.start = function(entry) {
      this.objects.push(EventType3.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.interrupt = function(entry) {
      this.objects.push(EventType3.interrupt);
      this.objects.push(entry);
    };
    EventQueue4.prototype.end = function(entry) {
      this.objects.push(EventType3.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue4.prototype.dispose = function(entry) {
      this.objects.push(EventType3.dispose);
      this.objects.push(entry);
    };
    EventQueue4.prototype.complete = function(entry) {
      this.objects.push(EventType3.complete);
      this.objects.push(entry);
    };
    EventQueue4.prototype.event = function(entry, event) {
      this.objects.push(EventType3.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue4.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i = 0; i < objects.length; i += 2) {
        var type = objects[i];
        var entry = objects[i + 1];
        switch (type) {
          case EventType3.start:
            if (entry.listener && entry.listener.start)
              entry.listener.start(entry);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.start)
                listener.start(entry);
            }
            break;
          case EventType3.interrupt:
            if (entry.listener && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.interrupt)
                listener.interrupt(entry);
            }
            break;
          case EventType3.end:
            if (entry.listener && entry.listener.end)
              entry.listener.end(entry);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.end)
                listener.end(entry);
            }
          case EventType3.dispose:
            if (entry.listener && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.dispose)
                listener.dispose(entry);
            }
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType3.complete:
            if (entry.listener && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.complete)
                listener.complete(entry);
            }
            break;
          case EventType3.event:
            var event_3 = objects[i++ + 2];
            if (entry.listener && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii = 0; ii < listeners.length; ii++) {
              var listener = listeners[ii];
              if (listener.event)
                listener.event(entry, event_3);
            }
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue4.prototype.clear = function() {
      this.objects.length = 0;
    };
    return EventQueue4;
  }()
);
var EventType3;
(function(EventType4) {
  EventType4[EventType4["start"] = 0] = "start";
  EventType4[EventType4["interrupt"] = 1] = "interrupt";
  EventType4[EventType4["end"] = 2] = "end";
  EventType4[EventType4["dispose"] = 3] = "dispose";
  EventType4[EventType4["complete"] = 4] = "complete";
  EventType4[EventType4["event"] = 5] = "event";
})(EventType3 || (EventType3 = {}));
var AnimationStateAdapter3 = (
  /** @class */
  function() {
    function AnimationStateAdapter4() {
    }
    AnimationStateAdapter4.prototype.start = function(entry) {
    };
    AnimationStateAdapter4.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter4.prototype.end = function(entry) {
    };
    AnimationStateAdapter4.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter4.prototype.complete = function(entry) {
    };
    AnimationStateAdapter4.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter4;
  }()
);
var SUBSEQUENT = 0;
var FIRST = 1;
var HOLD_SUBSEQUENT = 2;
var HOLD_FIRST = 3;
var HOLD_MIX = 4;
var SETUP = 1;
var CURRENT = 2;
var AnimationStateData3 = (
  /** @class */
  function() {
    function AnimationStateData4(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (!skeletonData)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData4.prototype.setMix = function(fromName, toName, duration) {
      var from = this.skeletonData.findAnimation(fromName);
      if (!from)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (!to)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from, to, duration);
    };
    AnimationStateData4.prototype.setMixWith = function(from, to, duration) {
      if (!from)
        throw new Error("from cannot be null.");
      if (!to)
        throw new Error("to cannot be null.");
      var key = from.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData4.prototype.getMix = function(from, to) {
      var key = from.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    return AnimationStateData4;
  }()
);
var AtlasAttachmentLoader3 = (
  /** @class */
  function() {
    function AtlasAttachmentLoader4(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader4.prototype.loadSequence = function(name, basePath, sequence) {
      var regions = sequence.regions;
      for (var i = 0, n = regions.length; i < n; i++) {
        var path = sequence.getPath(basePath, i);
        var region = this.atlas.findRegion(path);
        if (region == null)
          throw new Error("Region not found in atlas: " + path + " (sequence: " + name + ")");
        regions[i] = region;
        regions[i].renderObject = regions[i];
      }
    };
    AtlasAttachmentLoader4.prototype.newRegionAttachment = function(skin, name, path, sequence) {
      var attachment = new RegionAttachment3(name, path);
      if (sequence != null) {
        this.loadSequence(name, path, sequence);
      } else {
        var region = this.atlas.findRegion(path);
        if (!region)
          throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
        region.renderObject = region;
        attachment.region = region;
      }
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newMeshAttachment = function(skin, name, path, sequence) {
      var attachment = new MeshAttachment3(name, path);
      if (sequence != null) {
        this.loadSequence(name, path, sequence);
      } else {
        var region = this.atlas.findRegion(path);
        if (!region)
          throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
        region.renderObject = region;
        attachment.region = region;
      }
      return attachment;
    };
    AtlasAttachmentLoader4.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment3(name);
    };
    AtlasAttachmentLoader4.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment3(name);
    };
    AtlasAttachmentLoader4.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment3(name);
    };
    AtlasAttachmentLoader4.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment3(name);
    };
    return AtlasAttachmentLoader4;
  }()
);
var Bone3 = (
  /** @class */
  function() {
    function Bone4(data, skeleton, parent) {
      this.matrix = new Matrix();
      this.parent = null;
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.sorted = false;
      this.active = false;
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone4.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone4.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone4.prototype.isActive = function() {
      return this.active;
    };
    Bone4.prototype.update = function() {
      this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
    };
    Bone4.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone4.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      var parent = this.parent;
      var m = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
      if (!parent) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m.tx = x * sx + skeleton.x;
        m.ty = y * sy + skeleton.y;
        return;
      }
      var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
      m.tx = pa * x + pb * y + parent.matrix.tx;
      m.ty = pc * x + pd * y + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb = MathUtils.cosDeg(rotationY) * scaleY;
          var lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld = MathUtils.sinDeg(rotationY) * scaleY;
          m.a = pa * la + pb * lc;
          m.c = pa * lb + pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m.c = MathUtils.cosDeg(rotationY) * scaleY;
          m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s = pa * pa + pc * pc;
          var prx = 0;
          if (s > 1e-4) {
            s = Math.abs(pa * pd - pb * pc) / s;
            pa /= sx;
            pc /= sy;
            pb = pc * s;
            pd = pa * s;
            prx = Math.atan2(pc, pa) * MathUtils.radDeg;
          } else {
            pa = 0;
            pc = 0;
            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la = MathUtils.cosDeg(rx) * scaleX;
          var lb = MathUtils.cosDeg(ry) * scaleY;
          var lc = MathUtils.sinDeg(rx) * scaleX;
          var ld = MathUtils.sinDeg(ry) * scaleY;
          m.a = pa * la - pb * lc;
          m.c = pa * lb - pb * ld;
          m.b = pc * la + pd * lc;
          m.d = pc * lb + pd * ld;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za = (pa * cos + pb * sin) / sx;
          var zc = (pc * cos + pd * sin) / sy;
          var s = Math.sqrt(za * za + zc * zc);
          if (s > 1e-5)
            s = 1 / s;
          za *= s;
          zc *= s;
          s = Math.sqrt(za * za + zc * zc);
          if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))
            s = -s;
          var r = Math.PI / 2 + Math.atan2(zc, za);
          var zb = Math.cos(r) * s;
          var zd = Math.sin(r) * s;
          var la = MathUtils.cosDeg(shearX) * scaleX;
          var lb = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc = MathUtils.sinDeg(shearX) * scaleX;
          var ld = MathUtils.sinDeg(90 + shearY) * scaleY;
          m.a = za * la + zb * lc;
          m.c = za * lb + zb * ld;
          m.b = zc * la + zd * lc;
          m.d = zc * lb + zd * ld;
          break;
        }
      }
      m.a *= sx;
      m.c *= sx;
      m.b *= sy;
      m.d *= sy;
    };
    Bone4.prototype.setToSetupPose = function() {
      var data = this.data;
      this.x = data.x;
      this.y = data.y;
      this.rotation = data.rotation;
      this.scaleX = data.scaleX;
      this.scaleY = data.scaleY;
      this.shearX = data.shearX;
      this.shearY = data.shearY;
    };
    Bone4.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone4.prototype.getWorldScaleX = function() {
      var m = this.matrix;
      return Math.sqrt(m.a * m.a + m.b * m.b);
    };
    Bone4.prototype.getWorldScaleY = function() {
      var m = this.matrix;
      return Math.sqrt(m.c * m.c + m.d * m.d);
    };
    Bone4.prototype.updateAppliedTransform = function() {
      var parent = this.parent;
      var m = this.matrix;
      if (!parent) {
        this.ax = m.tx - this.skeleton.x;
        this.ay = m.ty - this.skeleton.y;
        this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
        this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m.tx - pm.tx, dy = m.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia = pid * pm.d;
      var id = pid * pm.a;
      var ib = pid * pm.c;
      var ic = pid * pm.b;
      var ra = ia * m.a - ib * m.b;
      var rb = ia * m.c - ib * m.d;
      var rc = id * m.b - ic * m.a;
      var rd = id * m.d - ic * m.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra * ra + rc * rc);
      if (this.ascaleX > 1e-4) {
        var det = ra * rd - rb * rc;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb * rb + rd * rd);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
      }
    };
    Bone4.prototype.worldToLocal = function(world) {
      var m = this.matrix;
      var a = m.a, b = m.c, c = m.b, d = m.d;
      var invDet = 1 / (a * d - b * c);
      var x = world.x - m.tx, y = world.y - m.ty;
      world.x = x * d * invDet - y * b * invDet;
      world.y = y * a * invDet - x * c * invDet;
      return world;
    };
    Bone4.prototype.localToWorld = function(local) {
      var m = this.matrix;
      var x = local.x, y = local.y;
      local.x = x * m.a + y * m.c + m.tx;
      local.y = x * m.b + y * m.d + m.ty;
      return local;
    };
    Bone4.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone4.prototype.localToWorldRotation = function(localRotation) {
      localRotation -= this.rotation - this.shearX;
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone4.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a - sin * c;
      mat.c = cos * b - sin * d;
      mat.b = sin * a + cos * c;
      mat.d = sin * b + cos * d;
    };
    return Bone4;
  }()
);
var BoneData3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoneData4(index, name, parent) {
      this.index = 0;
      this.parent = null;
      this.length = 0;
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      this.skinRequired = false;
      this.color = new Color();
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      this.index = index;
      this.name = name;
      this.parent = parent;
    }
    return BoneData4;
  }()
);
var ConstraintData2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ConstraintData3(name, order, skinRequired) {
      this.name = name;
      this.order = order;
      this.skinRequired = skinRequired;
    }
    return ConstraintData3;
  }()
);
var Event3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Event4(time, data) {
      this.intValue = 0;
      this.floatValue = 0;
      this.stringValue = null;
      this.time = 0;
      this.volume = 0;
      this.balance = 0;
      if (!data)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data;
    }
    return Event4;
  }()
);
var EventData3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventData4(name) {
      this.intValue = 0;
      this.floatValue = 0;
      this.stringValue = null;
      this.audioPath = null;
      this.volume = 0;
      this.balance = 0;
      this.name = name;
    }
    return EventData4;
  }()
);
var IkConstraint3 = (
  /** @class */
  function() {
    function IkConstraint4(data, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      this.softness = 0;
      this.active = false;
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.mix = data.mix;
      this.softness = data.softness;
      this.bendDirection = data.bendDirection;
      this.compress = data.compress;
      this.stretch = data.stretch;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++) {
        var bone = skeleton.findBone(data.bones[i].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data.bones[i].name);
        this.bones.push(bone);
      }
      var target = skeleton.findBone(data.target.name);
      if (!target)
        throw new Error("Couldn't find bone " + data.target.name);
      this.target = target;
    }
    IkConstraint4.prototype.isActive = function() {
      return this.active;
    };
    IkConstraint4.prototype.update = function() {
      if (this.mix == 0)
        return;
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
          break;
      }
    };
    IkConstraint4.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha) {
      var p = bone.parent.matrix;
      if (!p)
        throw new Error("IK bone must have parent.");
      var pa = p.a, pb = p.c, pc = p.b, pd = p.d;
      var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
      var skelX = bone.skeleton.scaleX;
      var skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;
      switch (bone.data.transformMode) {
        case TransformMode.OnlyTranslation:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
          if (settings.yDown) {
            ty = -ty;
          }
          break;
        case TransformMode.NoRotationOrReflection:
          var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
          var sa = pa / skelX;
          var sc = pc / skelY;
          pb = -sc * s * skelX;
          pd = sa * s * skelY;
          rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
        default:
          var x = targetX - p.tx, y = targetY - p.ty;
          var d = pa * pd - pb * pc;
          tx = (x * pd - y * pb) / d - bone.ax;
          ty = (y * pa - x * pc) / d - bone.ay;
      }
      rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        switch (bone.data.transformMode) {
          case TransformMode.NoScale:
          case TransformMode.NoScaleOrReflection:
            tx = targetX - bone.worldX;
            ty = targetY - bone.worldY;
        }
        var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd < b || stretch && dd > b && b > 1e-4) {
          var s = (dd / b - 1) * alpha + 1;
          sx *= s;
          if (uniform)
            sy *= s;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint4.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;
      var u = Math.abs(psx - psy) <= 1e-4;
      if (!u || stretch) {
        cy = 0;
        cwx = a * cx + pmat.tx;
        cwy = c * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a * cx + b * cy + pmat.tx;
        cwy = c * cx + d * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      if (!pp)
        throw new Error("IK parent must itself have a parent.");
      a = pp.a;
      b = pp.c;
      c = pp.b;
      d = pp.d;
      var id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;
      var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;
      if (l1 < 1e-4) {
        this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
        child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        return;
      }
      x = targetX - pp.tx;
      y = targetY - pp.ty;
      var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
      var dd = tx * tx + ty * ty;
      if (softness != 0) {
        softness *= psx * (csx + 1) * 0.5;
        var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;
        if (sd > 0) {
          var p = Math.min(1, sd / (softness * 2)) - 1;
          p = (sd - softness * (1 - p * p)) / td;
          tx -= p * tx;
          ty -= p * ty;
          dd = tx * tx + ty * ty;
        }
      }
      outer: if (u) {
        l2 *= psx;
        var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a2 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a2 = 0;
          if (stretch) {
            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a;
            if (uniform)
              sy *= a;
          }
        } else
          a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        var c1 = -2 * bb * l1, c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          var q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          var r0 = q / c2, r1 = c / q;
          var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        var minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
        var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
      rotation = child.arotation;
      a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a2 > 180)
        a2 -= 360;
      else if (a2 < -180)
        a2 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint4;
  }()
);
var IkConstraintData3 = (
  /** @class */
  function(_super) {
    __extends4(IkConstraintData4, _super);
    function IkConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.bendDirection = 1;
      _this.compress = false;
      _this.stretch = false;
      _this.uniform = false;
      _this.mix = 1;
      _this.softness = 0;
      return _this;
    }
    Object.defineProperty(IkConstraintData4.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("BoneData not set.");
        else
          return this._target;
      },
      set: function(boneData) {
        this._target = boneData;
      },
      enumerable: false,
      configurable: true
    });
    return IkConstraintData4;
  }(ConstraintData2)
);
var PathConstraintData3 = (
  /** @class */
  function(_super) {
    __extends4(PathConstraintData4, _super);
    function PathConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.positionMode = PositionMode.Fixed;
      _this.spacingMode = SpacingMode3.Fixed;
      _this.rotateMode = RotateMode.Chain;
      _this.offsetRotation = 0;
      _this.position = 0;
      _this.spacing = 0;
      _this.mixRotate = 0;
      _this.mixX = 0;
      _this.mixY = 0;
      return _this;
    }
    Object.defineProperty(PathConstraintData4.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("SlotData not set.");
        else
          return this._target;
      },
      set: function(slotData) {
        this._target = slotData;
      },
      enumerable: false,
      configurable: true
    });
    return PathConstraintData4;
  }(ConstraintData2)
);
var SpacingMode3;
(function(SpacingMode4) {
  SpacingMode4[SpacingMode4["Length"] = 0] = "Length";
  SpacingMode4[SpacingMode4["Fixed"] = 1] = "Fixed";
  SpacingMode4[SpacingMode4["Percent"] = 2] = "Percent";
  SpacingMode4[SpacingMode4["Proportional"] = 3] = "Proportional";
})(SpacingMode3 || (SpacingMode3 = {}));
var PathConstraint3 = (
  /** @class */
  function() {
    function PathConstraint4(data, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.mixRotate = 0;
      this.mixX = 0;
      this.mixY = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      this.active = false;
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0, n = data.bones.length; i < n; i++) {
        var bone = skeleton.findBone(data.bones[i].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data.bones[i].name + ".");
        this.bones.push(bone);
      }
      var target = skeleton.findSlot(data.target.name);
      if (!target)
        throw new Error("Couldn't find target bone " + data.target.name);
      this.target = target;
      this.position = data.position;
      this.spacing = data.spacing;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
    }
    PathConstraint4.prototype.isActive = function() {
      return this.active;
    };
    PathConstraint4.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment3))
        return;
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;
      if (mixRotate == 0 && mixX == 0 && mixY == 0)
        return;
      var data = this.data;
      var tangents = data.rotateMode == RotateMode.Tangent, scale = data.rotateMode == RotateMode.ChainScale;
      var bones = this.bones;
      var boneCount = bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];
      var spacing = this.spacing;
      switch (data.spacingMode) {
        case SpacingMode3.Percent:
          if (scale) {
            for (var i = 0, n = spacesCount - 1; i < n; i++) {
              var bone = bones[i];
              var setupLength = bone.data.length;
              if (setupLength < PathConstraint4.epsilon)
                lengths[i] = 0;
              else {
                var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
                lengths[i] = Math.sqrt(x * x + y * y);
              }
            }
          }
          Utils.arrayFill(spaces, 1, spacesCount, spacing);
          break;
        case SpacingMode3.Proportional:
          var sum = 0;
          for (var i = 0, n = spacesCount - 1; i < n; ) {
            var bone = bones[i];
            var setupLength = bone.data.length;
            if (setupLength < PathConstraint4.epsilon) {
              if (scale)
                lengths[i] = 0;
              spaces[++i] = spacing;
            } else {
              var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
              var length_1 = Math.sqrt(x * x + y * y);
              if (scale)
                lengths[i] = length_1;
              spaces[++i] = length_1;
              sum += length_1;
            }
          }
          if (sum > 0) {
            sum = spacesCount / sum * spacing;
            for (var i = 1; i < spacesCount; i++)
              spaces[i] *= sum;
          }
          break;
        default:
          var lengthSpacing = data.spacingMode == SpacingMode3.Length;
          for (var i = 0, n = spacesCount - 1; i < n; ) {
            var bone = bones[i];
            var setupLength = bone.data.length;
            if (setupLength < PathConstraint4.epsilon) {
              if (scale)
                lengths[i] = 0;
              spaces[++i] = spacing;
            } else {
              var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
              var length_2 = Math.sqrt(x * x + y * y);
              if (scale)
                lengths[i] = length_2;
              spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;
            }
          }
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = data.rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
        var bone = bones[i];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * mixX;
        mat.ty += (boneY - mat.ty) * mixY;
        var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
        if (scale) {
          var length_3 = lengths[i];
          if (length_3 != 0) {
            var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * mixRotate + 1;
            mat.a *= s;
            mat.b *= s;
          }
        }
        boneX = x;
        boneY = y;
        if (mixRotate > 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
          r -= Math.atan2(c, a);
          if (tip) {
            cos = Math.cos(r);
            sin = Math.sin(r);
            var length_4 = bone.data.length;
            boneX += (length_4 * (cos * a - sin * c) - dx) * mixRotate;
            boneY += (length_4 * (sin * a + cos * c) - dy) * mixRotate;
          } else {
            r += offsetRotation;
          }
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= mixRotate;
          cos = Math.cos(r);
          sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
        }
        bone.updateAppliedTransform();
      }
    };
    PathConstraint4.prototype.computeWorldPositions = function(path, spacesCount, tangents) {
      var target = this.target;
      var position = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = this.world;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint4.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (this.data.positionMode == PositionMode.Percent)
          position *= pathLength_1;
        var multiplier_1;
        switch (this.data.spacingMode) {
          case SpacingMode3.Percent:
            multiplier_1 = pathLength_1;
            break;
          case SpacingMode3.Proportional:
            multiplier_1 = pathLength_1 / spacesCount;
            break;
          default:
            multiplier_1 = 1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
          var space = spaces[i] * multiplier_1;
          position += space;
          var p = position;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint4.BEFORE) {
              prevCurve = PathConstraint4.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint4.AFTER) {
              prevCurve = PathConstraint4.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o);
            continue;
          }
          for (; ; curve++) {
            var length_5 = lengths[curve];
            if (p > length_5)
              continue;
            if (curve == 0)
              p /= length_5;
            else {
              var prev = lengths[curve - 1];
              p = (p - prev) / (length_5 - prev);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
        cx1 = world[w];
        cy1 = world[w + 1];
        cx2 = world[w + 2];
        cy2 = world[w + 3];
        x2 = world[w + 4];
        y2 = world[w + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (this.data.positionMode == PositionMode.Percent)
        position *= pathLength;
      var multiplier;
      switch (this.data.spacingMode) {
        case SpacingMode3.Percent:
          multiplier = pathLength;
          break;
        case SpacingMode3.Proportional:
          multiplier = pathLength / spacesCount;
          break;
        default:
          multiplier = 1;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
        var space = spaces[i] * multiplier;
        position += space;
        var p = position;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
          continue;
        }
        for (; ; curve++) {
          var length_6 = curves[curve];
          if (p > length_6)
            continue;
          if (curve == 0)
            p /= length_6;
          else {
            var prev = curves[curve - 1];
            p = (p - prev) / (length_6 - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii = curve * 6;
          x1 = world[ii];
          y1 = world[ii + 1];
          cx1 = world[ii + 2];
          cy1 = world[ii + 3];
          cx2 = world[ii + 4];
          cy2 = world[ii + 5];
          x2 = world[ii + 6];
          y2 = world[ii + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii = 1; ii < 8; ii++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_7 = segments[segment];
          if (p > length_7)
            continue;
          if (segment == 0)
            p /= length_7;
          else {
            var prev = segments[segment - 1];
            p = segment + (p - prev) / (length_7 - prev);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
      }
      return out;
    };
    PathConstraint4.prototype.addBeforePosition = function(p, temp, i, out, o) {
      var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addAfterPosition = function(p, temp, i, out, o) {
      var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
      out[o] = x1 + p * Math.cos(r);
      out[o + 1] = y1 + p * Math.sin(r);
      out[o + 2] = r;
    };
    PathConstraint4.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
      if (p == 0 || isNaN(p)) {
        out[o] = x1;
        out[o + 1] = y1;
        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        return;
      }
      var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
      var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o] = x;
      out[o + 1] = y;
      if (tangents) {
        if (p < 1e-3)
          out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        else
          out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
      }
    };
    PathConstraint4.NONE = -1;
    PathConstraint4.BEFORE = -2;
    PathConstraint4.AFTER = -3;
    PathConstraint4.epsilon = 1e-5;
    return PathConstraint4;
  }()
);
var Slot3 = (
  /** @class */
  function() {
    function Slot4(data, bone) {
      this.darkColor = null;
      this.attachment = null;
      this.attachmentState = 0;
      this.sequenceIndex = -1;
      this.deform = new Array();
      if (!data)
        throw new Error("data cannot be null.");
      if (!bone)
        throw new Error("bone cannot be null.");
      this.data = data;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = !data.darkColor ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot4.prototype.getSkeleton = function() {
      return this.bone.skeleton;
    };
    Slot4.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot4.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      if (!(attachment instanceof VertexAttachment3) || !(this.attachment instanceof VertexAttachment3) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
        this.deform.length = 0;
      }
      this.attachment = attachment;
      this.sequenceIndex = -1;
    };
    Slot4.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor)
        this.darkColor.setFromColor(this.data.darkColor);
      if (!this.data.attachmentName)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot4;
  }()
);
var TransformConstraint3 = (
  /** @class */
  function() {
    function TransformConstraint4(data, skeleton) {
      this.mixRotate = 0;
      this.mixX = 0;
      this.mixY = 0;
      this.mixScaleX = 0;
      this.mixScaleY = 0;
      this.mixShearY = 0;
      this.temp = new Vector2();
      this.active = false;
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
      this.mixScaleX = data.mixScaleX;
      this.mixScaleY = data.mixScaleY;
      this.mixShearY = data.mixShearY;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++) {
        var bone = skeleton.findBone(data.bones[i].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data.bones[i].name + ".");
        this.bones.push(bone);
      }
      var target = skeleton.findBone(data.target.name);
      if (!target)
        throw new Error("Couldn't find target bone " + data.target.name + ".");
      this.target = target;
    }
    TransformConstraint4.prototype.isActive = function() {
      return this.active;
    };
    TransformConstraint4.prototype.update = function() {
      if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
        return;
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint4.prototype.applyAbsoluteWorld = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var translate = mixX != 0 || mixY != 0;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var mat = bone.matrix;
        if (mixRotate != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= mixRotate;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
        }
        if (translate) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp.x - mat.tx) * mixX;
          mat.ty += (temp.y - mat.ty) * mixY;
        }
        if (mixScaleX != 0) {
          var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          if (s != 0)
            s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
          mat.a *= s;
          mat.b *= s;
        }
        if (mixScaleY != 0) {
          var s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          if (s != 0)
            s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;
          mat.c *= s;
          mat.d *= s;
        }
        if (mixShearY > 0) {
          var b = mat.c, d = mat.d;
          var by = Math.atan2(d, b);
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r = by + (r + offsetShearY) * mixShearY;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
        }
        bone.updateAppliedTransform();
      }
    };
    TransformConstraint4.prototype.applyRelativeWorld = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var translate = mixX != 0 || mixY != 0;
      var target = this.target;
      var targetMat = target.matrix;
      var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
      var degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var mat = bone.matrix;
        if (mixRotate != 0) {
          var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
          var r = Math.atan2(tc, ta) + offsetRotation;
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          r *= mixRotate;
          var cos = Math.cos(r), sin = Math.sin(r);
          mat.a = cos * a - sin * c;
          mat.c = cos * b - sin * d;
          mat.b = sin * a + cos * c;
          mat.d = sin * b + cos * d;
        }
        if (translate) {
          var temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp.x * mixX;
          mat.ty += temp.y * mixY;
        }
        if (mixScaleX != 0) {
          var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
          mat.a *= s;
          mat.b *= s;
        }
        if (mixScaleY != 0) {
          var s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
          mat.c *= s;
          mat.d *= s;
        }
        if (mixShearY > 0) {
          var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
          if (r > MathUtils.PI)
            r -= MathUtils.PI2;
          else if (r < -MathUtils.PI)
            r += MathUtils.PI2;
          var b = mat.c, d = mat.d;
          r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;
          var s = Math.sqrt(b * b + d * d);
          mat.c = Math.cos(r) * s;
          mat.d = Math.sin(r) * s;
        }
        bone.updateAppliedTransform();
      }
    };
    TransformConstraint4.prototype.applyAbsoluteLocal = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var target = this.target;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var rotation = bone.arotation;
        if (mixRotate != 0) {
          var r = target.arotation - rotation + this.data.offsetRotation;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          rotation += r * mixRotate;
        }
        var x = bone.ax, y = bone.ay;
        x += (target.ax - x + this.data.offsetX) * mixX;
        y += (target.ay - y + this.data.offsetY) * mixY;
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (mixScaleX != 0 && scaleX != 0)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
        if (mixScaleY != 0 && scaleY != 0)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
        var shearY = bone.ashearY;
        if (mixShearY != 0) {
          var r = target.ashearY - shearY + this.data.offsetShearY;
          r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
          shearY += r * mixShearY;
        }
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint4.prototype.applyRelativeLocal = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var target = this.target;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        var rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
        var x = bone.ax + (target.ax + this.data.offsetX) * mixX;
        var y = bone.ay + (target.ay + this.data.offsetY) * mixY;
        var scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
        var scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
        var shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    return TransformConstraint4;
  }()
);
var Skeleton3 = (
  /** @class */
  function() {
    function Skeleton4(data) {
      this._updateCache = new Array();
      this.skin = null;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (!data)
        throw new Error("data cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (var i = 0; i < data.bones.length; i++) {
        var boneData = data.bones[i];
        var bone = void 0;
        if (!boneData.parent)
          bone = new Bone3(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone3(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i = 0; i < data.slots.length; i++) {
        var slotData = data.slots[i];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot3(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i = 0; i < data.ikConstraints.length; i++) {
        var ikConstraintData = data.ikConstraints[i];
        this.ikConstraints.push(new IkConstraint3(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i = 0; i < data.transformConstraints.length; i++) {
        var transformConstraintData = data.transformConstraints[i];
        this.transformConstraints.push(new TransformConstraint3(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i = 0; i < data.pathConstraints.length; i++) {
        var pathConstraintData = data.pathConstraints[i];
        this.pathConstraints.push(new PathConstraint3(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton4.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        bone.sorted = bone.data.skinRequired;
        bone.active = !bone.sorted;
      }
      if (this.skin) {
        var skinBones = this.skin.bones;
        for (var i = 0, n = this.skin.bones.length; i < n; i++) {
          var bone = this.bones[skinBones[i].index];
          do {
            bone.sorted = false;
            bone.active = true;
            bone = bone.parent;
          } while (bone);
        }
      }
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer: for (var i = 0; i < constraintCount; i++) {
        for (var ii = 0; ii < ikCount; ii++) {
          var constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < transformCount; ii++) {
          var constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (var ii = 0; ii < pathCount; ii++) {
          var constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
      for (var i = 0, n = bones.length; i < n; i++)
        this.sortBone(bones[i]);
    };
    Skeleton4.prototype.sortIkConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length == 1) {
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
      } else {
        var child = constrained[constrained.length - 1];
        this.sortBone(child);
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
        child.sorted = true;
      }
    };
    Skeleton4.prototype.sortPathConstraint = function(constraint) {
      constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i = 0, n = this.data.skins.length; i < n; i++)
        this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment3)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i = 0; i < boneCount; i++)
        this.sortBone(constrained[i]);
      this._updateCache.push(constraint);
      for (var i = 0; i < boneCount; i++)
        this.sortReset(constrained[i].children);
      for (var i = 0; i < boneCount; i++)
        constrained[i].sorted = true;
    };
    Skeleton4.prototype.sortTransformConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i = 0; i < boneCount; i++) {
          var child = constrained[i];
          this.sortBone(child.parent);
          this.sortBone(child);
        }
      } else {
        for (var i = 0; i < boneCount; i++) {
          this.sortBone(constrained[i]);
        }
      }
      this._updateCache.push(constraint);
      for (var i = 0; i < boneCount; i++)
        this.sortReset(constrained[i].children);
      for (var i = 0; i < boneCount; i++)
        constrained[i].sorted = true;
    };
    Skeleton4.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton4.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment3))
        return;
      var pathBones = attachment.bones;
      if (!pathBones)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        for (var i = 0, n = pathBones.length; i < n; ) {
          var nn = pathBones[i++];
          nn += i;
          while (i < nn)
            this.sortBone(bones[pathBones[i++]]);
        }
      }
    };
    Skeleton4.prototype.sortBone = function(bone) {
      if (!bone)
        return;
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton4.prototype.sortReset = function(bones) {
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (!bone.active)
          continue;
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton4.prototype.updateWorldTransform = function() {
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
      }
      var updateCache = this._updateCache;
      for (var i = 0, n = updateCache.length; i < n; i++)
        updateCache[i].update();
    };
    Skeleton4.prototype.updateWorldTransformWith = function(parent) {
      var rootBone = this.getRootBone();
      var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
      rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;
      rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;
      var rotationY = rootBone.rotation + 90 + rootBone.shearY;
      var la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
      var lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;
      var lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
      var ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;
      var sx = this.scaleX;
      var sy = settings.yDown ? -this.scaleY : this.scaleY;
      rootBone.matrix.a = (pa * la + pb * lc) * sx;
      rootBone.matrix.c = (pa * lb + pb * ld) * sx;
      rootBone.matrix.b = (pc * la + pd * lc) * sy;
      rootBone.matrix.d = (pc * lb + pd * ld) * sy;
      var updateCache = this._updateCache;
      for (var i = 0, n = updateCache.length; i < n; i++) {
        var updatable = updateCache[i];
        if (updatable != rootBone)
          updatable.update();
      }
    };
    Skeleton4.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton4.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        bones[i].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        constraint.mix = constraint.data.mix;
        constraint.softness = constraint.data.softness;
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      }
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        var data = constraint.data;
        constraint.mixRotate = data.mixRotate;
        constraint.mixX = data.mixX;
        constraint.mixY = data.mixY;
        constraint.mixScaleX = data.mixScaleX;
        constraint.mixScaleY = data.mixScaleY;
        constraint.mixShearY = data.mixShearY;
      }
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        var data = constraint.data;
        constraint.position = data.position;
        constraint.spacing = data.spacing;
        constraint.mixRotate = data.mixRotate;
        constraint.mixX = data.mixX;
        constraint.mixY = data.mixY;
      }
    };
    Skeleton4.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i = 0, n = slots.length; i < n; i++)
        slots[i].setToSetupPose();
    };
    Skeleton4.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton4.prototype.findBone = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton4.prototype.findBoneIndex = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].data.name == boneName)
          return i;
      return -1;
    };
    Skeleton4.prototype.findSlot = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton4.prototype.findSlotIndex = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].data.name == slotName)
          return i;
      return -1;
    };
    Skeleton4.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (!skin)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton4.prototype.setSkin = function(newSkin) {
      if (newSkin == this.skin)
        return;
      if (newSkin) {
        if (this.skin)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            var name_1 = slot.data.attachmentName;
            if (name_1) {
              var attachment = newSkin.getAttachment(i, name_1);
              if (attachment)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
      this.updateCache();
    };
    Skeleton4.prototype.getAttachmentByName = function(slotName, attachmentName) {
      var slot = this.data.findSlot(slotName);
      if (!slot)
        throw new Error("Can't find slot with name " + slotName);
      return this.getAttachment(slot.index, attachmentName);
    };
    Skeleton4.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (!attachmentName)
        throw new Error("attachmentName cannot be null.");
      if (this.skin) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment)
          return attachment;
      }
      if (this.data.defaultSkin)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton4.prototype.setAttachment = function(slotName, attachmentName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName) {
            attachment = this.getAttachment(i, attachmentName);
            if (!attachment)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton4.prototype.findIkConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var ikConstraint = ikConstraints[i];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton4.prototype.findTransformConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.findPathConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton4.prototype.getBoundsRect = function() {
      var offset = new Vector2();
      var size = new Vector2();
      this.getBounds(offset, size);
      return { x: offset.x, y: offset.y, width: size.x, height: size.y };
    };
    Skeleton4.prototype.getBounds = function(offset, size, temp) {
      if (temp === void 0) {
        temp = new Array(2);
      }
      if (!offset)
        throw new Error("offset cannot be null.");
      if (!size)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        if (!slot.bone.active)
          continue;
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment3) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          attachment.computeWorldVertices(slot, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment3) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices) {
          for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
            var x = vertices[ii], y = vertices[ii + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Object.defineProperty(Skeleton4.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton4.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton4.deprecatedWarning1) {
          Skeleton4.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton4.deprecatedWarning1 = false;
    return Skeleton4;
  }()
);
var SkeletonData3 = (
  /** @class */
  function() {
    function SkeletonData4() {
      this.name = null;
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.defaultSkin = null;
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.version = null;
      this.hash = null;
      this.fps = 0;
      this.imagesPath = null;
      this.audioPath = null;
    }
    SkeletonData4.prototype.findBone = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++) {
        var bone = bones[i];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData4.prototype.findBoneIndex = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i = 0, n = bones.length; i < n; i++)
        if (bones[i].name == boneName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSlot = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData4.prototype.findSlotIndex = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i = 0, n = slots.length; i < n; i++)
        if (slots[i].name == slotName)
          return i;
      return -1;
    };
    SkeletonData4.prototype.findSkin = function(skinName) {
      if (!skinName)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i = 0, n = skins.length; i < n; i++) {
        var skin = skins[i];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData4.prototype.findEvent = function(eventDataName) {
      if (!eventDataName)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i = 0, n = events.length; i < n; i++) {
        var event_1 = events[i];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData4.prototype.findAnimation = function(animationName) {
      if (!animationName)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i = 0, n = animations.length; i < n; i++) {
        var animation = animations[i];
        if (animation.name == animationName)
          return animation;
      }
      return null;
    };
    SkeletonData4.prototype.findIkConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i = 0, n = ikConstraints.length; i < n; i++) {
        var constraint = ikConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findTransformConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i = 0, n = transformConstraints.length; i < n; i++) {
        var constraint = transformConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++) {
        var constraint = pathConstraints[i];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData4.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i = 0, n = pathConstraints.length; i < n; i++)
        if (pathConstraints[i].name == pathConstraintName)
          return i;
      return -1;
    };
    return SkeletonData4;
  }()
);
var SlotData3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function SlotData4(index, name, boneData) {
      this.index = 0;
      this.color = new Color(1, 1, 1, 1);
      this.darkColor = null;
      this.attachmentName = null;
      this.blendMode = BLEND_MODES.NORMAL;
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      if (!boneData)
        throw new Error("boneData cannot be null.");
      this.index = index;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData4;
  }()
);
var TransformConstraintData3 = (
  /** @class */
  function(_super) {
    __extends4(TransformConstraintData4, _super);
    function TransformConstraintData4(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.mixRotate = 0;
      _this.mixX = 0;
      _this.mixY = 0;
      _this.mixScaleX = 0;
      _this.mixScaleY = 0;
      _this.mixShearY = 0;
      _this.offsetRotation = 0;
      _this.offsetX = 0;
      _this.offsetY = 0;
      _this.offsetScaleX = 0;
      _this.offsetScaleY = 0;
      _this.offsetShearY = 0;
      _this.relative = false;
      _this.local = false;
      return _this;
    }
    Object.defineProperty(TransformConstraintData4.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("BoneData not set.");
        else
          return this._target;
      },
      set: function(boneData) {
        this._target = boneData;
      },
      enumerable: false,
      configurable: true
    });
    return TransformConstraintData4;
  }(ConstraintData2)
);
var SkinEntry2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function SkinEntry3(slotIndex, name, attachment) {
      this.slotIndex = slotIndex;
      this.name = name;
      this.attachment = attachment;
    }
    return SkinEntry3;
  }()
);
var Skin3 = (
  /** @class */
  function() {
    function Skin4(name) {
      this.attachments = new Array();
      this.bones = Array();
      this.constraints = new Array();
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin4.prototype.setAttachment = function(slotIndex, name, attachment) {
      if (!attachment)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin4.prototype.addSkin = function(skin) {
      for (var i = 0; i < skin.bones.length; i++) {
        var bone = skin.bones[i];
        var contained = false;
        for (var ii = 0; ii < this.bones.length; ii++) {
          if (this.bones[ii] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i = 0; i < skin.constraints.length; i++) {
        var constraint = skin.constraints[i];
        var contained = false;
        for (var ii = 0; ii < this.constraints.length; ii++) {
          if (this.constraints[ii] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i = 0; i < attachments.length; i++) {
        var attachment = attachments[i];
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    };
    Skin4.prototype.copySkin = function(skin) {
      for (var i = 0; i < skin.bones.length; i++) {
        var bone = skin.bones[i];
        var contained = false;
        for (var ii = 0; ii < this.bones.length; ii++) {
          if (this.bones[ii] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i = 0; i < skin.constraints.length; i++) {
        var constraint = skin.constraints[i];
        var contained = false;
        for (var ii = 0; ii < this.constraints.length; ii++) {
          if (this.constraints[ii] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i = 0; i < attachments.length; i++) {
        var attachment = attachments[i];
        if (!attachment.attachment)
          continue;
        if (attachment.attachment instanceof MeshAttachment3) {
          attachment.attachment = attachment.attachment.newLinkedMesh();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        } else {
          attachment.attachment = attachment.attachment.copy();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }
    };
    Skin4.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin4.prototype.removeAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      if (dictionary)
        delete dictionary[name];
    };
    Skin4.prototype.getAttachments = function() {
      var entries = new Array();
      for (var i = 0; i < this.attachments.length; i++) {
        var slotAttachments = this.attachments[i];
        if (slotAttachments) {
          for (var name_1 in slotAttachments) {
            var attachment = slotAttachments[name_1];
            if (attachment)
              entries.push(new SkinEntry2(i, name_1, attachment));
          }
        }
      }
      return entries;
    };
    Skin4.prototype.getAttachmentsForSlot = function(slotIndex, attachments) {
      var slotAttachments = this.attachments[slotIndex];
      if (slotAttachments) {
        for (var name_2 in slotAttachments) {
          var attachment = slotAttachments[name_2];
          if (attachment)
            attachments.push(new SkinEntry2(slotIndex, name_2, attachment));
        }
      }
    };
    Skin4.prototype.clear = function() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    };
    Skin4.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i = 0; i < skeleton.slots.length; i++) {
        var slot = skeleton.slots[i];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin4;
  }()
);
var SkeletonBinary2 = (
  /** @class */
  function() {
    function SkeletonBinary3(attachmentLoader) {
      this.ver40 = false;
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonBinary3.prototype.readSkeletonData = function(binary) {
      var scale = this.scale;
      var skeletonData = new SkeletonData3();
      skeletonData.name = "";
      var input = new BinaryInput(binary);
      var lowHash = input.readInt32();
      var highHash = input.readInt32();
      skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
      skeletonData.version = input.readString();
      var verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        var error = "Spine 4.1 loader cant load version " + skeletonData.version + ". Please configure your pixi-spine bundle";
        console.error(error);
      }
      this.ver40 = verShort === "4.0";
      skeletonData.x = input.readFloat();
      skeletonData.y = input.readFloat();
      skeletonData.width = input.readFloat();
      skeletonData.height = input.readFloat();
      var nonessential = input.readBoolean();
      if (nonessential) {
        skeletonData.fps = input.readFloat();
        skeletonData.imagesPath = input.readString();
        skeletonData.audioPath = input.readString();
      }
      var n = 0;
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var str = input.readString();
        if (!str)
          throw new Error("String in string table must not be null.");
        input.strings.push(str);
      }
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var name_1 = input.readString();
        if (!name_1)
          throw new Error("Bone name must not be null.");
        var parent_1 = i == 0 ? null : skeletonData.bones[input.readInt(true)];
        var data = new BoneData3(i, name_1, parent_1);
        data.rotation = input.readFloat();
        data.x = input.readFloat() * scale;
        data.y = input.readFloat() * scale;
        data.scaleX = input.readFloat();
        data.scaleY = input.readFloat();
        data.shearX = input.readFloat();
        data.shearY = input.readFloat();
        data.length = input.readFloat() * scale;
        data.transformMode = input.readInt(true);
        data.skinRequired = input.readBoolean();
        if (nonessential)
          Color.rgba8888ToColor(data.color, input.readInt32());
        skeletonData.bones.push(data);
      }
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var slotName = input.readString();
        if (!slotName)
          throw new Error("Slot name must not be null.");
        var boneData = skeletonData.bones[input.readInt(true)];
        var data = new SlotData3(i, slotName, boneData);
        Color.rgba8888ToColor(data.color, input.readInt32());
        var darkColor = input.readInt32();
        if (darkColor != -1)
          Color.rgb888ToColor(data.darkColor = new Color(), darkColor);
        data.attachmentName = input.readStringRef();
        data.blendMode = input.readInt(true);
        skeletonData.slots.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var name_2 = input.readString();
        if (!name_2)
          throw new Error("IK constraint data name must not be null.");
        var data = new IkConstraintData3(name_2);
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        data.mix = input.readFloat();
        data.softness = input.readFloat() * scale;
        data.bendDirection = input.readByte();
        data.compress = input.readBoolean();
        data.stretch = input.readBoolean();
        data.uniform = input.readBoolean();
        skeletonData.ikConstraints.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var name_3 = input.readString();
        if (!name_3)
          throw new Error("Transform constraint data name must not be null.");
        var data = new TransformConstraintData3(name_3);
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        data.local = input.readBoolean();
        data.relative = input.readBoolean();
        data.offsetRotation = input.readFloat();
        data.offsetX = input.readFloat() * scale;
        data.offsetY = input.readFloat() * scale;
        data.offsetScaleX = input.readFloat();
        data.offsetScaleY = input.readFloat();
        data.offsetShearY = input.readFloat();
        data.mixRotate = input.readFloat();
        data.mixX = input.readFloat();
        data.mixY = input.readFloat();
        data.mixScaleX = input.readFloat();
        data.mixScaleY = input.readFloat();
        data.mixShearY = input.readFloat();
        skeletonData.transformConstraints.push(data);
      }
      n = input.readInt(true);
      for (var i = 0, nn = void 0; i < n; i++) {
        var name_4 = input.readString();
        if (!name_4)
          throw new Error("Path constraint data name must not be null.");
        var data = new PathConstraintData3(name_4);
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (var ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.slots[input.readInt(true)];
        data.positionMode = input.readInt(true);
        data.spacingMode = input.readInt(true);
        data.rotateMode = input.readInt(true);
        data.offsetRotation = input.readFloat();
        data.position = input.readFloat();
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = input.readFloat();
        if (data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed)
          data.spacing *= scale;
        data.mixRotate = input.readFloat();
        data.mixX = input.readFloat();
        data.mixY = input.readFloat();
        skeletonData.pathConstraints.push(data);
      }
      var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
      if (defaultSkin) {
        skeletonData.defaultSkin = defaultSkin;
        skeletonData.skins.push(defaultSkin);
      }
      {
        var i = skeletonData.skins.length;
        Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
        for (; i < n; i++) {
          var skin = this.readSkin(input, skeletonData, false, nonessential);
          if (!skin)
            throw new Error("readSkin() should not have returned null.");
          skeletonData.skins[i] = skin;
        }
      }
      n = this.linkedMeshes.length;
      for (var i = 0; i < n; i++) {
        var linkedMesh = this.linkedMeshes[i];
        var skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (!skin)
          throw new Error("Not skin found for linked mesh.");
        if (!linkedMesh.parent)
          throw new Error("Linked mesh parent must not be null");
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent_2)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var eventName = input.readStringRef();
        if (!eventName)
          throw new Error();
        var data = new EventData3(eventName);
        data.intValue = input.readInt(false);
        data.floatValue = input.readFloat();
        data.stringValue = input.readString();
        data.audioPath = input.readString();
        if (data.audioPath) {
          data.volume = input.readFloat();
          data.balance = input.readFloat();
        }
        skeletonData.events.push(data);
      }
      n = input.readInt(true);
      for (var i = 0; i < n; i++) {
        var animationName = input.readString();
        if (!animationName)
          throw new Error("Animatio name must not be null.");
        skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
      }
      return skeletonData;
    };
    SkeletonBinary3.prototype.readSkin = function(input, skeletonData, defaultSkin, nonessential) {
      var skin = null;
      var slotCount = 0;
      if (defaultSkin) {
        slotCount = input.readInt(true);
        if (slotCount == 0)
          return null;
        skin = new Skin3("default");
      } else {
        var skinName = input.readStringRef();
        if (!skinName)
          throw new Error("Skin name must not be null.");
        skin = new Skin3(skinName);
        skin.bones.length = input.readInt(true);
        for (var i = 0, n = skin.bones.length; i < n; i++)
          skin.bones[i] = skeletonData.bones[input.readInt(true)];
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
        for (var i = 0, n = input.readInt(true); i < n; i++)
          skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
        slotCount = input.readInt(true);
      }
      for (var i = 0; i < slotCount; i++) {
        var slotIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var name_5 = input.readStringRef();
          if (!name_5)
            throw new Error("Attachment name must not be null");
          var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_5, nonessential);
          if (attachment)
            skin.setAttachment(slotIndex, name_5, attachment);
        }
      }
      return skin;
    };
    SkeletonBinary3.prototype.readAttachment = function(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
      var scale = this.scale;
      var name = input.readStringRef();
      if (!name)
        name = attachmentName;
      switch (input.readByte()) {
        case AttachmentType.Region: {
          var path = input.readStringRef();
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y = input.readFloat();
          var scaleX = input.readFloat();
          var scaleY = input.readFloat();
          var width = input.readFloat();
          var height = input.readFloat();
          var color = input.readInt32();
          var sequence = this.readSequence(input);
          if (!path)
            path = name;
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
          if (!region)
            return null;
          region.path = path;
          region.x = x * scale;
          region.y = y * scale;
          region.scaleX = scaleX;
          region.scaleY = scaleY;
          region.rotation = rotation;
          region.width = width * scale;
          region.height = height * scale;
          Color.rgba8888ToColor(region.color, color);
          region.sequence = sequence;
          if (sequence == null)
            region.updateRegion();
          return region;
        }
        case AttachmentType.BoundingBox: {
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color = nonessential ? input.readInt32() : 0;
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          box.worldVerticesLength = vertexCount << 1;
          box.vertices = vertices.vertices;
          box.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(box.color, color);
          return box;
        }
        case AttachmentType.Mesh: {
          var path = input.readStringRef();
          var color = input.readInt32();
          var vertexCount = input.readInt(true);
          var uvs = this.readFloatArray(input, vertexCount << 1, 1);
          var triangles = this.readShortArray(input);
          var vertices = this.readVertices(input, vertexCount);
          var hullLength = input.readInt(true);
          var sequence = this.readSequence(input);
          var edges = [];
          var width = 0, height = 0;
          if (nonessential) {
            edges = this.readShortArray(input);
            width = input.readFloat();
            height = input.readFloat();
          }
          if (!path)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color);
          mesh.bones = vertices.bones;
          mesh.vertices = vertices.vertices;
          mesh.worldVerticesLength = vertexCount << 1;
          mesh.triangles = triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = hullLength << 1;
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.edges = edges;
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          return mesh;
        }
        case AttachmentType.LinkedMesh: {
          var path = input.readStringRef();
          var color = input.readInt32();
          var skinName = input.readStringRef();
          var parent_3 = input.readStringRef();
          var inheritTimelines = input.readBoolean();
          var sequence = this.readSequence(input);
          var width = 0, height = 0;
          if (nonessential) {
            width = input.readFloat();
            height = input.readFloat();
          }
          if (!path)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color);
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          this.linkedMeshes.push(new LinkedMesh$12(mesh, skinName, slotIndex, parent_3, inheritTimelines));
          return mesh;
        }
        case AttachmentType.Path: {
          var closed_1 = input.readBoolean();
          var constantSpeed = input.readBoolean();
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i = 0, n = lengths.length; i < n; i++)
            lengths[i] = input.readFloat() * scale;
          var color = nonessential ? input.readInt32() : 0;
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path)
            return null;
          path.closed = closed_1;
          path.constantSpeed = constantSpeed;
          path.worldVerticesLength = vertexCount << 1;
          path.vertices = vertices.vertices;
          path.bones = vertices.bones;
          path.lengths = lengths;
          if (nonessential)
            Color.rgba8888ToColor(path.color, color);
          return path;
        }
        case AttachmentType.Point: {
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y = input.readFloat();
          var color = nonessential ? input.readInt32() : 0;
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = x * scale;
          point.y = y * scale;
          point.rotation = rotation;
          if (nonessential)
            Color.rgba8888ToColor(point.color, color);
          return point;
        }
        case AttachmentType.Clipping: {
          var endSlotIndex = input.readInt(true);
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color = nonessential ? input.readInt32() : 0;
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          clip.endSlot = skeletonData.slots[endSlotIndex];
          clip.worldVerticesLength = vertexCount << 1;
          clip.vertices = vertices.vertices;
          clip.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(clip.color, color);
          return clip;
        }
      }
      return null;
    };
    SkeletonBinary3.prototype.readSequence = function(input) {
      if (this.ver40 || !input.readBoolean())
        return null;
      var sequence = new Sequence(input.readInt(true));
      sequence.start = input.readInt(true);
      sequence.digits = input.readInt(true);
      sequence.setupIndex = input.readInt(true);
      return sequence;
    };
    SkeletonBinary3.prototype.readDeformTimelineType = function(input) {
      if (this.ver40)
        return ATTACHMENT_DEFORM;
      return input.readByte();
    };
    SkeletonBinary3.prototype.readVertices = function(input, vertexCount) {
      var scale = this.scale;
      var verticesLength = vertexCount << 1;
      var vertices = new Vertices2();
      if (!input.readBoolean()) {
        vertices.vertices = this.readFloatArray(input, verticesLength, scale);
        return vertices;
      }
      var weights = new Array();
      var bonesArray = new Array();
      for (var i = 0; i < vertexCount; i++) {
        var boneCount = input.readInt(true);
        bonesArray.push(boneCount);
        for (var ii = 0; ii < boneCount; ii++) {
          bonesArray.push(input.readInt(true));
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat());
        }
      }
      vertices.vertices = Utils.toFloatArray(weights);
      vertices.bones = bonesArray;
      return vertices;
    };
    SkeletonBinary3.prototype.readFloatArray = function(input, n, scale) {
      var array = new Array(n);
      if (scale == 1) {
        for (var i = 0; i < n; i++)
          array[i] = input.readFloat();
      } else {
        for (var i = 0; i < n; i++)
          array[i] = input.readFloat() * scale;
      }
      return array;
    };
    SkeletonBinary3.prototype.readShortArray = function(input) {
      var n = input.readInt(true);
      var array = new Array(n);
      for (var i = 0; i < n; i++)
        array[i] = input.readShort();
      return array;
    };
    SkeletonBinary3.prototype.readAnimation = function(input, name, skeletonData) {
      input.readInt(true);
      var timelines = new Array();
      var scale = this.scale;
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var slotIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          var frameLast = frameCount - 1;
          switch (timelineType) {
            case SLOT_ATTACHMENT: {
              var timeline = new AttachmentTimeline3(frameCount, slotIndex);
              for (var frame = 0; frame < frameCount; frame++)
                timeline.setFrame(frame, input.readFloat(), input.readStringRef());
              timelines.push(timeline);
              break;
            }
            case SLOT_RGBA: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r = input.readUnsignedByte() / 255;
              var g = input.readUnsignedByte() / 255;
              var b = input.readUnsignedByte() / 255;
              var a = input.readUnsignedByte() / 255;
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, r, g, b, a);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat();
                var r2 = input.readUnsignedByte() / 255;
                var g2 = input.readUnsignedByte() / 255;
                var b2 = input.readUnsignedByte() / 255;
                var a2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);
                }
                time = time2;
                r = r2;
                g = g2;
                b = b2;
                a = a2;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGB: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r = input.readUnsignedByte() / 255;
              var g = input.readUnsignedByte() / 255;
              var b = input.readUnsignedByte() / 255;
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, r, g, b);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat();
                var r2 = input.readUnsignedByte() / 255;
                var g2 = input.readUnsignedByte() / 255;
                var b2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                }
                time = time2;
                r = r2;
                g = g2;
                b = b2;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGBA2: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r = input.readUnsignedByte() / 255;
              var g = input.readUnsignedByte() / 255;
              var b = input.readUnsignedByte() / 255;
              var a = input.readUnsignedByte() / 255;
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat();
                var nr = input.readUnsignedByte() / 255;
                var ng = input.readUnsignedByte() / 255;
                var nb = input.readUnsignedByte() / 255;
                var na = input.readUnsignedByte() / 255;
                var nr2 = input.readUnsignedByte() / 255;
                var ng2 = input.readUnsignedByte() / 255;
                var nb2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);
                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);
                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);
                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);
                }
                time = time2;
                r = nr;
                g = ng;
                b = nb;
                a = na;
                r2 = nr2;
                g2 = ng2;
                b2 = nb2;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGB2: {
              var bezierCount = input.readInt(true);
              var timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r = input.readUnsignedByte() / 255;
              var g = input.readUnsignedByte() / 255;
              var b = input.readUnsignedByte() / 255;
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, r, g, b, r2, g2, b2);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat();
                var nr = input.readUnsignedByte() / 255;
                var ng = input.readUnsignedByte() / 255;
                var nb = input.readUnsignedByte() / 255;
                var nr2 = input.readUnsignedByte() / 255;
                var ng2 = input.readUnsignedByte() / 255;
                var nb2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);
                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);
                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);
                }
                time = time2;
                r = nr;
                g = ng;
                b = nb;
                r2 = nr2;
                g2 = ng2;
                b2 = nb2;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_ALPHA: {
              var timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);
              var time = input.readFloat(), a = input.readUnsignedByte() / 255;
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, a);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat();
                var a2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);
                }
                time = time2;
                a = a2;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var boneIndex = input.readInt(true);
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var type = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);
          switch (type) {
            case BONE_ROTATE:
              timelines.push(readTimeline1$1(input, new RotateTimeline3(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_TRANSLATE:
              timelines.push(readTimeline2$1(input, new TranslateTimeline3(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEX:
              timelines.push(readTimeline1$1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEY:
              timelines.push(readTimeline1$1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_SCALE:
              timelines.push(readTimeline2$1(input, new ScaleTimeline3(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEX:
              timelines.push(readTimeline1$1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEY:
              timelines.push(readTimeline1$1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEAR:
              timelines.push(readTimeline2$1(input, new ShearTimeline3(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARX:
              timelines.push(readTimeline1$1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARY:
              timelines.push(readTimeline1$1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        var timeline = new IkConstraintTimeline3(frameCount, input.readInt(true), index);
        var time = input.readFloat(), mix = input.readFloat(), softness = input.readFloat() * scale;
        for (var frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());
          if (frame == frameLast)
            break;
          var time2 = input.readFloat(), mix2 = input.readFloat(), softness2 = input.readFloat() * scale;
          switch (input.readByte()) {
            case CURVE_STEPPED:
              timeline.setStepped(frame);
              break;
            case CURVE_BEZIER:
              setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);
              setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
        }
        timelines.push(timeline);
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        var timeline = new TransformConstraintTimeline3(frameCount, input.readInt(true), index);
        var time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(), mixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();
        for (var frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          if (frame == frameLast)
            break;
          var time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(), mixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();
          switch (input.readByte()) {
            case CURVE_STEPPED:
              timeline.setStepped(frame);
              break;
            case CURVE_BEZIER:
              setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
              setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
              setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
              setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
              setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixShearY = mixShearY2;
        }
        timelines.push(timeline);
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var index = input.readInt(true);
        var data = skeletonData.pathConstraints[index];
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          switch (input.readByte()) {
            case PATH_POSITION:
              timelines.push(readTimeline1$1(input, new PathConstraintPositionTimeline3(input.readInt(true), input.readInt(true), index), data.positionMode == PositionMode.Fixed ? scale : 1));
              break;
            case PATH_SPACING:
              timelines.push(readTimeline1$1(input, new PathConstraintSpacingTimeline3(input.readInt(true), input.readInt(true), index), data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed ? scale : 1));
              break;
            case PATH_MIX:
              var timeline = new PathConstraintMixTimeline3(input.readInt(true), input.readInt(true), index);
              var time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();
              for (var frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
                timeline.setFrame(frame, time, mixRotate, mixX, mixY);
                if (frame == frameLast)
                  break;
                var time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
              }
              timelines.push(timeline);
          }
        }
      }
      for (var i = 0, n = input.readInt(true); i < n; i++) {
        var skin = skeletonData.skins[input.readInt(true)];
        for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var slotIndex = input.readInt(true);
          for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
            var attachmentName = input.readStringRef();
            if (!attachmentName)
              throw new Error("attachmentName must not be null.");
            var attachment = skin.getAttachment(slotIndex, attachmentName);
            var timelineType = this.readDeformTimelineType(input);
            var frameCount = input.readInt(true);
            var frameLast = frameCount - 1;
            switch (timelineType) {
              case ATTACHMENT_DEFORM: {
                var vertexAttachment = attachment;
                var weighted = vertexAttachment.bones;
                var vertices = vertexAttachment.vertices;
                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                var bezierCount = input.readInt(true);
                var timeline = new DeformTimeline3(frameCount, bezierCount, slotIndex, vertexAttachment);
                var time = input.readFloat();
                for (var frame = 0, bezier = 0; ; frame++) {
                  var deform = void 0;
                  var end = input.readInt(true);
                  if (end == 0)
                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = Utils.newFloatArray(deformLength);
                    var start = input.readInt(true);
                    end += start;
                    if (scale == 1) {
                      for (var v = start; v < end; v++)
                        deform[v] = input.readFloat();
                    } else {
                      for (var v = start; v < end; v++)
                        deform[v] = input.readFloat() * scale;
                    }
                    if (!weighted) {
                      for (var v = 0, vn = deform.length; v < vn; v++)
                        deform[v] += vertices[v];
                    }
                  }
                  timeline.setFrame(frame, time, deform);
                  if (frame == frameLast)
                    break;
                  var time2 = input.readFloat();
                  switch (input.readByte()) {
                    case CURVE_STEPPED:
                      timeline.setStepped(frame);
                      break;
                    case CURVE_BEZIER:
                      setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);
                  }
                  time = time2;
                }
                timelines.push(timeline);
                break;
              }
              case ATTACHMENT_SEQUENCE: {
                var timeline = new SequenceTimeline(frameCount, slotIndex, attachment);
                for (var frame = 0; frame < frameCount; frame++) {
                  var time = input.readFloat();
                  var modeAndIndex = input.readInt32();
                  timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
                }
                timelines.push(timeline);
                break;
              }
            }
          }
        }
      }
      var drawOrderCount = input.readInt(true);
      if (drawOrderCount > 0) {
        var timeline = new DrawOrderTimeline3(drawOrderCount);
        var slotCount = skeletonData.slots.length;
        for (var i = 0; i < drawOrderCount; i++) {
          var time = input.readFloat();
          var offsetCount = input.readInt(true);
          var drawOrder = Utils.newArray(slotCount, 0);
          for (var ii = slotCount - 1; ii >= 0; ii--)
            drawOrder[ii] = -1;
          var unchanged = Utils.newArray(slotCount - offsetCount, 0);
          var originalIndex = 0, unchangedIndex = 0;
          for (var ii = 0; ii < offsetCount; ii++) {
            var slotIndex = input.readInt(true);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (var ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
          timeline.setFrame(i, time, drawOrder);
        }
        timelines.push(timeline);
      }
      var eventCount = input.readInt(true);
      if (eventCount > 0) {
        var timeline = new EventTimeline3(eventCount);
        for (var i = 0; i < eventCount; i++) {
          var time = input.readFloat();
          var eventData = skeletonData.events[input.readInt(true)];
          var event_1 = new Event3(time, eventData);
          event_1.intValue = input.readInt(false);
          event_1.floatValue = input.readFloat();
          event_1.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
          if (event_1.data.audioPath) {
            event_1.volume = input.readFloat();
            event_1.balance = input.readFloat();
          }
          timeline.setFrame(i, event_1);
        }
        timelines.push(timeline);
      }
      var duration = 0;
      for (var i = 0, n = timelines.length; i < n; i++)
        duration = Math.max(duration, timelines[i].getDuration());
      return new Animation3(name, timelines, duration);
    };
    SkeletonBinary3.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];
    return SkeletonBinary3;
  }()
);
var LinkedMesh$12 = (
  /** @class */
  /* @__PURE__ */ function() {
    function LinkedMesh4(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
    return LinkedMesh4;
  }()
);
var Vertices2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Vertices3(bones, vertices) {
      if (bones === void 0) {
        bones = null;
      }
      if (vertices === void 0) {
        vertices = null;
      }
      this.bones = bones;
      this.vertices = vertices;
    }
    return Vertices3;
  }()
);
function readTimeline1$1(input, timeline, scale) {
  var time = input.readFloat(), value = input.readFloat() * scale;
  for (var frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value);
    if (frame == frameLast)
      break;
    var time2 = input.readFloat(), value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2$1(input, timeline, scale) {
  var time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;
  for (var frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    if (frame == frameLast)
      break;
    var time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
var BONE_ROTATE = 0;
var BONE_TRANSLATE = 1;
var BONE_TRANSLATEX = 2;
var BONE_TRANSLATEY = 3;
var BONE_SCALE = 4;
var BONE_SCALEX = 5;
var BONE_SCALEY = 6;
var BONE_SHEAR = 7;
var BONE_SHEARX = 8;
var BONE_SHEARY = 9;
var SLOT_ATTACHMENT = 0;
var SLOT_RGBA = 1;
var SLOT_RGB = 2;
var SLOT_RGBA2 = 3;
var SLOT_RGB2 = 4;
var SLOT_ALPHA = 5;
var ATTACHMENT_DEFORM = 0;
var ATTACHMENT_SEQUENCE = 1;
var PATH_POSITION = 0;
var PATH_SPACING = 1;
var PATH_MIX = 2;
var CURVE_STEPPED = 1;
var CURVE_BEZIER = 2;
var SkeletonBounds3 = (
  /** @class */
  function(_super) {
    __extends4(SkeletonBounds4, _super);
    function SkeletonBounds4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds4;
  }(SkeletonBoundsBase)
);
var SkeletonJson3 = (
  /** @class */
  function() {
    function SkeletonJson4(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson4.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData3();
      var root = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root.skeleton;
      if (skeletonMap) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        var verShort = skeletonData.version.substr(0, 3);
        if (verShort !== "4.0" && verShort !== "4.1") {
          var error = "Spine 4.1 loader cant load version " + skeletonMap.spine + ". Please configure your pixi-spine bundle";
          console.error(error);
        }
        skeletonData.x = skeletonMap.x;
        skeletonData.y = skeletonMap.y;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root.bones) {
        for (var i = 0; i < root.bones.length; i++) {
          var boneMap = root.bones[i];
          var parent_1 = null;
          var parentName = getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data = new BoneData3(skeletonData.bones.length, boneMap.name, parent_1);
          data.length = getValue(boneMap, "length", 0) * scale;
          data.x = getValue(boneMap, "x", 0) * scale;
          data.y = getValue(boneMap, "y", 0) * scale;
          data.rotation = getValue(boneMap, "rotation", 0);
          data.scaleX = getValue(boneMap, "scaleX", 1);
          data.scaleY = getValue(boneMap, "scaleY", 1);
          data.shearX = getValue(boneMap, "shearX", 0);
          data.shearY = getValue(boneMap, "shearY", 0);
          data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, "transform", "Normal"));
          data.skinRequired = getValue(boneMap, "skin", false);
          var color = getValue(boneMap, "color", null);
          if (color)
            data.color.setFromString(color);
          skeletonData.bones.push(data);
        }
      }
      if (root.slots) {
        for (var i = 0; i < root.slots.length; i++) {
          var slotMap = root.slots[i];
          var boneData = skeletonData.findBone(slotMap.bone);
          if (!boneData)
            throw new Error("Couldn't find bone " + slotMap.bone + " for slot " + slotMap.name);
          var data = new SlotData3(skeletonData.slots.length, slotMap.name, boneData);
          var color = getValue(slotMap, "color", null);
          if (color)
            data.color.setFromString(color);
          var dark = getValue(slotMap, "dark", null);
          if (dark)
            data.darkColor = Color.fromString(dark);
          data.attachmentName = getValue(slotMap, "attachment", null);
          data.blendMode = SkeletonJson4.blendModeFromString(getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data);
        }
      }
      if (root.ik) {
        for (var i = 0; i < root.ik.length; i++) {
          var constraintMap = root.ik[i];
          var data = new IkConstraintData3(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii = 0; ii < constraintMap.bones.length; ii++) {
            var boneName = constraintMap.bones[ii];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data.bones.push(bone);
          }
          data.target = skeletonData.findBone(constraintMap.target);
          data.mix = getValue(constraintMap, "mix", 1);
          data.softness = getValue(constraintMap, "softness", 0) * scale;
          data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data.compress = getValue(constraintMap, "compress", false);
          data.stretch = getValue(constraintMap, "stretch", false);
          data.uniform = getValue(constraintMap, "uniform", false);
          skeletonData.ikConstraints.push(data);
        }
      }
      if (root.transform) {
        for (var i = 0; i < root.transform.length; i++) {
          var constraintMap = root.transform[i];
          var data = new TransformConstraintData3(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii = 0; ii < constraintMap.bones.length; ii++) {
            var boneName = constraintMap.bones[ii];
            var bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error("Couldn't find bone " + boneName + " for transform constraint " + constraintMap.name + ".");
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          var target = skeletonData.findBone(targetName);
          if (!target)
            throw new Error("Couldn't find target bone " + targetName + " for transform constraint " + constraintMap.name + ".");
          data.target = target;
          data.local = getValue(constraintMap, "local", false);
          data.relative = getValue(constraintMap, "relative", false);
          data.offsetRotation = getValue(constraintMap, "rotation", 0);
          data.offsetX = getValue(constraintMap, "x", 0) * scale;
          data.offsetY = getValue(constraintMap, "y", 0) * scale;
          data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
          data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
          data.offsetShearY = getValue(constraintMap, "shearY", 0);
          data.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data.mixX = getValue(constraintMap, "mixX", 1);
          data.mixY = getValue(constraintMap, "mixY", data.mixX);
          data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
          data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
          data.mixShearY = getValue(constraintMap, "mixShearY", 1);
          skeletonData.transformConstraints.push(data);
        }
      }
      if (root.path) {
        for (var i = 0; i < root.path.length; i++) {
          var constraintMap = root.path[i];
          var data = new PathConstraintData3(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii = 0; ii < constraintMap.bones.length; ii++) {
            var boneName = constraintMap.bones[ii];
            var bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error("Couldn't find bone " + boneName + " for path constraint " + constraintMap.name + ".");
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          var target = skeletonData.findSlot(targetName);
          if (!target)
            throw new Error("Couldn't find target slot " + targetName + " for path constraint " + constraintMap.name + ".");
          data.target = target;
          data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, "positionMode", "Percent"));
          data.spacingMode = Utils.enumValue(SpacingMode3, getValue(constraintMap, "spacingMode", "Length"));
          data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
          data.offsetRotation = getValue(constraintMap, "rotation", 0);
          data.position = getValue(constraintMap, "position", 0);
          if (data.positionMode == PositionMode.Fixed)
            data.position *= scale;
          data.spacing = getValue(constraintMap, "spacing", 0);
          if (data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed)
            data.spacing *= scale;
          data.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data.mixX = getValue(constraintMap, "mixX", 1);
          data.mixY = getValue(constraintMap, "mixY", data.mixX);
          skeletonData.pathConstraints.push(data);
        }
      }
      if (root.skins) {
        for (var i = 0; i < root.skins.length; i++) {
          var skinMap = root.skins[i];
          var skin = new Skin3(skinMap.name);
          if (skinMap.bones) {
            for (var ii = 0; ii < skinMap.bones.length; ii++) {
              var boneName = skinMap.bones[ii];
              var bone = skeletonData.findBone(boneName);
              if (!bone)
                throw new Error("Couldn't find bone " + boneName + " for skin " + skinMap.name + ".");
              skin.bones.push(bone);
            }
          }
          if (skinMap.ik) {
            for (var ii = 0; ii < skinMap.ik.length; ii++) {
              var constraintName = skinMap.ik[ii];
              var constraint = skeletonData.findIkConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find IK constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.transform) {
            for (var ii = 0; ii < skinMap.transform.length; ii++) {
              var constraintName = skinMap.transform[ii];
              var constraint = skeletonData.findTransformConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find transform constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.path) {
            for (var ii = 0; ii < skinMap.path.length; ii++) {
              var constraintName = skinMap.path[ii];
              var constraint = skeletonData.findPathConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find path constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          for (var slotName in skinMap.attachments) {
            var slot = skeletonData.findSlot(slotName);
            if (!slot)
              throw new Error("Couldn't find slot " + slotName + " for skin " + skinMap.name + ".");
            var slotMap = skinMap.attachments[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
              if (attachment)
                skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
        var linkedMesh = this.linkedMeshes[i];
        var skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (!skin)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent_2)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root.events) {
        for (var eventName in root.events) {
          var eventMap = root.events[eventName];
          var data = new EventData3(eventName);
          data.intValue = getValue(eventMap, "int", 0);
          data.floatValue = getValue(eventMap, "float", 0);
          data.stringValue = getValue(eventMap, "string", "");
          data.audioPath = getValue(eventMap, "audio", null);
          if (data.audioPath) {
            data.volume = getValue(eventMap, "volume", 1);
            data.balance = getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data);
        }
      }
      if (root.animations) {
        for (var animationName in root.animations) {
          var animationMap = root.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson4.prototype.readAttachment = function(map, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = getValue(map, "name", name);
      switch (getValue(map, "type", "region")) {
        case "region": {
          var path = getValue(map, "path", name);
          var sequence = this.readSequence(getValue(map, "sequence", null));
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
          if (!region)
            return null;
          region.path = path;
          region.x = getValue(map, "x", 0) * scale;
          region.y = getValue(map, "y", 0) * scale;
          region.scaleX = getValue(map, "scaleX", 1);
          region.scaleY = getValue(map, "scaleY", 1);
          region.rotation = getValue(map, "rotation", 0);
          region.width = map.width * scale;
          region.height = map.height * scale;
          region.sequence = sequence;
          var color = getValue(map, "color", null);
          if (color)
            region.color.setFromString(color);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          this.readVertices(map, box, map.vertexCount << 1);
          var color = getValue(map, "color", null);
          if (color)
            box.color.setFromString(color);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = getValue(map, "path", name);
          var sequence = this.readSequence(getValue(map, "sequence", null));
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          var color = getValue(map, "color", null);
          if (color)
            mesh.color.setFromString(color);
          mesh.width = getValue(map, "width", 0) * scale;
          mesh.height = getValue(map, "height", 0) * scale;
          mesh.sequence = sequence;
          var parent_3 = getValue(map, "parent", null);
          if (parent_3) {
            this.linkedMeshes.push(new LinkedMesh3(mesh, getValue(map, "skin", null), slotIndex, parent_3, getValue(map, "timelines", true)));
            return mesh;
          }
          var uvs = map.uvs;
          this.readVertices(map, mesh, uvs.length);
          mesh.triangles = map.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.edges = getValue(map, "edges", null);
          mesh.hullLength = getValue(map, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path)
            return null;
          path.closed = getValue(map, "closed", false);
          path.constantSpeed = getValue(map, "constantSpeed", true);
          var vertexCount = map.vertexCount;
          this.readVertices(map, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i = 0; i < map.lengths.length; i++)
            lengths[i] = map.lengths[i] * scale;
          path.lengths = lengths;
          var color = getValue(map, "color", null);
          if (color)
            path.color.setFromString(color);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = getValue(map, "x", 0) * scale;
          point.y = getValue(map, "y", 0) * scale;
          point.rotation = getValue(map, "rotation", 0);
          var color = getValue(map, "color", null);
          if (color)
            point.color.setFromString(color);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          var end = getValue(map, "end", null);
          if (end != null) {
            var slot = skeletonData.findSlot(end);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end);
            clip.endSlot = slot;
          }
          var vertexCount = map.vertexCount;
          this.readVertices(map, clip, vertexCount << 1);
          var color = getValue(map, "color", null);
          if (color)
            clip.color.setFromString(color);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson4.prototype.readSequence = function(map) {
      if (map == null)
        return null;
      var sequence = new Sequence(getValue(map, "count", 0));
      sequence.start = getValue(map, "start", 1);
      sequence.digits = getValue(map, "digits", 0);
      sequence.setupIndex = getValue(map, "setup", 0);
      return sequence;
    };
    SkeletonJson4.prototype.readVertices = function(map, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i = 0, n = vertices.length; i < n; i++)
            scaledVertices[i] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i = 0, n = vertices.length; i < n; ) {
        var boneCount = vertices[i++];
        bones.push(boneCount);
        for (var nn = i + boneCount * 4; i < nn; i += 4) {
          bones.push(vertices[i]);
          weights.push(vertices[i + 1] * scale);
          weights.push(vertices[i + 2] * scale);
          weights.push(vertices[i + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson4.prototype.readAnimation = function(map, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      if (map.slots) {
        for (var slotName in map.slots) {
          var slotMap = map.slots[slotName];
          var slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error("Slot not found: " + slotName);
          var slotIndex = slot.index;
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (!timelineMap)
              continue;
            var frames_1 = timelineMap.length;
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline3(frames_1, slotIndex);
              for (var frame = 0; frame < frames_1; frame++) {
                var keyMap = timelineMap[frame];
                timeline.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
              }
              timelines.push(timeline);
            } else if (timelineName == "rgba") {
              var timeline = new RGBATimeline(frames_1, frames_1 << 2, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color = Color.fromString(keyMap.color);
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);
                var nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.color);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                }
                time = time2;
                color = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "rgb") {
              var timeline = new RGBTimeline(frames_1, frames_1 * 3, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color = Color.fromString(keyMap.color);
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, color.r, color.g, color.b);
                var nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.color);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                }
                time = time2;
                color = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "alpha") {
              timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames_1, frames_1, slotIndex), 0, 1));
            } else if (timelineName == "rgba2") {
              var timeline = new RGBA2Timeline(frames_1, frames_1 * 7, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color = Color.fromString(keyMap.light);
              var color2 = Color.fromString(keyMap.dark);
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
                var nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.light);
                var newColor2 = Color.fromString(nextMap.dark);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
                }
                time = time2;
                color = newColor;
                color2 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "rgb2") {
              var timeline = new RGB2Timeline(frames_1, frames_1 * 6, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color = Color.fromString(keyMap.light);
              var color2 = Color.fromString(keyMap.dark);
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
                var nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.light);
                var newColor2 = Color.fromString(nextMap.dark);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
                }
                time = time2;
                color = newColor;
                color2 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      if (map.bones) {
        for (var boneName in map.bones) {
          var boneMap = map.bones[boneName];
          var bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error("Bone not found: " + boneName);
          var boneIndex = bone.index;
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            var frames_2 = timelineMap.length;
            if (frames_2 == 0)
              continue;
            if (timelineName === "rotate") {
              timelines.push(readTimeline1(timelineMap, new RotateTimeline3(frames_2, frames_2, boneIndex), 0, 1));
            } else if (timelineName === "translate") {
              var timeline = new TranslateTimeline3(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, scale));
            } else if (timelineName === "translatex") {
              var timeline = new TranslateXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
            } else if (timelineName === "translatey") {
              var timeline = new TranslateYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
            } else if (timelineName === "scale") {
              var timeline = new ScaleTimeline3(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 1, 1));
            } else if (timelineName === "scalex") {
              var timeline = new ScaleXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
            } else if (timelineName === "scaley") {
              var timeline = new ScaleYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
            } else if (timelineName === "shear") {
              var timeline = new ShearTimeline3(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, 1));
            } else if (timelineName === "shearx") {
              var timeline = new ShearXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
            } else if (timelineName === "sheary") {
              var timeline = new ShearYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
            }
          }
        }
      }
      if (map.ik) {
        for (var constraintName in map.ik) {
          var constraintMap = map.ik[constraintName];
          var keyMap = constraintMap[0];
          if (!keyMap)
            continue;
          var constraint = skeletonData.findIkConstraint(constraintName);
          if (!constraint)
            throw new Error("IK Constraint not found: " + constraintName);
          var constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var timeline = new IkConstraintTimeline3(constraintMap.length, constraintMap.length << 1, constraintIndex);
          var time = getValue(keyMap, "time", 0);
          var mix = getValue(keyMap, "mix", 1);
          var softness = getValue(keyMap, "softness", 0) * scale;
          for (var frame = 0, bezier = 0; ; frame++) {
            timeline.setFrame(frame, time, mix, softness, getValue(keyMap, "bendPositive", true) ? 1 : -1, getValue(keyMap, "compress", false), getValue(keyMap, "stretch", false));
            var nextMap = constraintMap[frame + 1];
            if (!nextMap) {
              timeline.shrink(bezier);
              break;
            }
            var time2 = getValue(nextMap, "time", 0);
            var mix2 = getValue(nextMap, "mix", 1);
            var softness2 = getValue(nextMap, "softness", 0) * scale;
            var curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);
            }
            time = time2;
            mix = mix2;
            softness = softness2;
            keyMap = nextMap;
          }
          timelines.push(timeline);
        }
      }
      if (map.transform) {
        for (var constraintName in map.transform) {
          var timelineMap = map.transform[constraintName];
          var keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          var constraint = skeletonData.findTransformConstraint(constraintName);
          if (!constraint)
            throw new Error("Transform constraint not found: " + constraintName);
          var constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var timeline = new TransformConstraintTimeline3(timelineMap.length, timelineMap.length * 6, constraintIndex);
          var time = getValue(keyMap, "time", 0);
          var mixRotate = getValue(keyMap, "mixRotate", 1);
          var mixX = getValue(keyMap, "mixX", 1);
          var mixY = getValue(keyMap, "mixY", mixX);
          var mixScaleX = getValue(keyMap, "mixScaleX", 1);
          var mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
          var mixShearY = getValue(keyMap, "mixShearY", 1);
          for (var frame = 0, bezier = 0; ; frame++) {
            timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
            var nextMap = timelineMap[frame + 1];
            if (!nextMap) {
              timeline.shrink(bezier);
              break;
            }
            var time2 = getValue(nextMap, "time", 0);
            var mixRotate2 = getValue(nextMap, "mixRotate", 1);
            var mixX2 = getValue(nextMap, "mixX", 1);
            var mixY2 = getValue(nextMap, "mixY", mixX2);
            var mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
            var mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
            var mixShearY2 = getValue(nextMap, "mixShearY", 1);
            var curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
              bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
            }
            time = time2;
            mixRotate = mixRotate2;
            mixX = mixX2;
            mixY = mixY2;
            mixScaleX = mixScaleX2;
            mixScaleY = mixScaleY2;
            mixScaleX = mixScaleX2;
            keyMap = nextMap;
          }
          timelines.push(timeline);
        }
      }
      if (map.path) {
        for (var constraintName in map.path) {
          var constraintMap = map.path[constraintName];
          var constraint = skeletonData.findPathConstraint(constraintName);
          if (!constraint)
            throw new Error("Path constraint not found: " + constraintName);
          var constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            var keyMap = timelineMap[0];
            if (!keyMap)
              continue;
            var frames_3 = timelineMap.length;
            if (timelineName === "position") {
              var timeline = new PathConstraintPositionTimeline3(frames_3, frames_3, constraintIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));
            } else if (timelineName === "spacing") {
              var timeline = new PathConstraintSpacingTimeline3(frames_3, frames_3, constraintIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode3.Length || constraint.spacingMode == SpacingMode3.Fixed ? scale : 1));
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline3(frames_3, frames_3 * 3, constraintIndex);
              var time = getValue(keyMap, "time", 0);
              var mixRotate = getValue(keyMap, "mixRotate", 1);
              var mixX = getValue(keyMap, "mixX", 1);
              var mixY = getValue(keyMap, "mixY", mixX);
              for (var frame = 0, bezier = 0; ; frame++) {
                timeline.setFrame(frame, time, mixRotate, mixX, mixY);
                var nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var mixRotate2 = getValue(nextMap, "mixRotate", 1);
                var mixX2 = getValue(nextMap, "mixX", 1);
                var mixY2 = getValue(nextMap, "mixY", mixX2);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                  bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      if (map.deform) {
        map.attachments = {};
        for (var deformName in map.deform) {
          var deformMap = map.deform[deformName];
          var outMap = map.attachments[deformName] = {};
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var outMap2 = outMap[slotName] = {};
            for (var innerMapName in slotMap) {
              outMap2[innerMapName] = {
                deform: slotMap[innerMapName]
              };
            }
          }
        }
      }
      if (map.attachments) {
        for (var attachmentsName in map.attachments) {
          var attachmentsMap = map.attachments[attachmentsName];
          var skin = skeletonData.findSkin(attachmentsName);
          if (skin == null) {
            if (settings.FAIL_ON_NON_EXISTING_SKIN) {
              throw new Error("Skin not found: " + attachmentsName);
            } else {
              continue;
            }
          }
          for (var slotMapName in attachmentsMap) {
            var slotMap = attachmentsMap[slotMapName];
            var slot = skeletonData.findSlot(slotMapName);
            if (!slot)
              throw new Error("Slot not found: " + slotMapName);
            var slotIndex = slot.index;
            for (var attachmentMapName in slotMap) {
              var attachmentMap = slotMap[attachmentMapName];
              var attachment = skin.getAttachment(slotIndex, attachmentMapName);
              for (var timelineMapName in attachmentMap) {
                var timelineMap = attachmentMap[timelineMapName];
                var keyMap = timelineMap[0];
                if (!keyMap)
                  continue;
                if (timelineMapName == "deform") {
                  var weighted = attachment.bones;
                  var vertices = attachment.vertices;
                  var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                  var timeline = new DeformTimeline3(timelineMap.length, timelineMap.length, slotIndex, attachment);
                  var time = getValue(keyMap, "time", 0);
                  for (var frame = 0, bezier = 0; ; frame++) {
                    var deform = void 0;
                    var verticesValue = getValue(keyMap, "vertices", null);
                    if (!verticesValue)
                      deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                    else {
                      deform = Utils.newFloatArray(deformLength);
                      var start = getValue(keyMap, "offset", 0);
                      Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                      if (scale != 1) {
                        for (var i = start, n = i + verticesValue.length; i < n; i++)
                          deform[i] *= scale;
                      }
                      if (!weighted) {
                        for (var i = 0; i < deformLength; i++)
                          deform[i] += vertices[i];
                      }
                    }
                    timeline.setFrame(frame, time, deform);
                    var nextMap = timelineMap[frame + 1];
                    if (!nextMap) {
                      timeline.shrink(bezier);
                      break;
                    }
                    var time2 = getValue(nextMap, "time", 0);
                    var curve = keyMap.curve;
                    if (curve)
                      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);
                    time = time2;
                    keyMap = nextMap;
                  }
                  timelines.push(timeline);
                } else if (timelineMapName == "sequence") {
                  var timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);
                  var lastDelay = 0;
                  for (var frame = 0; frame < timelineMap.length; frame++) {
                    var delay = getValue(keyMap, "delay", lastDelay);
                    var time = getValue(keyMap, "time", 0);
                    var mode = SequenceMode[getValue(keyMap, "mode", "hold")];
                    var index = getValue(keyMap, "index", 0);
                    timeline.setFrame(frame, time, mode, index, delay);
                    lastDelay = delay;
                    keyMap = timelineMap[frame + 1];
                  }
                  timelines.push(timeline);
                }
              }
            }
          }
        }
      }
      if (map.drawOrder) {
        var timeline = new DrawOrderTimeline3(map.drawOrder.length);
        var slotCount = skeletonData.slots.length;
        var frame = 0;
        for (var i = 0; i < map.drawOrder.length; i++, frame++) {
          var drawOrderMap = map.drawOrder[i];
          var drawOrder = null;
          var offsets = getValue(drawOrderMap, "offsets", null);
          if (offsets) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var ii = 0; ii < offsets.length; ii++) {
              var offsetMap = offsets[ii];
              var slot = skeletonData.findSlot(offsetMap.slot);
              if (!slot)
                throw new Error("Slot not found: " + slot);
              var slotIndex = slot.index;
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var ii = slotCount - 1; ii >= 0; ii--)
              if (drawOrder[ii] == -1)
                drawOrder[ii] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
        }
        timelines.push(timeline);
      }
      if (map.events) {
        var timeline = new EventTimeline3(map.events.length);
        var frame = 0;
        for (var i = 0; i < map.events.length; i++, frame++) {
          var eventMap = map.events[i];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (!eventData)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event3(Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
          event_1.intValue = getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath) {
            event_1.volume = getValue(eventMap, "volume", 1);
            event_1.balance = getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frame, event_1);
        }
        timelines.push(timeline);
      }
      var duration = 0;
      for (var i = 0, n = timelines.length; i < n; i++)
        duration = Math.max(duration, timelines[i].getDuration());
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation3(name, timelines, duration));
    };
    SkeletonJson4.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES.NORMAL;
      if (str == "additive")
        return BLEND_MODES.ADD;
      if (str == "multiply")
        return BLEND_MODES.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    return SkeletonJson4;
  }()
);
var LinkedMesh3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function LinkedMesh4(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
    return LinkedMesh4;
  }()
);
function readTimeline1(keys, timeline, defaultValue, scale) {
  var keyMap = keys[0];
  var time = getValue(keyMap, "time", 0);
  var value = getValue(keyMap, "value", defaultValue) * scale;
  var bezier = 0;
  for (var frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value);
    var nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    var time2 = getValue(nextMap, "time", 0);
    var value2 = getValue(nextMap, "value", defaultValue) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {
  var keyMap = keys[0];
  var time = getValue(keyMap, "time", 0);
  var value1 = getValue(keyMap, name1, defaultValue) * scale;
  var value2 = getValue(keyMap, name2, defaultValue) * scale;
  var bezier = 0;
  for (var frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    var nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    var time2 = getValue(nextMap, "time", 0);
    var nvalue1 = getValue(nextMap, name1, defaultValue) * scale;
    var nvalue2 = getValue(nextMap, name2, defaultValue) * scale;
    var curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame);
    return bezier;
  }
  var i = value << 2;
  var cx1 = curve[i];
  var cy1 = curve[i + 1] * scale;
  var cx2 = curve[i + 2];
  var cy2 = curve[i + 3] * scale;
  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map, property, defaultValue) {
  return map[property] !== void 0 ? map[property] : defaultValue;
}
var Spine3 = (
  /** @class */
  function(_super) {
    __extends4(Spine5, _super);
    function Spine5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine5.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton3(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData3(spineData);
      this.state = new AnimationState3(this.stateData);
    };
    return Spine5;
  }(SpineBase)
);

// node_modules/@pixi-spine/loader-uni/lib/loader-uni.es.js
var extendStatics5 = function(d, b) {
  extendStatics5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics5(d, b);
};
function __extends5(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics5(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var SPINE_VERSION;
(function(SPINE_VERSION2) {
  SPINE_VERSION2[SPINE_VERSION2["UNKNOWN"] = 0] = "UNKNOWN";
  SPINE_VERSION2[SPINE_VERSION2["VER37"] = 37] = "VER37";
  SPINE_VERSION2[SPINE_VERSION2["VER38"] = 38] = "VER38";
  SPINE_VERSION2[SPINE_VERSION2["VER40"] = 40] = "VER40";
  SPINE_VERSION2[SPINE_VERSION2["VER41"] = 41] = "VER41";
})(SPINE_VERSION || (SPINE_VERSION = {}));
function detectSpineVersion(version) {
  var ver3 = version.substr(0, 3);
  var verNum = Math.floor(+ver3 * 10 + 1e-3);
  if (ver3 === "3.7") {
    return SPINE_VERSION.VER37;
  }
  if (ver3 === "3.8") {
    return SPINE_VERSION.VER38;
  }
  if (ver3 === "4.0") {
    return SPINE_VERSION.VER40;
  }
  if (ver3 === "4.1") {
    return SPINE_VERSION.VER41;
  }
  if (verNum < SPINE_VERSION.VER37) {
    return SPINE_VERSION.VER37;
  }
  return SPINE_VERSION.UNKNOWN;
}
var UniBinaryParser = (
  /** @class */
  function() {
    function UniBinaryParser2() {
      this.scale = 1;
    }
    UniBinaryParser2.prototype.readSkeletonData = function(atlas, dataToParse) {
      var parser = null;
      var version = this.readVersionOldFormat(dataToParse);
      var ver = detectSpineVersion(version);
      if (ver === SPINE_VERSION.VER38) {
        parser = new SkeletonBinary(new AtlasAttachmentLoader(atlas));
      }
      version = this.readVersionNewFormat(dataToParse);
      ver = detectSpineVersion(version);
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        parser = new SkeletonBinary2(new AtlasAttachmentLoader3(atlas));
      }
      if (!parser) {
        var error = "Unsupported version of spine model " + version + ", please update pixi-spine";
        console.error(error);
      }
      parser.scale = this.scale;
      return parser.readSkeletonData(dataToParse);
    };
    UniBinaryParser2.prototype.readVersionOldFormat = function(dataToParse) {
      var input = new BinaryInput(dataToParse);
      var version;
      try {
        input.readString();
        version = input.readString();
      } catch (e) {
        version = "";
      }
      return version || "";
    };
    UniBinaryParser2.prototype.readVersionNewFormat = function(dataToParse) {
      var input = new BinaryInput(dataToParse);
      input.readInt32();
      input.readInt32();
      var version;
      try {
        version = input.readString();
      } catch (e) {
        version = "";
      }
      return version || "";
    };
    return UniBinaryParser2;
  }()
);
var UniJsonParser = (
  /** @class */
  function() {
    function UniJsonParser2() {
      this.scale = 1;
    }
    UniJsonParser2.prototype.readSkeletonData = function(atlas, dataToParse) {
      var version = dataToParse.skeleton.spine;
      var ver = detectSpineVersion(version);
      var parser = null;
      if (ver === SPINE_VERSION.VER37) {
        parser = new SkeletonJson2(new AtlasAttachmentLoader2(atlas));
      }
      if (ver === SPINE_VERSION.VER38) {
        parser = new SkeletonJson(new AtlasAttachmentLoader(atlas));
      }
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        parser = new SkeletonJson3(new AtlasAttachmentLoader3(atlas));
      }
      if (!parser) {
        var error = "Unsupported version of spine model " + version + ", please update pixi-spine";
        console.error(error);
      }
      parser.scale = this.scale;
      return parser.readSkeletonData(dataToParse);
    };
    return UniJsonParser2;
  }()
);
var SpineParser = (
  /** @class */
  function(_super) {
    __extends5(SpineParser2, _super);
    function SpineParser2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SpineParser2.prototype.createBinaryParser = function() {
      return new UniBinaryParser();
    };
    SpineParser2.prototype.createJsonParser = function() {
      return new UniJsonParser();
    };
    SpineParser2.prototype.parseData = function(resource, parser, atlas, dataToParse) {
      var parserCast = parser;
      resource.spineData = parserCast.readSkeletonData(atlas, dataToParse);
      resource.spineAtlas = atlas;
    };
    SpineParser2.registerLoaderPlugin = function() {
      Loader.registerPlugin(SpineParser2);
    };
    SpineParser2.use = new SpineParser2().genMiddleware().use;
    return SpineParser2;
  }(AbstractSpineParser)
);
var Spine4 = (
  /** @class */
  function(_super) {
    __extends5(Spine5, _super);
    function Spine5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine5.prototype.createSkeleton = function(spineData) {
      var ver = detectSpineVersion(spineData.version);
      var spine = null;
      if (ver === SPINE_VERSION.VER37) {
        spine = runtime_3_7_es_exports;
      }
      if (ver === SPINE_VERSION.VER38) {
        spine = runtime_3_8_es_exports;
      }
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        spine = runtime_4_1_es_exports;
      }
      if (!spine) {
        var error = "Cant detect version of spine model " + spineData.version;
        console.error(error);
      }
      this.skeleton = new spine.Skeleton(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new spine.AnimationStateData(spineData);
      this.state = new spine.AnimationState(this.stateData);
    };
    return Spine5;
  }(SpineBase)
);

// node_modules/pixi-spine/lib/all.es.js
SpineParser.registerLoaderPlugin();
export {
  AttachmentType,
  BinaryInput,
  Color,
  DebugUtils,
  IntSet,
  Interpolation,
  MathUtils,
  MixBlend,
  MixDirection,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RotateMode,
  SkeletonBounds3 as SkeletonBounds,
  SkeletonBoundsBase,
  Spine4 as Spine,
  SpineBase,
  SpineDebugRenderer,
  SpineMesh,
  SpineParser,
  SpineSprite,
  StringSet,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  TimeKeeper,
  TransformMode,
  Utils,
  Vector2,
  WindowedMean,
  filterFromString,
  settings,
  wrapFromString
};
/*! Bundled license information:

@pixi-spine/base/lib/base.es.js:
  (*!
   * @pixi-spine/base - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:29 UTC
   *
   * @pixi-spine/base is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi-spine/loader-base/lib/loader-base.es.js:
  (*!
   * @pixi-spine/loader-base - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:32 UTC
   *
   * @pixi-spine/loader-base is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)

@pixi-spine/runtime-3.8/lib/runtime-3.8.es.js:
  (*!
   * @pixi-spine/runtime-3.8 - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:32 UTC
   *
   * @pixi-spine/runtime-3.8 is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi-spine/runtime-3.7/lib/runtime-3.7.es.js:
  (*!
   * @pixi-spine/runtime-3.7 - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:32 UTC
   *
   * @pixi-spine/runtime-3.7 is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi-spine/runtime-4.1/lib/runtime-4.1.es.js:
  (*!
   * @pixi-spine/runtime-4.1 - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:32 UTC
   *
   * @pixi-spine/runtime-4.1 is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi-spine/loader-uni/lib/loader-uni.es.js:
  (*!
   * @pixi-spine/loader-uni - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:38 UTC
   *
   * @pixi-spine/loader-uni is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Mat Groves, All Rights Reserved
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

pixi-spine/lib/all.es.js:
  (*!
   * pixi-spine - v3.1.2
   * Compiled Tue, 10 Jan 2023 14:17:40 UTC
   *
   * pixi-spine is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
   *)
*/
//# sourceMappingURL=pixi-spine.js.map
