{
  "version": 3,
  "sources": ["../../@pixi-spine/base/src/core/AttachmentType.ts", "../../@pixi-spine/base/src/core/BinaryInput.ts", "../../@pixi-spine/base/src/core/IAnimation.ts", "../../@pixi-spine/base/src/core/IConstraint.ts", "../../@pixi-spine/base/src/core/ISkeleton.ts", "../../common/temp/node_modules/.pnpm/registry.npmjs.org/tslib/2.2.0/node_modules/tslib/tslib.es6.js", "../../@pixi-spine/base/src/core/TextureRegion.ts", "../../@pixi-spine/base/src/core/TextureAtlas.ts", "../../@pixi-spine/base/src/core/Utils.ts", "../../@pixi-spine/base/src/core/SkeletonBoundsBase.ts", "../../@pixi-spine/base/src/settings.ts", "../../@pixi-spine/base/src/SpineBase.ts", "../../@pixi-spine/base/src/SpineDebugRenderer.ts", "../../@pixi-spine/loader-base/src/loaders.ts", "../../common/temp/node_modules/.pnpm/registry.npmjs.org/tslib/2.2.0/node_modules/tslib/tslib.es6.js", "../../@pixi-spine/runtime-3.8/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/Slot.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/vertexeffects/JitterEffect.ts", "../../@pixi-spine/runtime-3.8/src/core/vertexeffects/SwirlEffect.ts", "../../@pixi-spine/runtime-3.8/src/core/Animation.ts", "../../@pixi-spine/runtime-3.8/src/core/AnimationState.ts", "../../@pixi-spine/runtime-3.8/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-3.8/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-3.8/src/core/Bone.ts", "../../@pixi-spine/runtime-3.8/src/core/BoneData.ts", "../../@pixi-spine/runtime-3.8/src/core/Constraint.ts", "../../@pixi-spine/runtime-3.8/src/core/Event.ts", "../../@pixi-spine/runtime-3.8/src/core/EventData.ts", "../../@pixi-spine/runtime-3.8/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/Skeleton.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-3.8/src/core/SlotData.ts", "../../@pixi-spine/runtime-3.8/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/Skin.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonBinary.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-3.8/src/Spine.ts", "../../common/temp/node_modules/.pnpm/registry.npmjs.org/tslib/2.2.0/node_modules/tslib/tslib.es6.js", "../../@pixi-spine/runtime-3.7/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/Slot.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/vertexeffects/JitterEffect.ts", "../../@pixi-spine/runtime-3.7/src/core/vertexeffects/SwirlEffect.ts", "../../@pixi-spine/runtime-3.7/src/core/Animation.ts", "../../@pixi-spine/runtime-3.7/src/core/AnimationState.ts", "../../@pixi-spine/runtime-3.7/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-3.7/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-3.7/src/core/Bone.ts", "../../@pixi-spine/runtime-3.7/src/core/BoneData.ts", "../../@pixi-spine/runtime-3.7/src/core/Event.ts", "../../@pixi-spine/runtime-3.7/src/core/EventData.ts", "../../@pixi-spine/runtime-3.7/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/Skeleton.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-3.7/src/core/SlotData.ts", "../../@pixi-spine/runtime-3.7/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/Skin.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-3.7/src/Spine.ts", "../../common/temp/node_modules/.pnpm/registry.npmjs.org/tslib/2.2.0/node_modules/tslib/tslib.es6.js", "../../@pixi-spine/runtime-4.1/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/Sequence.ts", "../../@pixi-spine/runtime-4.1/src/core/Animation.ts", "../../@pixi-spine/runtime-4.1/src/core/AnimationState.ts", "../../@pixi-spine/runtime-4.1/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-4.1/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-4.1/src/core/Bone.ts", "../../@pixi-spine/runtime-4.1/src/core/BoneData.ts", "../../@pixi-spine/runtime-4.1/src/core/ConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/Event.ts", "../../@pixi-spine/runtime-4.1/src/core/EventData.ts", "../../@pixi-spine/runtime-4.1/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/Slot.ts", "../../@pixi-spine/runtime-4.1/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/Skeleton.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-4.1/src/core/SlotData.ts", "../../@pixi-spine/runtime-4.1/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/Skin.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonBinary.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-4.1/src/Spine.ts", "../../common/temp/node_modules/.pnpm/registry.npmjs.org/tslib/2.2.0/node_modules/tslib/tslib.es6.js", "../../@pixi-spine/loader-uni/src/versions.ts", "../../@pixi-spine/loader-uni/src/SpineLoader.ts", "../../@pixi-spine/loader-uni/src/Spine.ts", "../../pixi-spine/src/index.ts"],
  "sourcesContent": ["\r\n/**\r\n * @public\r\n */\r\nexport enum AttachmentType {\r\n    Region, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping\r\n}\r\n", "/**\r\n * @public\r\n */\r\nexport class BinaryInput {\r\n    constructor (data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {\r\n    }\r\n\r\n    readByte (): number {\r\n        return this.buffer.getInt8(this.index++);\r\n    }\r\n\r\n    readUnsignedByte (): number {\r\n        return this.buffer.getUint8(this.index++);\r\n    }\r\n\r\n    readShort (): number {\r\n        let value = this.buffer.getInt16(this.index);\r\n        this.index += 2;\r\n        return value;\r\n    }\r\n\r\n    readInt32 (): number {\r\n        let value = this.buffer.getInt32(this.index)\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readInt (optimizePositive: boolean) {\r\n        let b = this.readByte();\r\n        let result = b & 0x7F;\r\n        if ((b & 0x80) != 0) {\r\n            b = this.readByte();\r\n            result |= (b & 0x7F) << 7;\r\n            if ((b & 0x80) != 0) {\r\n                b = this.readByte();\r\n                result |= (b & 0x7F) << 14;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 21;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 28;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n    }\r\n\r\n    readStringRef (): string | null {\r\n        let index = this.readInt(true);\r\n        return index == 0 ? null : this.strings[index - 1];\r\n    }\r\n\r\n    readString (): string | null {\r\n        let byteCount = this.readInt(true);\r\n        switch (byteCount) {\r\n            case 0:\r\n                return null;\r\n            case 1:\r\n                return \"\";\r\n        }\r\n        byteCount--;\r\n        let chars = \"\";\r\n        for (let i = 0; i < byteCount;) {\r\n            let b = this.readUnsignedByte();\r\n            switch (b >> 4) {\r\n                case 12:\r\n                case 13:\r\n                    chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                    i += 2;\r\n                    break;\r\n                case 14:\r\n                    chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                    i += 3;\r\n                    break;\r\n                default:\r\n                    chars += String.fromCharCode(b);\r\n                    i++;\r\n            }\r\n        }\r\n        return chars;\r\n    }\r\n\r\n    readFloat (): number {\r\n        let value = this.buffer.getFloat32(this.index);\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readBoolean (): boolean {\r\n        return this.readByte() != 0;\r\n    }\r\n}\r\n", "import {ISkeleton, ISkeletonData} from './ISkeleton';\r\nimport type {Map} from './Utils';\r\n\r\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixBlend {\r\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\r\n     * value is set. */\r\n    setup,\r\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\r\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\r\n     * AttachmentTimeline, use the setup value before the first key.\r\n     *\r\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\r\n    first,\r\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\r\n     * kept until the first key).\r\n     *\r\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\r\n    replace,\r\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\r\n     * (the current value is kept until the first key).\r\n     *\r\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\r\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\r\n     * the property values will increase continually. */\r\n    add\r\n}\r\n\r\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\r\n * mixing in toward 1 (the timeline's value).\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixDirection {\r\n    mixIn, mixOut\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\r\n    name: string;\r\n    timelines: Timeline[];\r\n    duration: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\n export interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\r\n    data: AnimationStateData;\r\n    tracks: ITrackEntry[];\r\n    listeners: IAnimationStateListener[];\r\n    timeScale: number;\r\n\r\n    update(dt: number): void;\r\n    apply(skeleton: ISkeleton): boolean;\r\n\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\r\n    addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\r\n    setEmptyAnimation (trackIndex: number, mixDuration: number): ITrackEntry;\r\n    setEmptyAnimations (mixDuration: number): void;\r\n    hasAnimation(animationName: string): boolean;\r\n    addListener (listener: IAnimationStateListener): void;\r\n    removeListener (listener: IAnimationStateListener): void;\r\n    clearListeners (): void;\r\n    clearTracks (): void;\r\n    clearTrack (index: number): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\n export interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\r\n    skeletonData: SkeletonData;\r\n    animationToMixTime: Map<number>;\r\n    defaultMix: number;\r\n    setMix (fromName: string, toName: string, duration: number): void;\r\n    setMixWith (from: Animation, to: Animation, duration: number): void;\r\n    getMix (from: Animation, to: Animation): number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\n export interface IAnimationStateListener {\r\n    start? (entry: ITrackEntry): void;\r\n    interrupt? (entry: ITrackEntry): void;\r\n    end? (entry: ITrackEntry): void;\r\n    dispose? (entry: ITrackEntry): void;\r\n    complete? (entry: ITrackEntry): void;\r\n    event? (entry: ITrackEntry, event: IEvent): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITimeline {\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\n export interface ITrackEntry {\r\n    trackIndex: number;\r\n    loop: boolean;\r\n    animationEnd: number;\r\n    listener: IAnimationStateListener;\r\n\r\n    delay: number; trackTime: number; trackLast: number; nextTrackLast: number; trackEnd: number; timeScale: number;\r\n    alpha: number; mixTime: number; mixDuration: number; interruptAlpha: number; totalAlpha: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IEventData {\r\n    name: string;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IEvent {\r\n    time: number;\r\n    data: IEventData;\r\n}\r\n", "\r\n// These enums were moved from PathConstraintData.ts of spine 3.7, 3.8 and 4.0\r\n\r\n/** Controls how the first bone is positioned along the path.\r\n *\r\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum PositionMode {\r\n    Fixed, Percent\r\n}\r\n\r\n/** Controls how bones are rotated, translated, and scaled to match the path.\r\n *\r\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum RotateMode {\r\n    Tangent, Chain, ChainScale\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IConstraintData {\r\n    name: string;\r\n    order: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IIkConstraint {\r\n    data: IIkConstraintData;\r\n    /** -1 | 0 | 1 */\r\n    bendDirection: number;\r\n    compress: boolean;\r\n    stretch: boolean;\r\n\r\n    /** A percentage (0-1) */\r\n    mix: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IIkConstraintData extends IConstraintData {\r\n    /** -1 | 0 | 1 */\r\n    bendDirection: number;\r\n    compress: boolean;\r\n    stretch: boolean;\r\n    uniform: boolean;\r\n\r\n    /** A percentage (0-1) */\r\n    mix: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IPathConstraint {\r\n    data: IPathConstraintData;\r\n    position: number;\r\n    spacing: number;\r\n\r\n    spaces: number[];\r\n    positions: number[];\r\n    world: number[];\r\n    curves: number[];\r\n    lengths: number[];\r\n    segments: number[];\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IPathConstraintData extends IConstraintData {\r\n    positionMode: PositionMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number;\r\n    spacing: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITransformConstraint {\r\n    data: ITransformConstraintData;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITransformConstraintData extends IConstraintData {\r\n    offsetRotation: number;\r\n    offsetX: number;\r\n    offsetY: number;\r\n    offsetScaleX: number;\r\n    offsetScaleY: number;\r\n    offsetShearY: number;\r\n    relative: boolean;\r\n    local: boolean;\r\n}\r\n", "import {AttachmentType} from './AttachmentType';\r\nimport {IAnimation, IEventData} from \"./IAnimation\";\r\nimport {IIkConstraintData, IPathConstraintData, ITransformConstraintData} from './IConstraint';\r\nimport type {Color, Vector2, Map} from './Utils';\r\nimport type {TextureRegion} from './TextureRegion';\r\n\r\nimport type {Matrix} from '@pixi/math';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n// This enum was moved from BoneData.ts of spine 3.7, 3.8 and 4.0\r\n\r\n/** Determines how a bone inherits world transforms from parent bones.\r\n * @public\r\n * */\r\n export enum TransformMode {\r\n    Normal,\r\n    OnlyTranslation,\r\n    NoRotationOrReflection,\r\n    NoScale,\r\n    NoScaleOrReflection\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IBone {\r\n    data: IBoneData;\r\n    matrix: Matrix;\r\n    active:boolean;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkin {\r\n    name: string;\r\n    attachments: Array<Map<IAttachment>>;\r\n\r\n    getAttachment (slotIndex: number, name: string): IAttachment | null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n    readonly sequence?: ISequence;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IHasTextureRegion {\r\n    /** The name used to find the {@link #region()}. */\r\n    path: string;\r\n\r\n    /** The region used to draw the attachment. After setting the region or if the region's properties are changed,\r\n     * {@link #updateRegion()} must be called. */\r\n    region: TextureRegion | null;\r\n\r\n    /** Updates any values the attachment calculates using the {@link #getRegion()}. Must be called after setting the\r\n     * {@link #getRegion()} or if the region's properties are changed. */\r\n    // updateRegion (): void;\r\n\r\n    /** The color to tint the attachment. */\r\n    color: Color;\r\n\r\n    readonly sequence: ISequence | null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISequence {\r\n    id: number;\r\n    regions: TextureRegion[];\r\n    apply (slot: ISlot, attachment: IHasTextureRegion): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IVertexAttachment<Slot extends ISlot = ISlot> extends IAttachment {\r\n    id: number;\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>): void;\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number): void;\r\n    worldVerticesLength: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IClippingAttachment extends IVertexAttachment {\r\n    endSlot?: ISlotData;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IRegionAttachment extends IAttachment {\r\n    region: TextureRegion;\r\n    color: Color;\r\n    x, y, scaleX, scaleY, rotation, width, height: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IMeshAttachment extends IVertexAttachment {\r\n    region: TextureRegion;\r\n    color: Color;\r\n    regionUVs: Float32Array,\r\n    triangles: number[],\r\n    hullLength:number,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: IBoneData;\r\n    color: Color;\r\n    darkColor: Color;\r\n    attachmentName: string;\r\n    blendMode: BLEND_MODES;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IBoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: IBoneData;\r\n    length: number;\r\n    x: number;\r\n    y: number;\r\n    rotation: number;\r\n    scaleX: number;\r\n    scaleY: number;\r\n    shearX: number;\r\n    shearY: number;\r\n    transformMode: TransformMode;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISlot {\r\n    getAttachment(): IAttachment;\r\n    data: ISlotData;\r\n    color: Color;\r\n    darkColor: Color;\r\n    blendMode: number;\r\n    bone: IBone;\r\n\r\n    sprites?: any;\r\n    currentSprite?: any;\r\n    currentSpriteName?: string;\r\n\r\n    meshes?: any;\r\n    currentMesh?: any;\r\n    currentMeshName?: string;\r\n    currentMeshId?: number;\r\n\r\n    currentGraphics?: any;\r\n    clippingContainer?: any;\r\n\r\n    hackRegion?: TextureRegion;\r\n    hackAttachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeleton<SkeletonData extends ISkeletonData = ISkeletonData,\r\n                           Bone extends IBone = IBone,\r\n                           Slot extends ISlot = ISlot,\r\n                           Skin extends ISkin = ISkin> {\r\n    bones: Bone[]\r\n    slots: Slot[]\r\n    drawOrder: Slot[]\r\n    skin: Skin;\r\n    data: SkeletonData;\r\n    x: number; // added for debug purposes\r\n    y: number; // added for debug purposes\r\n    updateWorldTransform (): void;\r\n    setToSetupPose (): void;\r\n    findSlotIndex (slotName: string): number;\r\n    getAttachmentByName (slotName: string, attachmentName: string): IAttachment;\r\n\r\n    setBonesToSetupPose (): void;\r\n    setSlotsToSetupPose (): void;\r\n    findBone (boneName: string): Bone;\r\n    findSlot (slotName: string): Slot;\r\n    findBoneIndex (boneName: string): number;\r\n    findSlotIndex (slotName: string): number;\r\n    setSkinByName (skinName: string): void;\r\n    setAttachment (slotName: string, attachmentName: string): void;\r\n    getBounds (offset: Vector2, size: Vector2, temp: Array<number>): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeletonParser {\r\n    scale: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeletonData<BoneData extends IBoneData = IBoneData,\r\n                               SlotData extends ISlotData = ISlotData,\r\n                               Skin extends ISkin = ISkin,\r\n                               Animation extends IAnimation = IAnimation,\r\n                               EventData extends IEventData = IEventData,\r\n                               IkConstraintData extends IIkConstraintData = IIkConstraintData,\r\n                               TransformConstraintData extends ITransformConstraintData = ITransformConstraintData,\r\n                               PathConstraintData extends IPathConstraintData = IPathConstraintData> {\r\n    name: string;\r\n    bones: BoneData[];\r\n    slots: SlotData[];\r\n    skins: Skin[];\r\n    defaultSkin: Skin;\r\n    events: EventData[];\r\n    animations: Animation[];\r\n    version: string;\r\n    hash: string;\r\n    width: number;\r\n    height: number;\r\n    ikConstraints: IkConstraintData[];\r\n    transformConstraints: TransformConstraintData[];\r\n    pathConstraints: PathConstraintData[];\r\n\r\n    findBone(boneName: string): BoneData | null;\r\n    findBoneIndex(boneName: string): number;\r\n    findSlot(slotName: string): SlotData | null;\r\n    findSlotIndex (slotName: string): number;\r\n    findSkin (skinName: string): Skin | null;\r\n\r\n    findEvent (eventDataName: string): EventData | null;\r\n    findAnimation (animationName: string): Animation | null;\r\n    findIkConstraint (constraintName: string): IkConstraintData | null;\r\n    findTransformConstraint (constraintName: string): TransformConstraintData | null;\r\n    findPathConstraint (constraintName: string): PathConstraintData | null;\r\n}\r\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "\r\nimport { Texture } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\n\r\n/**\r\n * @public\r\n */\r\nexport function filterFromString (text: string): TextureFilter {\r\n    switch (text.toLowerCase()) {\r\n        case \"nearest\": return TextureFilter.Nearest;\r\n        case \"linear\": return TextureFilter.Linear;\r\n        case \"mipmap\": return TextureFilter.MipMap;\r\n        case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n        case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n        case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n        case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n        default: throw new Error(`Unknown texture filter ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function wrapFromString (text: string): TextureWrap {\r\n    switch (text.toLowerCase()) {\r\n        case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n        case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n        case \"repeat\": return TextureWrap.Repeat;\r\n        default: throw new Error(`Unknown texture wrap ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureRegion {\r\n    texture: Texture;\r\n\r\n    //thats for overrides\r\n    size: Rectangle = null;\r\n\r\n    names: string[] = null;\r\n    values: number[][] = null;\r\n\r\n    renderObject: any = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return (this.texture as any)._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return (this.texture as any)._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return (this.texture as any)._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return (this.texture as any)._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        let tex = this.texture;\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        return this.texture.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        return this.texture.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n\r\n    get degrees() {\r\n        return (360 - this.texture.rotate * 45) % 360;\r\n    }\r\n}\r\n", "import {SCALE_MODES, MIPMAP_MODES, ALPHA_MODES} from '@pixi/constants';\r\nimport {Texture} from '@pixi/core';\r\nimport {Rectangle} from '@pixi/math';\r\nimport {TextureRegion, TextureWrap, TextureFilter, filterFromString} from './TextureRegion';\r\nimport {Map, Disposable} from './Utils';\r\n\r\nimport type {BaseTexture} from '@pixi/core';\r\n\r\nclass RegionFields {\r\n    x = 0;\r\n    y = 0;\r\n    width = 0;\r\n    height = 0;\r\n    offsetX = 0;\r\n    offsetY = 0;\r\n    originalWidth = 0;\r\n    originalHeight = 0;\r\n    rotate = 0;\r\n    index = 0;\r\n}\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: Texture) {\r\n        let pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n        for (let i = 0; i < pages.length; i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            let baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        let region = new TextureAtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\r\n        for (let key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null)\r\n            throw new Error(\"textureLoader cannot be null.\");\r\n\r\n        let reader = new TextureAtlasReader(atlasText);\r\n        let entry = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n        let pageFields: Map<Function> = {};\r\n        let region: RegionFields = null;\r\n        pageFields[\"size\"] = () => {\r\n            page.width = parseInt(entry[1]);\r\n            page.height = parseInt(entry[2]);\r\n        };\r\n        pageFields[\"format\"] = () => {\r\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n        };\r\n        pageFields[\"filter\"] = () => {\r\n            page.minFilter = filterFromString(entry[1]);\r\n            page.magFilter = filterFromString(entry[2]);\r\n        };\r\n        pageFields[\"repeat\"] = () => {\r\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\r\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\r\n        };\r\n        pageFields[\"pma\"] = () => {\r\n            page.pma = entry[1] == \"true\";\r\n        };\r\n\r\n        let regionFields: Map<Function> = {};\r\n        regionFields[\"xy\"] = () => { // Deprecated, use bounds.\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"size\"] = () => { // Deprecated, use bounds.\r\n            region.width = parseInt(entry[1]);\r\n            region.height = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"bounds\"] = () => {\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n            region.width = parseInt(entry[3]);\r\n            region.height = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"offset\"] = () => { // Deprecated, use offsets.\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"orig\"] = () => { // Deprecated, use offsets.\r\n            region.originalWidth = parseInt(entry[1]);\r\n            region.originalHeight = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"offsets\"] = () => {\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n            region.originalWidth = parseInt(entry[3]);\r\n            region.originalHeight = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"rotate\"] = () => {\r\n            let rotateValue = entry[1];\r\n            let rotate = 0;\r\n            if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                rotate = 6;\r\n            } else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                rotate = 0;\r\n            } else {\r\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n            }\r\n            region.rotate = rotate;\r\n        };\r\n        regionFields[\"index\"] = () => {\r\n            region.index = parseInt(entry[1]);\r\n        };\r\n\r\n        let line = reader.readLine();\r\n        // Ignore empty lines before first entry.\r\n        while (line != null && line.trim().length == 0)\r\n            line = reader.readLine();\r\n        // Header entries.\r\n        while (true) {\r\n            if (line == null || line.trim().length == 0) break;\r\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\r\n            line = reader.readLine();\r\n        }\r\n\r\n        let iterateParser = () => {\r\n            while (true) {\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                if (line.trim().length == 0) {\r\n                    page = null;\r\n                    line = reader.readLine();\r\n                } else if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line.trim();\r\n\r\n                    while (true) {\r\n                        if (reader.readEntry(entry, line = reader.readLine()) == 0) break;\r\n                        let field: Function = pageFields[entry[0]];\r\n                        if (field) field();\r\n                    }\r\n                    this.pages.push(page);\r\n\r\n                    textureLoader(page.name, (texture: BaseTexture) => {\r\n                        if (texture === null) {\r\n                            this.pages.splice(this.pages.indexOf(page), 1);\r\n                            return callback && callback(null);\r\n                        }\r\n                        page.baseTexture = texture;\r\n                        //TODO: set scaleMode and mipmapMode from spine\r\n                        if (page.pma) {\r\n                            texture.alphaMode = ALPHA_MODES.PMA;\r\n                        }\r\n                        if (!texture.valid) {\r\n                            texture.setSize(page.width, page.height);\r\n                        }\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    region = new RegionFields();\r\n                    let atlasRegion = new TextureAtlasRegion();\r\n                    atlasRegion.name = line;\r\n                    atlasRegion.page = page;\r\n                    let names: string[] = null;\r\n                    let values: number[][] = null;\r\n                    while (true) {\r\n                        let count = reader.readEntry(entry, line = reader.readLine());\r\n                        if (count == 0) break;\r\n                        let field: Function = regionFields[entry[0]];\r\n                        if (field)\r\n                            field();\r\n                        else {\r\n                            if (names == null) {\r\n                                names = [];\r\n                                values = []\r\n                            }\r\n                            names.push(entry[0]);\r\n                            let entryValues: number[] = [];\r\n                            for (let i = 0; i < count; i++)\r\n                                entryValues.push(parseInt(entry[i + 1]));\r\n                            values.push(entryValues);\r\n                        }\r\n                    }\r\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\r\n                        region.originalWidth = region.width;\r\n                        region.originalHeight = region.height;\r\n                    }\r\n\r\n                    let resolution = page.baseTexture.resolution;\r\n                    region.x /= resolution;\r\n                    region.y /= resolution;\r\n                    region.width /= resolution;\r\n                    region.height /= resolution;\r\n                    region.originalWidth /= resolution;\r\n                    region.originalHeight /= resolution;\r\n                    region.offsetX /= resolution;\r\n                    region.offsetY /= resolution;\r\n\r\n                    const swapWH = region.rotate % 4 !== 0;\r\n                    let frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\r\n\r\n                    let orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\r\n                    let trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\r\n\r\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\r\n                    atlasRegion.index = region.index;\r\n                    atlasRegion.texture.updateUvs();\r\n\r\n                    this.regions.push(atlasRegion);\r\n                }\r\n            }\r\n        };\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index: number = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length)\r\n            return null;\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readEntry (entry: string[], line: string): number {\r\n        if (line == null) return 0;\r\n        line = line.trim();\r\n        if (line.length == 0) return 0;\r\n\r\n        let colon = line.indexOf(':');\r\n        if (colon == -1) return 0;\r\n        entry[0] = line.substr(0, colon).trim();\r\n        for (let i = 1, lastMatch = colon + 1;; i++) {\r\n            let comma = line.indexOf(',', lastMatch);\r\n            if (comma == -1) {\r\n                entry[i] = line.substr(lastMatch).trim();\r\n                return i;\r\n            }\r\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n            if (i == 4) return 4;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter = TextureFilter.Nearest;\r\n    magFilter: TextureFilter = TextureFilter.Nearest;\r\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    baseTexture: BaseTexture;\r\n    width: number;\r\n    height: number;\r\n    pma: boolean;\r\n\r\n    public setFilters() {\r\n        let tex = this.baseTexture;\r\n        let filter = this.minFilter;\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = MIPMAP_MODES.POW2;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n", "import {ISkeleton} from \"./ISkeleton\";\r\n\r\n\r\nlet fround_polyfill = (function(array) {\r\n    return function(x: number) {\r\n        return array[0] = x, array[0];\r\n    };\r\n})(new Float32Array(1));\r\n\r\nlet fround: (value: number) => number =\r\n    (Math as any).fround || fround_polyfill;\r\n/**\r\n * @public\r\n */\r\nexport interface Map<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface StringMap<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IntSet {\r\n    array = new Array<number>();\r\n\r\n    add (value: number): boolean {\r\n        let contains = this.contains(value);\r\n        this.array[value | 0] = value | 0;\r\n        return !contains;\r\n    }\r\n\r\n    contains (value: number) {\r\n        return this.array[value | 0] != undefined;\r\n    }\r\n\r\n    remove (value: number) {\r\n        this.array[value | 0] = undefined;\r\n    }\r\n\r\n    clear () {\r\n        this.array.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class StringSet {\r\n    entries: StringMap<boolean> = {};\r\n    size = 0;\r\n\r\n    add (value: string): boolean {\r\n        let contains = this.entries[value];\r\n        this.entries[value] = true;\r\n        if (!contains) {\r\n            this.size++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    addAll (values: string[]): boolean {\r\n        let oldSize = this.size;\r\n        for (var i = 0, n = values.length; i < n; i++)\r\n            this.add(values[i]);\r\n        return oldSize != this.size;\r\n    }\r\n\r\n    contains (value: string) {\r\n        return this.entries[value];\r\n    }\r\n\r\n    clear () {\r\n        this.entries = {};\r\n        this.size = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface NumberArrayLike {\r\n    readonly length: number;\r\n    [n: number]: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Disposable {\r\n    dispose (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Restorable {\r\n    restore (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Color {\r\n    public static WHITE = new Color(1, 1, 1, 1);\r\n    public static RED = new Color(1, 0, 0, 1);\r\n    public static GREEN = new Color(0, 1, 0, 1);\r\n    public static BLUE = new Color(0, 0, 1, 1);\r\n    public static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\r\n    }\r\n\r\n    set (r: number, g: number, b: number, a: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this.clamp();\r\n    }\r\n\r\n    setFromColor (c: Color) {\r\n        this.r = c.r;\r\n        this.g = c.g;\r\n        this.b = c.b;\r\n        this.a = c.a;\r\n        return this;\r\n    }\r\n\r\n    setFromString (hex: string) {\r\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\r\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\r\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\r\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\r\n        return this;\r\n    }\r\n\r\n    add (r: number, g: number, b: number, a: number) {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n        return this.clamp();\r\n    }\r\n\r\n    clamp () {\r\n        if (this.r < 0) this.r = 0;\r\n        else if (this.r > 1) this.r = 1;\r\n\r\n        if (this.g < 0) this.g = 0;\r\n        else if (this.g > 1) this.g = 1;\r\n\r\n        if (this.b < 0) this.b = 0;\r\n        else if (this.b > 1) this.b = 1;\r\n\r\n        if (this.a < 0) this.a = 0;\r\n        else if (this.a > 1) this.a = 1;\r\n        return this;\r\n    }\r\n\r\n    static rgba8888ToColor (color: Color, value: number) {\r\n        color.r = ((value & 0xff000000) >>> 24) / 255;\r\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.a = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static rgb888ToColor (color: Color, value: number) {\r\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.b = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static fromString (hex: string): Color {\r\n        return new Color().setFromString(hex);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MathUtils {\r\n    static PI = 3.1415927;\r\n    static PI2 = MathUtils.PI * 2;\r\n    static radiansToDegrees = 180 / MathUtils.PI;\r\n    static radDeg = MathUtils.radiansToDegrees;\r\n    static degreesToRadians = MathUtils.PI / 180;\r\n    static degRad = MathUtils.degreesToRadians;\r\n\r\n    static clamp (value: number, min: number, max: number) {\r\n        if (value < min) return min;\r\n        if (value > max) return max;\r\n        return value;\r\n    }\r\n\r\n    static cosDeg (degrees: number) {\r\n        return Math.cos(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static sinDeg (degrees: number) {\r\n        return Math.sin(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static signum (value: number): number {\r\n        return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n    }\r\n\r\n    static toInt (x: number) {\r\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n    }\r\n\r\n    static cbrt (x: number) {\r\n        let y = Math.pow(Math.abs(x), 1 / 3);\r\n        return x < 0 ? -y : y;\r\n    }\r\n\r\n    static randomTriangular (min: number, max: number): number {\r\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n    }\r\n\r\n    static randomTriangularWith (min: number, max: number, mode: number): number {\r\n        let u = Math.random();\r\n        let d = max - min;\r\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\r\n        return max - Math.sqrt((1 - u) * d * (max - mode));\r\n    }\r\n\r\n    static isPowerOfTwo (value: number) {\r\n        return value && (value & (value - 1)) === 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Interpolation {\r\n    protected abstract applyInternal (a: number): number;\r\n    apply (start: number, end: number, a: number): number {\r\n        return start + (end - start) * this.applyInternal(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pow extends Interpolation {\r\n    protected power = 2;\r\n\r\n    constructor (power: number) {\r\n        super();\r\n        this.power = power;\r\n    }\r\n\r\n    applyInternal (a: number): number {\r\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\r\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PowOut extends Pow {\r\n    constructor (power: number) {\r\n        super(power);\r\n    }\r\n\r\n    applyInternal (a: number): number {\r\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Utils {\r\n    static SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n\r\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n            dest[j] = source[i];\r\n        }\r\n    }\r\n\r\n    static arrayFill<T> (array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\r\n        for (let i = fromIndex; i < toIndex; i++)\r\n            array[i] = value;\r\n    }\r\n\r\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        let oldSize = array.length;\r\n        if (oldSize == size) return array;\r\n        array.length = size;\r\n        if (oldSize < size) {\r\n            for (let i = oldSize; i < size; i++) array[i] = value;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        if (array.length >= size) return array;\r\n        return Utils.setArraySize(array, size, value);\r\n    }\r\n\r\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\r\n        let array = new Array<T>(size);\r\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\r\n        return array;\r\n    }\r\n\r\n    static newFloatArray (size: number): NumberArrayLike {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Float32Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static newShortArray (size: number): NumberArrayLike {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Int16Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static toFloatArray (array: Array<number>) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n    }\r\n\r\n    static toSinglePrecision (value: number) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;\r\n    }\r\n\r\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n    static webkit602BugfixHelper (alpha: number, blend: any) {\r\n\r\n    }\r\n\r\n    static contains<T> (array: Array<T>, element: T, identity = true) {\r\n        for (var i = 0; i < array.length; i++)\r\n            if (array[i] == element) return true;\r\n        return false;\r\n    }\r\n\r\n    static enumValue (type: any, name: string) {\r\n        return type[name[0].toUpperCase() + name.slice(1)];\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DebugUtils {\r\n    static logBones(skeleton: ISkeleton) {\r\n        for (let i = 0; i < skeleton.bones.length; i++) {\r\n            let bone = skeleton.bones[i];\r\n            let mat = bone.matrix;\r\n            console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pool<T> {\r\n    private items = new Array<T>();\r\n    private instantiator: () => T;\r\n\r\n    constructor (instantiator: () => T) {\r\n        this.instantiator = instantiator;\r\n    }\r\n\r\n    obtain () {\r\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n    }\r\n\r\n    free (item: T) {\r\n        if ((item as any).reset) (item as any).reset();\r\n        this.items.push(item);\r\n    }\r\n\r\n    freeAll (items: ArrayLike<T>) {\r\n        for (let i = 0; i < items.length; i++)\r\n            this.free(items[i]);\r\n    }\r\n\r\n    clear () {\r\n        this.items.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Vector2 {\r\n    constructor (public x = 0, public y = 0) {\r\n    }\r\n\r\n    set (x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    length () {\r\n        let x = this.x;\r\n        let y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    normalize () {\r\n        let len = this.length();\r\n        if (len != 0) {\r\n            this.x /= len;\r\n            this.y /= len;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TimeKeeper {\r\n    maxDelta = 0.064;\r\n    framesPerSecond = 0;\r\n    delta = 0;\r\n    totalTime = 0;\r\n\r\n    private lastTime = Date.now() / 1000;\r\n    private frameCount = 0;\r\n    private frameTime = 0;\r\n\r\n    update () {\r\n        let now = Date.now() / 1000;\r\n        this.delta = now - this.lastTime;\r\n        this.frameTime += this.delta;\r\n        this.totalTime += this.delta;\r\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n        this.lastTime = now;\r\n\r\n        this.frameCount++;\r\n        if (this.frameTime > 1) {\r\n            this.framesPerSecond = this.frameCount / this.frameTime;\r\n            this.frameTime = 0;\r\n            this.frameCount = 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ArrayLike<T> {\r\n    length: number;\r\n    [n: number]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class WindowedMean {\r\n    values: Array<number>;\r\n    addedValues = 0;\r\n    lastValue = 0;\r\n    mean = 0;\r\n    dirty = true;\r\n\r\n    constructor (windowSize: number = 32) {\r\n        this.values = new Array<number>(windowSize);\r\n    }\r\n\r\n    hasEnoughData () {\r\n        return this.addedValues >= this.values.length;\r\n    }\r\n\r\n    addValue (value: number) {\r\n        if (this.addedValues < this.values.length) this.addedValues++;\r\n        this.values[this.lastValue++] = value;\r\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\r\n        this.dirty = true;\r\n    }\r\n\r\n    getMean () {\r\n        if (this.hasEnoughData()) {\r\n            if (this.dirty) {\r\n                let mean = 0;\r\n                for (let i = 0; i < this.values.length; i++)\r\n                    mean += this.values[i];\r\n                this.mean = mean / this.values.length;\r\n                this.dirty = false;\r\n            }\r\n            return this.mean;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n", "import { AttachmentType } from \"./AttachmentType\";\r\nimport type {ISkeleton, IVertexAttachment} from \"./ISkeleton\";\r\nimport { NumberArrayLike, Pool, Utils } from \"./Utils\";\r\n\r\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBoundsBase <BoundingBoxAttachment extends IVertexAttachment> {\r\n\r\n    /** The left edge of the axis aligned bounding box. */\r\n    minX = 0;\r\n\r\n    /** The bottom edge of the axis aligned bounding box. */\r\n    minY = 0;\r\n\r\n    /** The right edge of the axis aligned bounding box. */\r\n    maxX = 0;\r\n\r\n    /** The top edge of the axis aligned bounding box. */\r\n    maxY = 0;\r\n\r\n    /** The visible bounding boxes. */\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n\r\n    /** The world vertices for the bounding box polygons. */\r\n    polygons = new Array<NumberArrayLike>();\r\n\r\n    private polygonPool = new Pool<NumberArrayLike>(() => {\r\n        return Utils.newFloatArray(16);\r\n    });\r\n\r\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\r\n     * box's polygon.\r\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\r\n     *           SkeletonBounds AABB methods will always return true. */\r\n    update (skeleton: ISkeleton, updateAabb: boolean) {\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        let boundingBoxes = this.boundingBoxes;\r\n        let polygons = this.polygons;\r\n        let polygonPool = this.polygonPool;\r\n        let slots = skeleton.slots;\r\n        let slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slot = slots[i];\r\n            if (!slot.bone.active) continue;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\r\n                let boundingBox = attachment as BoundingBoxAttachment;\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain() as NumberArrayLike;\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) {\r\n            this.aabbCompute();\r\n        } else {\r\n            this.minX = Number.POSITIVE_INFINITY;\r\n            this.minY = Number.POSITIVE_INFINITY;\r\n            this.maxX = Number.NEGATIVE_INFINITY;\r\n            this.maxY = Number.NEGATIVE_INFINITY;\r\n        }\r\n    }\r\n\r\n    aabbCompute () {\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            let polygon = polygons[i];\r\n            let vertices = polygon;\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                let x = vertices[ii];\r\n                let y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint (x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let minX = this.minX;\r\n        let minY = this.minY;\r\n        let maxX = this.maxX;\r\n        let maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        let m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton (bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. \r\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\r\n    containsPoint (x: number, y: number): BoundingBoxAttachment | null {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon (polygon: NumberArrayLike, x: number, y: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let vertexY = vertices[ii + 1];\r\n            let prevY = vertices[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                let vertexX = vertices[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\r\n     * true. */\r\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon (polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let width12 = x1 - x2, height12 = y1 - y2;\r\n        let det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\r\n            let det2 = x3 * y4 - y3 * x4;\r\n            let width34 = x3 - x4, height34 = y3 - y4;\r\n            let det3 = width12 * height34 - height12 * width34;\r\n            let x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                let y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon (boundingBox: BoundingBoxAttachment) {\r\n        if (!boundingBox) throw new Error(\"boundingBox cannot be null.\");\r\n        let index = this.boundingBoxes.indexOf(boundingBox);\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    /** The width of the axis aligned bounding box. */\r\n    getWidth () {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    /** The height of the axis aligned bounding box. */\r\n    getHeight () {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n", "/**\r\n * @public\r\n */\r\nexport let settings = {\r\n    yDown: true,\r\n    /**\r\n     * pixi-spine gives option to not fail at certain parsing errors\r\n     * spine-ts fails here\r\n     */\r\n    FAIL_ON_NON_EXISTING_SKIN: false,\r\n\r\n    /**\r\n     * past Spine.globalAutoUpdate\r\n     */\r\n    GLOBAL_AUTO_UPDATE: true,\r\n\r\n    /**\r\n     * past Spine.globalDelayLimit\r\n     */\r\n    GLOBAL_DELAY_LIMIT: 0,\r\n}\r\n", "import {AttachmentType} from './core/AttachmentType';\r\nimport {TextureRegion} from './core/TextureRegion';\r\nimport {MathUtils} from './core/Utils';\r\nimport type {\r\n    IAnimationState,\r\n    IAnimationStateData\r\n} from './core/IAnimation';\r\nimport type {\r\n    IAttachment, IClippingAttachment, IMeshAttachment,\r\n    IRegionAttachment,\r\n    ISkeleton,\r\n    ISkeletonData,\r\n    ISlot,\r\n    IVertexAttachment\r\n} from './core/ISkeleton';\r\n\r\nimport {DRAW_MODES} from '@pixi/constants';\r\nimport {Container, DisplayObject} from '@pixi/display';\r\nimport {Sprite} from '@pixi/sprite';\r\nimport {SimpleMesh} from '@pixi/mesh-extras';\r\nimport {Graphics} from '@pixi/graphics'\r\nimport {Rectangle, Polygon, Transform} from '@pixi/math';\r\nimport {hex2rgb, rgb2hex} from '@pixi/utils';\r\nimport type {Texture} from '@pixi/core';\r\nimport {settings} from \"./settings\";\r\nimport { ISpineDebugRenderer } from './SpineDebugRenderer';\r\n\r\nlet tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISpineDisplayObject extends DisplayObject {\r\n    region?: TextureRegion;\r\n    attachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        super(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n}\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nexport abstract class SpineBase<Skeleton extends ISkeleton,\r\n    SkeletonData extends ISkeletonData,\r\n    AnimationState extends IAnimationState,\r\n    AnimationStateData extends IAnimationStateData>\r\n    extends Container implements GlobalMixins.Spine {\r\n    tintRgb: ArrayLike<number>;\r\n    spineData: SkeletonData;\r\n    skeleton: Skeleton;\r\n    stateData: AnimationStateData;\r\n    state: AnimationState;\r\n    slotContainers: Array<Container>;\r\n    tempClipContainers: Array<Container>;\r\n    localDelayLimit: number;\r\n    private _autoUpdate: boolean;\r\n    protected _visible: boolean;\r\n    private _debug: ISpineDebugRenderer;\r\n    public get debug(): ISpineDebugRenderer {\r\n        return this._debug;\r\n    }\r\n    public set debug(value: ISpineDebugRenderer) {\r\n        if (value == this._debug) { // soft equality allows null == undefined\r\n            return;\r\n        }\r\n        this._debug?.unregisterSpine(this);\r\n        value?.registerSpine(this);\r\n        this._debug = value;\r\n    }\r\n\r\n\r\n    abstract createSkeleton(spineData: ISkeletonData);\r\n\r\n    constructor(spineData: SkeletonData) {\r\n        super();\r\n\r\n        if (!spineData) {\r\n            throw new Error('The spineData param is required.');\r\n        }\r\n\r\n        if ((typeof spineData) === \"string\") {\r\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n        }\r\n\r\n        /**\r\n         * The spineData object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.spineData = spineData;\r\n\r\n        /**\r\n         * A spine Skeleton object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.createSkeleton(spineData);\r\n\r\n        /**\r\n         * An array of containers\r\n         *\r\n         * @member {Container[]}\r\n         */\r\n        this.slotContainers = [];\r\n\r\n        this.tempClipContainers = [];\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            let attachment: any = slot.getAttachment();\r\n            let slotContainer = this.newContainer();\r\n            this.slotContainers.push(slotContainer);\r\n            this.addChild(slotContainer);\r\n            this.tempClipContainers.push(null);\r\n\r\n            if (!attachment) {\r\n                continue;\r\n            }\r\n            if (attachment.type === AttachmentType.Region) {\r\n                let spriteName = attachment.name;\r\n                let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                slot.currentSprite = sprite;\r\n                slot.currentSpriteName = spriteName;\r\n                slotContainer.addChild(sprite);\r\n            } else if (attachment.type === AttachmentType.Mesh) {\r\n                let mesh = this.createMesh(slot, attachment);\r\n                slot.currentMesh = mesh;\r\n                slot.currentMeshId = attachment.id;\r\n                slot.currentMeshName = attachment.name;\r\n                slotContainer.addChild(mesh);\r\n            } else if (attachment.type === AttachmentType.Clipping) {\r\n                this.createGraphics(slot, attachment);\r\n                slotContainer.addChild(slot.clippingContainer);\r\n                slotContainer.addChild(slot.currentGraphics);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         */\r\n        this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n        this.autoUpdate = true;\r\n        this.visible = true;\r\n    }\r\n\r\n    /**\r\n     * If this flag is set to true, the spine animation will be automatically updated every\r\n     * time the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoUpdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof spine.Spine#\r\n     * @default true\r\n     */\r\n    get autoUpdate(): boolean {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    set autoUpdate(value: boolean) {\r\n        if (value !== this._autoUpdate) {\r\n            this._autoUpdate = value;\r\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number {\r\n        return rgb2hex(this.tintRgb as any);\r\n    }\r\n\r\n    set tint(value: number) {\r\n        this.tintRgb = hex2rgb(value, this.tintRgb as any);\r\n    }\r\n\r\n    /**\r\n     * Limit value for the update dt with Spine.globalDelayLimit\r\n     * that can be overridden with localDelayLimit\r\n     * @return {number} - Maximum processed dt value for the update\r\n     */\r\n    get delayLimit(): number {\r\n        let limit = typeof this.localDelayLimit !== \"undefined\" ?\r\n            this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\r\n\r\n        // If limit is 0, this means there is no limit for the delay\r\n        return limit || Number.MAX_VALUE\r\n    }\r\n\r\n    /**\r\n     * Update the spine skeleton and its animations by delta time (dt)\r\n     *\r\n     * @param dt {number} Delta time. Time by which the animation should be updated\r\n     */\r\n    update(dt: number) {\r\n        // Limit delta value to avoid animation jumps\r\n        let delayLimit = this.delayLimit;\r\n        if (dt > delayLimit) dt = delayLimit;\r\n\r\n        this.state.update(dt);\r\n        this.state.apply(this.skeleton);\r\n\r\n        //check we haven't been destroyed via a spine event callback in state update\r\n        if (!this.skeleton)\r\n            return;\r\n\r\n        this.skeleton.updateWorldTransform();\r\n\r\n        let slots = this.skeleton.slots;\r\n\r\n        // in case pixi has double tint\r\n        let globalClr = (this as any).color;\r\n        let light: ArrayLike<number> = null, dark: ArrayLike<number> = null;\r\n\r\n        if (globalClr) {\r\n            light = globalClr.light;\r\n            dark = globalClr.dark;\r\n        } else {\r\n            light = this.tintRgb;\r\n        }\r\n\r\n        // let thack = false;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            let attachment = slot.getAttachment();\r\n            let slotContainer = this.slotContainers[i];\r\n\r\n            if (!attachment) {\r\n                slotContainer.visible = false;\r\n                continue;\r\n            }\r\n\r\n            let spriteColor: any = null;\r\n\r\n            if (attachment.sequence) {\r\n                attachment.sequence.apply(slot, attachment as any);\r\n            }\r\n            let region = (attachment as IRegionAttachment).region;\r\n\r\n            let attColor = (attachment as any).color;\r\n            switch (attachment != null && attachment.type) {\r\n                case AttachmentType.Region:\r\n                    let transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    region = (attachment as IRegionAttachment).region;\r\n                    if (slot.currentMesh) {\r\n                        slot.currentMesh.visible = false;\r\n                        slot.currentMesh = null;\r\n                        slot.currentMeshId = undefined;\r\n                        slot.currentMeshName = undefined;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\r\n                        let spriteName = attachment.name;\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.visible = false;\r\n                        }\r\n                        slot.sprites = slot.sprites || {};\r\n                        if (slot.sprites[spriteName] !== undefined) {\r\n                            slot.sprites[spriteName].visible = true;\r\n                        } else {\r\n                            let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                            slotContainer.addChild(sprite);\r\n                        }\r\n                        slot.currentSprite = slot.sprites[spriteName];\r\n                        slot.currentSpriteName = spriteName;\r\n\r\n                        // force sprite update when attachment name is same.\r\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                    }\r\n                    slot.currentSprite.renderable = true;\r\n                    if (!slot.hackRegion) {\r\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\r\n                    }\r\n                    if (slot.currentSprite.color) {\r\n                        //YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                    break;\r\n\r\n                case AttachmentType.Mesh:\r\n                    if (slot.currentSprite) {\r\n                        //TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        //TODO: refactor this shit\r\n                        const transform = new Transform();\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    const id = (attachment as IVertexAttachment).id;\r\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\r\n                        let meshId = id;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        } else {\r\n                            let mesh = this.createMesh(slot, attachment as IMeshAttachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    slot.currentMesh.renderable = true;\r\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                    if (!slot.hackRegion) {\r\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\r\n                    }\r\n                    break;\r\n                case AttachmentType.Clipping:\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment as IClippingAttachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                default:\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n            }\r\n            slotContainer.visible = true;\r\n\r\n            // pixi has double tint\r\n            if (spriteColor) {\r\n                let r0 = slot.color.r * attColor.r;\r\n                let g0 = slot.color.g * attColor.g;\r\n                let b0 = slot.color.b * attColor.b;\r\n\r\n                //YAY! double-tint!\r\n                spriteColor.setLight(\r\n                    light[0] * r0 + dark[0] * (1.0 - r0),\r\n                    light[1] * g0 + dark[1] * (1.0 - g0),\r\n                    light[2] * b0 + dark[2] * (1.0 - b0),\r\n                );\r\n                if (slot.darkColor) {\r\n                    r0 = slot.darkColor.r;\r\n                    g0 = slot.darkColor.g;\r\n                    b0 = slot.darkColor.b;\r\n                } else {\r\n                    r0 = 0.0;\r\n                    g0 = 0.0;\r\n                    b0 = 0.0;\r\n                }\r\n                spriteColor.setDark(\r\n                    light[0] * r0 + dark[0] * (1 - r0),\r\n                    light[1] * g0 + dark[1] * (1 - g0),\r\n                    light[2] * b0 + dark[2] * (1 - b0),\r\n                );\r\n            }\r\n\r\n            slotContainer.alpha = slot.color.a;\r\n        }\r\n\r\n        //== this is clipping implementation ===\r\n        //TODO: remove parent hacks when pixi masks allow it\r\n        let drawOrder = this.skeleton.drawOrder;\r\n        let clippingAttachment: IClippingAttachment = null;\r\n        let clippingContainer: Container = null;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = slots[drawOrder[i].data.index];\r\n            let slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n            if (!clippingContainer) {\r\n                //Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                    slotContainer.parent.removeChild(slotContainer);\r\n                    //silend add hack\r\n                    (slotContainer as any).parent = this;\r\n                }\r\n            }\r\n            if (slot.currentGraphics && slot.getAttachment()) {\r\n                clippingContainer = slot.clippingContainer;\r\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\r\n                clippingContainer.children.length = 0;\r\n                this.children[i] = slotContainer;\r\n\r\n                if (clippingAttachment.endSlot === slot.data) {\r\n                    clippingAttachment.endSlot = null;\r\n                }\r\n\r\n            } else {\r\n                if (clippingContainer) {\r\n                    let c = this.tempClipContainers[i];\r\n                    if (!c) {\r\n                        c = this.tempClipContainers[i] = this.newContainer();\r\n                        c.visible = false;\r\n                    }\r\n                    this.children[i] = c;\r\n\r\n                    //silent remove hack\r\n                    (slotContainer as any).parent = null;\r\n                    clippingContainer.addChild(slotContainer);\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingContainer.renderable = true;\r\n                        clippingContainer = null;\r\n                        clippingAttachment = null;\r\n                    }\r\n                } else {\r\n                    this.children[i] = slotContainer;\r\n                }\r\n            }\r\n        }\r\n\r\n        // if you can debug, then debug!\r\n        this._debug?.renderDebug(this);\r\n    };\r\n\r\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\r\n        // prevent setters calling when attachment and region is same\r\n        if (sprite.attachment === attachment && sprite.region === region) {\r\n            return;\r\n        }\r\n\r\n        sprite.region = region;\r\n        sprite.attachment = attachment;\r\n\r\n        sprite.texture = region.texture;\r\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\r\n        sprite.position.x = attachment.x;\r\n        sprite.position.y = attachment.y;\r\n        sprite.alpha = attachment.color.a;\r\n\r\n        if (!region.size) {\r\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n        } else {\r\n            //hacked!\r\n            sprite.scale.x = region.size.width / region.originalWidth;\r\n            sprite.scale.y = -region.size.height / region.originalHeight;\r\n        }\r\n    }\r\n\r\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\r\n\r\n        if (mesh.attachment === attachment && mesh.region === region) {\r\n            return;\r\n        }\r\n\r\n        mesh.region = region;\r\n        mesh.attachment = attachment;\r\n        mesh.texture = region.texture;\r\n        region.texture.updateUvs();\r\n        mesh.uvBuffer.update(attachment.regionUVs);\r\n    }\r\n\r\n    protected lastTime: number;\r\n\r\n    /**\r\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n     *\r\n     * @private\r\n     */\r\n    autoUpdateTransform() {\r\n        if (settings.GLOBAL_AUTO_UPDATE) {\r\n            this.lastTime = this.lastTime || Date.now();\r\n            let timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n            this.lastTime = Date.now();\r\n            this.update(timeDelta);\r\n        } else {\r\n            this.lastTime = 0;\r\n        }\r\n\r\n        Container.prototype.updateTransform.call(this);\r\n    };\r\n\r\n    /**\r\n     * Create a new sprite to be used with core.RegionAttachment\r\n     *\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n        }\r\n        let texture = region ? region.texture : null;\r\n        let sprite = this.newSprite(texture);\r\n\r\n        sprite.anchor.set(0.5);\r\n        if (region) {\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n        }\r\n\r\n        slot.sprites = slot.sprites || {};\r\n        slot.sprites[defName] = sprite;\r\n        return sprite;\r\n    };\r\n\r\n    /**\r\n     * Creates a Strip from the spine data\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n            slot.hackAttachment = null;\r\n            slot.hackRegion = null;\r\n        }\r\n        let strip = this.newMesh(\r\n            region ? region.texture : null,\r\n            new Float32Array(attachment.regionUVs.length),\r\n            attachment.regionUVs,\r\n            new Uint16Array(attachment.triangles),\r\n            DRAW_MODES.TRIANGLES);\r\n\r\n        if (typeof (strip as any)._canvasPadding !== \"undefined\") {\r\n            (strip as any)._canvasPadding = 1.5;\r\n        }\r\n\r\n        strip.alpha = attachment.color.a;\r\n\r\n        strip.region = attachment.region;\r\n        if (region) {\r\n            this.setMeshRegion(attachment, strip, region);\r\n        }\r\n\r\n        slot.meshes = slot.meshes || {};\r\n        slot.meshes[attachment.id] = strip;\r\n        return strip;\r\n    };\r\n\r\n    static clippingPolygon: Array<number> = [];\r\n\r\n    //@ts-ignore\r\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let graphics = this.newGraphics();\r\n        let poly = new Polygon([]);\r\n        graphics.clear();\r\n        graphics.beginFill(0xffffff, 1);\r\n        graphics.drawPolygon(poly as any);\r\n        graphics.renderable = false;\r\n        slot.currentGraphics = graphics;\r\n        slot.clippingContainer = this.newContainer();\r\n        slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n        return graphics;\r\n    }\r\n\r\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let geom = slot.currentGraphics.geometry;\r\n        let vertices = (geom.graphicsData[0].shape as Polygon).points;\r\n        let n = clip.worldVerticesLength;\r\n        vertices.length = n;\r\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n        geom.invalidate();\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotIndex {number}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\r\n        let slot = this.skeleton.slots[slotIndex];\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n        let attachment: any = slot.getAttachment();\r\n        let region: TextureRegion = attachment.region;\r\n        if (texture) {\r\n            region = new TextureRegion();\r\n            region.texture = texture;\r\n            region.size = size;\r\n            slot.hackRegion = region;\r\n            slot.hackAttachment = attachment;\r\n        } else {\r\n            slot.hackRegion = null;\r\n            slot.hackAttachment = null;\r\n        }\r\n        if (slot.currentSprite) {\r\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n        } else if (slot.currentMesh) {\r\n            this.setMeshRegion(attachment, slot.currentMesh, region);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\r\n        let index = this.skeleton.findSlotIndex(slotName);\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n        return this.hackTextureBySlotIndex(index, texture, size);\r\n    }\r\n\r\n    /**\r\n     * Changes texture of an attachment\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param attachmentName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\r\n        // changes the texture of an attachment at the skeleton level\r\n        const slotIndex = this.skeleton.findSlotIndex(slotName)\r\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName)\r\n        attachment.region.texture = texture\r\n\r\n        const slot = this.skeleton.slots[slotIndex]\r\n        if (!slot) {\r\n            return false\r\n        }\r\n\r\n        // gets the currently active attachment in this slot\r\n        const currentAttachment: any = slot.getAttachment()\r\n        if (attachmentName === currentAttachment.name) {\r\n            // if the attachment we are changing is currently active, change the the live texture\r\n            let region: TextureRegion = attachment.region\r\n            if (texture) {\r\n                region = new TextureRegion()\r\n                region.texture = texture\r\n                region.size = size\r\n                slot.hackRegion = region\r\n                slot.hackAttachment = currentAttachment\r\n            } else {\r\n                slot.hackRegion = null\r\n                slot.hackAttachment = null\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region)\r\n                slot.currentSprite.region = region\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region)\r\n            }\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    //those methods can be overriden to spawn different classes\r\n    newContainer() {\r\n        return new Container();\r\n    }\r\n\r\n    newSprite(tex: Texture) {\r\n        return new SpineSprite(tex);\r\n    }\r\n\r\n    newGraphics() {\r\n        return new Graphics();\r\n    }\r\n\r\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n\r\n    transformHack() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n     * @param nameSuffix\r\n     * @param group\r\n     * @param outGroup\r\n     */\r\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n        if (!nameSuffix) {\r\n            return undefined;\r\n        }\r\n        const list_d = [], list_n = [];\r\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const name = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n            const target = slot.currentSprite || slot.currentMesh;\r\n            if (name.endsWith(nameSuffix)) {\r\n                target.parentGroup = group;\r\n                list_n.push(target);\r\n            } else if (outGroup && target) {\r\n                target.parentGroup = outGroup;\r\n                list_d.push(target);\r\n            }\r\n        }\r\n        return [list_d, list_n];\r\n    };\r\n\r\n\r\n    destroy(options?: any): void {\r\n        this.debug = null; // setter will do the cleanup\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            for (let name in slot.meshes) {\r\n                slot.meshes[name].destroy(options);\r\n            }\r\n            slot.meshes = null;\r\n\r\n            for (let name in slot.sprites) {\r\n                slot.sprites[name].destroy(options);\r\n            }\r\n            slot.sprites = null;\r\n        }\r\n\r\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n            this.slotContainers[i].destroy(options);\r\n        }\r\n        this.spineData = null;\r\n        this.skeleton = null;\r\n        this.slotContainers = null;\r\n        this.stateData = null;\r\n        this.state = null;\r\n        this.tempClipContainers = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\r\nObject.defineProperty(SpineBase.prototype, 'visible', {\r\n    get: function () {\r\n        return this._visible;\r\n    },\r\n    set: function (value: boolean) {\r\n        if (value !== this._visible) {\r\n            this._visible = value;\r\n            if (value) {\r\n                this.lastTime = 0;\r\n            }\r\n        }\r\n    }\r\n})\r\n", "import { Container } from \"@pixi/display\";\r\nimport { Graphics } from \"@pixi/graphics\";\r\nimport type { IAnimationState, IAnimationStateData } from \"./core/IAnimation\";\r\nimport type { IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, IVertexAttachment } from \"./core/ISkeleton\";\r\nimport type { SpineBase } from \"./SpineBase\";\r\nimport { AttachmentType } from \"./core/AttachmentType\";\r\nimport { SkeletonBoundsBase } from \"./core/SkeletonBoundsBase\";\r\n\r\n/**\r\n * Make a class that extends from this interface to create your own debug renderer.\r\n * @public\r\n */\r\nexport interface ISpineDebugRenderer {\r\n    /**\r\n     * This will be called every frame, after the spine has been updated. \r\n     */\r\n    renderDebug(spine:SpineBase< ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>):void;\r\n\r\n    /**\r\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\r\n     */\r\n    unregisterSpine(spine:SpineBase< ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>):void\r\n\r\n    /**\r\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\r\n     */\r\n    registerSpine(spine:SpineBase< ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>):void\r\n}\r\n\r\ntype DebugDisplayObjects = {\r\n    bones: Container;\r\n    skeletonXY: Graphics;\r\n    regionAttachmentsShape: Graphics;\r\n    meshTrianglesLine: Graphics;\r\n    meshHullLine: Graphics;\r\n    clippingPolygon: Graphics;\r\n    boundingBoxesRect: Graphics;\r\n    boundingBoxesCircle: Graphics;\r\n    boundingBoxesPolygon: Graphics;\r\n    pathsCurve: Graphics;\r\n    pathsLine: Graphics;\r\n    parentDebugContainer: Container;\r\n}\r\n\r\n/**\r\n * This is a debug renderer that uses PixiJS Graphics under the hood.\r\n * @public\r\n */\r\nexport class SpineDebugRenderer implements ISpineDebugRenderer {\r\n    private registeredSpines:Map<SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, DebugDisplayObjects> = new Map();\r\n\r\n    public drawDebug: boolean = true;\r\n    public drawMeshHull: boolean = true;\r\n    public drawMeshTriangles: boolean = true;\r\n    public drawBones: boolean = true;\r\n    public drawPaths: boolean = true;\r\n    public drawBoundingBoxes: boolean = true;\r\n    public drawClipping: boolean = true;\r\n    public drawRegionAttachments: boolean = true;\r\n\r\n    public lineWidth: number =  1;\r\n    public regionAttachmentsColor: number =  0x0078ff;\r\n    public meshHullColor: number =  0x0078ff;\r\n    public meshTrianglesColor: number =  0xffcc00;\r\n    public clippingPolygonColor: number =  0xff00ff;\r\n    public boundingBoxesRectColor: number =  0x00ff00;\r\n    public boundingBoxesPolygonColor: number =  0x00ff00;\r\n    public boundingBoxesCircleColor: number =  0x00ff00;\r\n    public pathsCurveColor: number =  0xff0000;\r\n    public pathsLineColor: number =  0xff00ff;\r\n    public skeletonXYColor:number = 0xff0000;\r\n    public bonesColor:number = 0x00eecc;\r\n\r\n    /**\r\n     * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\r\n     */\r\n    public registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>) {\r\n        if (this.registeredSpines.has(spine))\r\n        {\r\n            console.warn(\"SpineDebugRenderer.registerSpine() - this spine is already registered!\", spine);\r\n        }\r\n        const debugDisplayObjects = {\r\n            parentDebugContainer: new Container(),\r\n            bones: new Container(),\r\n            skeletonXY: new Graphics(),\r\n            regionAttachmentsShape: new Graphics(),\r\n            meshTrianglesLine: new Graphics(),\r\n            meshHullLine: new Graphics(),\r\n            clippingPolygon: new Graphics(),\r\n            boundingBoxesRect: new Graphics(),\r\n            boundingBoxesCircle: new Graphics(),\r\n            boundingBoxesPolygon: new Graphics(),\r\n            pathsCurve: new Graphics(),\r\n            pathsLine: new Graphics(),\r\n        };\r\n        \r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\r\n\r\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\r\n\r\n        this.registeredSpines.set(spine, debugDisplayObjects);\r\n    }\r\n    public renderDebug(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>):void {\r\n\r\n        if (!this.registeredSpines.has(spine)) {\r\n            // This should never happen. Spines are registered when you assign spine.debug\r\n            this.registerSpine(spine);\r\n        }\r\n\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n\r\n        debugDisplayObjects.skeletonXY.clear();\r\n        debugDisplayObjects.regionAttachmentsShape.clear();\r\n        debugDisplayObjects.meshTrianglesLine.clear();\r\n        debugDisplayObjects.meshHullLine.clear();\r\n        debugDisplayObjects.clippingPolygon.clear();\r\n        debugDisplayObjects.boundingBoxesRect.clear();\r\n        debugDisplayObjects.boundingBoxesCircle.clear();\r\n        debugDisplayObjects.boundingBoxesPolygon.clear();\r\n        debugDisplayObjects.pathsCurve.clear();\r\n        debugDisplayObjects.pathsLine.clear();\r\n\r\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\r\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\r\n        }\r\n\r\n        const scale = spine.scale.x || spine.scale.y || 1;\r\n        const lineWidth = this.lineWidth / scale;\r\n\r\n        if (this.drawBones) {\r\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\r\n        }\r\n\r\n        if (this.drawPaths) {\r\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawBoundingBoxes) {\r\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawClipping) {\r\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawMeshHull || this.drawMeshTriangles) {\r\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawRegionAttachments) {\r\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n    }\r\n    \r\n    private drawBonesFunc(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number, scale:number): void {\r\n        const skeleton = spine.skeleton;\r\n        const skeletonX = skeleton.x;\r\n        const skeletonY = skeleton.y;\r\n        const bones = skeleton.bones;\r\n\r\n        debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\r\n\r\n        for (let i = 0, len = bones.length; i < len; i++) {\r\n            const bone = bones[i],\r\n                boneLen = bone.data.length,\r\n                starX = skeletonX + bone.matrix.tx,\r\n                starY = skeletonY + bone.matrix.ty,\r\n                endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx,\r\n                endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\r\n\r\n            if (bone.data.name === \"root\" || bone.data.parent === null) {\r\n                continue;\r\n            }\r\n\r\n            // Triangle calculation formula\r\n            // area: A=sqrt((a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c))/4\r\n            // alpha: alpha=acos((pow(b, 2)+pow(c, 2)-pow(a, 2))/(2*b*c))\r\n            // beta: beta=acos((pow(a, 2)+pow(c, 2)-pow(b, 2))/(2*a*c))\r\n            // gamma: gamma=acos((pow(a, 2)+pow(b, 2)-pow(c, 2))/(2*a*b))\r\n\r\n            const w = Math.abs(starX - endX),\r\n                h = Math.abs(starY - endY),\r\n                // a = w, // side length a\r\n                a2 = Math.pow(w, 2), // square root of side length a\r\n                b = h, // side length b\r\n                b2 = Math.pow(h, 2), // square root of side length b\r\n                c = Math.sqrt(a2 + b2), // side length c\r\n                c2 = Math.pow(c, 2), // square root of side length c\r\n                rad = Math.PI / 180,\r\n                // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\r\n                // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\r\n                B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\r\n            if (c === 0) {\r\n                continue;\r\n            }\r\n\r\n            const gp = new Graphics();\r\n            debugDisplayObjects.bones.addChild(gp);\r\n\r\n            // draw bone\r\n            const refRation = c / 50 / scale;\r\n            gp.beginFill(this.bonesColor, 1);\r\n            gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\r\n            gp.endFill();\r\n            gp.x = starX;\r\n            gp.y = starY;\r\n            gp.pivot.y = c;\r\n\r\n            // Calculate bone rotation angle\r\n            let rotation = 0;\r\n            if (starX < endX && starY < endY) {\r\n                // bottom right\r\n                rotation = -B + 180 * rad;\r\n            } else if (starX > endX && starY < endY) {\r\n                // bottom left\r\n                rotation = 180 * rad + B;\r\n            } else if (starX > endX && starY > endY) {\r\n                // top left\r\n                rotation = -B;\r\n            } else if (starX < endX && starY > endY) {\r\n                // bottom left\r\n                rotation = B;\r\n            } else if (starY === endY && starX < endX) {\r\n                // To the right\r\n                rotation = 90 * rad;\r\n            } else if (starY === endY && starX > endX) {\r\n                // go left\r\n                rotation = -90 * rad;\r\n            } else if (starX === endX && starY < endY) {\r\n                // down\r\n                rotation = 180 * rad;\r\n            } else if (starX === endX && starY > endY) {\r\n                // up\r\n                rotation = 0;\r\n            }\r\n            gp.rotation = rotation;\r\n\r\n            // Draw the starting rotation point of the bone\r\n            gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\r\n            gp.beginFill(0x000000, 0.6);\r\n            gp.drawCircle(0, c, refRation * 1.2);\r\n            gp.endFill();\r\n        }\r\n\r\n        // Draw the skeleton starting point \"X\" form\r\n        const startDotSize = lineWidth * 3;\r\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\r\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\r\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\r\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\r\n    }\r\n\r\n    private drawRegionAttachmentsFunc(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i],\r\n                attachment = slot.getAttachment();\r\n            if (attachment == null || attachment.type !== AttachmentType.Region) {\r\n                continue;\r\n            }\r\n\r\n            const regionAttachment = attachment as IRegionAttachment & {\r\n                computeWorldVertices:(slot: unknown, worldVertices: unknown, offset: unknown, stride: unknown) => void,\r\n                updateOffset?:() => void,\r\n            };\r\n\r\n            const vertices = new Float32Array(8);\r\n\r\n\r\n            regionAttachment?.updateOffset(); // We don't need this on all versions\r\n\r\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\r\n            debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\r\n            \r\n        }\r\n    }\r\n\r\n    private drawMeshHullAndMeshTriangles(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\r\n        debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n            if (attachment == null || attachment.type !== AttachmentType.Mesh) {\r\n                continue;\r\n            }\r\n\r\n            const meshAttachment:IMeshAttachment = attachment as IMeshAttachment;\r\n\r\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength),\r\n                triangles = meshAttachment.triangles;\r\n            let hullLength = meshAttachment.hullLength;\r\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\r\n            // draw the skinned mesh (triangle)\r\n            if (this.drawMeshTriangles) {\r\n                for (let i = 0, len = triangles.length; i < len; i += 3) {\r\n                    const v1 = triangles[i] * 2,\r\n                        v2 = triangles[i + 1] * 2,\r\n                        v3 = triangles[i + 2] * 2;\r\n                    debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\r\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\r\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\r\n                }\r\n            }\r\n\r\n            // draw skin border\r\n            if (this.drawMeshHull && hullLength > 0) {\r\n                hullLength = (hullLength >> 1) * 2;\r\n                let lastX = vertices[hullLength - 2],\r\n                    lastY = vertices[hullLength - 1];\r\n                for (let i = 0, len = hullLength; i < len; i += 2) {\r\n                    const x = vertices[i],\r\n                        y = vertices[i + 1];\r\n                    debugDisplayObjects.meshHullLine.moveTo(x, y);\r\n                    debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\r\n                    lastX = x;\r\n                    lastY = y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private drawClippingFunc(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n            if (attachment == null || attachment.type !== AttachmentType.Clipping) {\r\n                continue;\r\n            }\r\n\r\n            const clippingAttachment: IClippingAttachment = attachment as IClippingAttachment;\r\n\r\n            const nn = clippingAttachment.worldVerticesLength,\r\n                world = new Float32Array(nn);\r\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\r\n        }\r\n    }\r\n\r\n    private drawBoundingBoxesFunc(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number): void {\r\n        // draw the total outline of the bounding box\r\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\r\n\r\n        const bounds = new SkeletonBoundsBase();\r\n        bounds.update(spine.skeleton, true);\r\n        debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\r\n\r\n        const polygons = bounds.polygons,\r\n            drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void => {\r\n                debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\r\n                debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\r\n\r\n                if (count < 3) {\r\n                    throw new Error(\"Polygon must contain at least 3 vertices\");\r\n                }\r\n                const paths = [],\r\n                    dotSize = lineWidth * 2;\r\n                for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\r\n                    const x1 = polygonVertices[i],\r\n                        y1 = polygonVertices[i + 1];\r\n\r\n                    // draw the bounding box node\r\n                    debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\r\n                    debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\r\n                    debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\r\n                    debugDisplayObjects.boundingBoxesCircle.endFill();\r\n\r\n                    paths.push(x1, y1);\r\n                }\r\n\r\n                // draw the bounding box area\r\n                debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\r\n                debugDisplayObjects.boundingBoxesPolygon.endFill();\r\n            };\r\n\r\n        for (let i = 0, len = polygons.length; i < len; i++) {\r\n            const polygon = polygons[i];\r\n            drawPolygon(polygon, 0, polygon.length);\r\n        }\r\n    }\r\n\r\n    private drawPathsFunc(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth:number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\r\n        debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n            if (attachment == null || attachment.type !== AttachmentType.Path) {\r\n                continue\r\n            }\r\n\r\n            const pathAttachment = attachment as IVertexAttachment & {closed:boolean};\r\n            let nn = pathAttachment.worldVerticesLength;\r\n            const world = new Float32Array(nn);\r\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            let x1 = world[2],\r\n                y1 = world[3],\r\n                x2 = 0,\r\n                y2 = 0;\r\n            if (pathAttachment.closed) {\r\n                const cx1 = world[0],\r\n                    cy1 = world[1],\r\n                    cx2 = world[nn - 2],\r\n                    cy2 = world[nn - 1];\r\n                x2 = world[nn - 4];\r\n                y2 = world[nn - 3];\r\n\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n            }\r\n            nn -= 4;\r\n            for (let ii = 4; ii < nn; ii += 6) {\r\n                const cx1 = world[ii],\r\n                    cy1 = world[ii + 1],\r\n                    cx2 = world[ii + 2],\r\n                    cy2 = world[ii + 3];\r\n                x2 = world[ii + 4];\r\n                y2 = world[ii + 5];\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n                x1 = x2;\r\n                y1 = y2;\r\n            }\r\n        }\r\n    }\r\n\r\n    public unregisterSpine(spine:SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>):void{\r\n        if (!this.registeredSpines.has(spine)) {\r\n            console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\r\n        }\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n        debugDisplayObjects.parentDebugContainer.destroy({baseTexture:true, children:true, texture:true});\r\n        this.registeredSpines.delete(spine);\r\n    }\r\n}", "import {IResourceMetadata, Loader, LoaderResource} from \"@pixi/loaders\";\r\nimport {BaseTexture, Texture} from \"@pixi/core\";\r\nimport {ISkeletonParser, TextureAtlas} from \"@pixi-spine/base\";\r\nimport {ALPHA_MODES} from \"@pixi/constants\";\r\n\r\nfunction isJson(resource: LoaderResource) {\r\n    return resource.type === LoaderResource.TYPE.JSON;\r\n}\r\n\r\nfunction isBuffer(resource: LoaderResource) {\r\n    return resource.xhrType === (LoaderResource as any).XHR_RESPONSE_TYPE.BUFFER;\r\n}\r\n\r\nLoaderResource.setExtensionXhrType('skel', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AbstractSpineParser {\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(resource: LoaderResource, parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): void;\r\n\r\n    genMiddleware() {\r\n        const self = this;\r\n\r\n        return {\r\n            use(this: Loader, resource: LoaderResource, next: () => any) {\r\n                // skip if no data, its not json, or it isn't atlas data\r\n                if (!resource.data) {\r\n                    return next();\r\n                }\r\n\r\n                const isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n                const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata\r\n                    && (resource.metadata as any).spineMetadata);\r\n\r\n                if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                    return next();\r\n                }\r\n\r\n                let parser: ISkeletonParser = null;\r\n                let dataToParse = resource.data;\r\n\r\n                if (isJsonSpineModel) {\r\n                    parser = self.createJsonParser();\r\n                } else {\r\n                    parser = self.createBinaryParser();\r\n                    if (resource.data instanceof ArrayBuffer) {\r\n                        dataToParse = new Uint8Array(resource.data);\r\n                    }\r\n                }\r\n\r\n                const metadata = (resource.metadata || {}) as IResourceMetadata;\r\n                const metadataSkeletonScale = metadata ? (metadata as any).spineSkeletonScale : null;\r\n\r\n                if (metadataSkeletonScale) {\r\n                    parser.scale = metadataSkeletonScale;\r\n                }\r\n\r\n                const metadataAtlas = metadata.spineAtlas;\r\n                if (metadataAtlas === false) {\r\n                    return next();\r\n                }\r\n                if (metadataAtlas && metadataAtlas.pages) {\r\n                    self.parseData(resource, parser, metadataAtlas, dataToParse);\r\n                    return next();\r\n                }\r\n\r\n                const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n\r\n                /**\r\n                 * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n                 * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n                 * have the same name\r\n                 */\r\n                let atlasPath = resource.url;\r\n                let queryStringPos = atlasPath.indexOf('?');\r\n                if (queryStringPos > 0) {\r\n                    //remove querystring\r\n                    atlasPath = atlasPath.substr(0, queryStringPos)\r\n                }\r\n                atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n// use atlas path as a params. (no need to use same atlas file name with json file name)\r\n                if (metadata.spineAtlasFile) {\r\n                    atlasPath = metadata.spineAtlasFile;\r\n                }\r\n\r\n//remove the baseUrl\r\n                atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n                const atlasOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                    metadata: metadata.spineMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                const imageOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    metadata: metadata.imageMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n//remove the baseUrl\r\n                baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n                const namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n\r\n                const adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                    : metadata.image ? staticImageLoader({'default': metadata.image})\r\n                        : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                            : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n\r\n                function createSkeletonWithRawAtlas(rawData: string) {\r\n                    new TextureAtlas(rawData, adapter, function(spineAtlas) {\r\n                        if (spineAtlas) {\r\n                            self.parseData(resource, parser, spineAtlas, dataToParse);\r\n                        }\r\n                        next();\r\n                    });\r\n                }\r\n\r\n                if (metadata.atlasRawData) {\r\n                    createSkeletonWithRawAtlas(metadata.atlasRawData)\r\n                } else {\r\n                    this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: any) {\r\n                        if (!atlasResource.error) {\r\n                            createSkeletonWithRawAtlas(atlasResource.data);\r\n                        } else {\r\n                            next();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: string, callback: (baseTexture: BaseTexture) => any) {\r\n        const name = namePrefix + line;\r\n        const url = baseUrl + line;\r\n\r\n        const cachedResource = loader.resources[name];\r\n        if (cachedResource) {\r\n            const done = () => {\r\n                callback(cachedResource.texture.baseTexture)\r\n            }\r\n            if (cachedResource.texture) {\r\n                done();\r\n            } else {\r\n                cachedResource.onAfterMiddleware.add(done);\r\n            }\r\n        } else {\r\n            loader.add(name, url, imageOptions, (resource: LoaderResource) => {\r\n                if (!resource.error) {\r\n                    if (line.indexOf('-pma.') >= 0) {\r\n                        resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;\r\n                    }\r\n\r\n                    callback(resource.texture.baseTexture);\r\n                } else {\r\n                    callback(null);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: any, callback: any) {\r\n        callback(BaseTexture.from(line, crossOrigin));\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function staticImageLoader(pages: { [key: string]: (BaseTexture | Texture) }) {\r\n    return function (line: any, callback: any) {\r\n        let page = pages[line] || pages['default'] as any;\r\n        if (page && page.baseTexture)\r\n            callback(page.baseTexture);\r\n        else\r\n            callback(page);\r\n    }\r\n}\r\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "import {AttachmentType, Utils} from '@pixi-spine/base';\r\nimport type {IAttachment, ArrayLike} from '@pixi-spine/base';\r\n\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy (): Attachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    id = (VertexAttachment.nextID++ & 65535) << 11;\r\n    bones: Array<number>;\r\n    vertices: ArrayLike<number>;\r\n    worldVerticesLength = 0;\r\n    deformAttachment: VertexAttachment = this;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n\r\n    /** Transforms local vertices to world coordinates.\r\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n     * @param offset The worldVertices index to begin writing values. */\r\n    computeWorldVertices (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        let skeleton = slot.bone.skeleton;\r\n        let deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        let bones = this.bones;\r\n        if (bones == null) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            let mat = slot.bone.matrix;\r\n            let x = mat.tx;\r\n            let y = mat.ty;\r\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                let vx = vertices[v], vy = vertices[v + 1];\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n            return;\r\n        }\r\n        let v = 0, skip = 0;\r\n        for (let i = 0; i < start; i += 2) {\r\n            let n = bones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        let skeletonBones = skeleton.bones;\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            let deform = deformArray;\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    copyTo (attachment: VertexAttachment) {\r\n        if (this.bones != null) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else\r\n            attachment.bones = null;\r\n\r\n        if (this.vertices != null) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        } else\r\n            attachment.vertices = null;\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.deformAttachment = this.deformAttachment;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new BoundingBoxAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IClippingAttachment} from '@pixi-spine/base';\r\nimport type {SlotData} from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    endSlot: SlotData;\r\n\r\n    // Nonessential.\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new ClippingAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.endSlot = this.endSlot;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IMeshAttachment, TextureRegion, Utils} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion;\r\n    path: string;\r\n    regionUVs: Float32Array;\r\n    triangles: Array<number>;\r\n    color = new Color(1, 1, 1, 1);\r\n    width: number;\r\n    height: number;\r\n    hullLength: number;\r\n    edges: Array<number>;\r\n    private parentMesh: MeshAttachment;\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    getParentMesh () {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh (parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength\r\n        }\r\n    }\r\n\r\n    copy (): Attachment {\r\n        if (this.parentMesh != null) return this.newLinkedMesh();\r\n\r\n        let copy = new MeshAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        // Nonessential.\r\n        if (this.edges != null) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    newLinkedMesh (): MeshAttachment {\r\n        let copy = new MeshAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n        copy.deformAttachment = this.deformAttachment;\r\n        copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n        // copy.updateUVs();\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from \"./Attachment\";\r\nimport {AttachmentType, Color, Utils} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n    lengths: Array<number>;\r\n    closed = false; constantSpeed = false;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PathAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.lengths = new Array<number>(this.lengths.length);\r\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n        copy.closed = closed;\r\n        copy.constantSpeed = this.constantSpeed;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport type {Bone} from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n    x: number; y: number; rotation: number;\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition(bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation(bone: Bone) {\r\n        const mat = bone.matrix;\r\n        let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\r\n        let x = cos * mat.a + sin * mat.c;\r\n        let y = cos * mat.b + sin * mat.d;\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PointAttachment(this.name);\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.rotation = this.rotation;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "\r\nimport {Color, ISlot} from '@pixi-spine/base';\r\n\r\nimport type {Attachment} from './attachments/Attachment';\r\nimport type {Bone} from './Bone';\r\nimport type {SlotData} from './SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Slot implements ISlot {\r\n    //this is canon\r\n    blendMode: number;\r\n    data: SlotData;\r\n    bone: Bone;\r\n    color: Color;\r\n    darkColor: Color;\r\n    attachment: Attachment;\r\n    private attachmentTime: number;\r\n    attachmentState: number;\r\n    deform = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (bone == null) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = data.darkColor == null ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\r\n     * @param attachment May be null. */\r\n    setAttachment (attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.deform.length = 0;\r\n    }\r\n\r\n    setAttachmentTime (time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** Returns the time since the attachment was set. */\r\n    getAttachmentTime (): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\r\n        if (this.data.attachmentName == null)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n", "import {Attachment} from './Attachment';\r\nimport {AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment} from \"@pixi-spine/base\";\r\n\r\nimport type {Bone} from '../Bone';\r\nimport { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\r\n    type = AttachmentType.Region;\r\n\r\n    static OX1 = 0;\r\n    static OY1 = 1;\r\n    static OX2 = 2;\r\n    static OY2 = 3;\r\n    static OX3 = 4;\r\n    static OY3 = 5;\r\n    static OX4 = 6;\r\n    static OY4 = 7;\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n\r\n    x = 0;\r\n    y = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    rotation = 0;\r\n    width = 0;\r\n    height = 0;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    path: string;\r\n    rendererObject: any;\r\n    region: TextureRegion;\r\n\r\n    offset = Utils.newFloatArray(8);\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    updateOffset(): void {\r\n        let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n        let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n        let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n        let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n        let localX2 = localX + this.region.width * regionScaleX;\r\n        let localY2 = localY + this.region.height * regionScaleY;\r\n        let radians = this.rotation * Math.PI / 180;\r\n        let cos = Math.cos(radians);\r\n        let sin = Math.sin(radians);\r\n        let localXCos = localX * cos + this.x;\r\n        let localXSin = localX * sin;\r\n        let localYCos = localY * cos + this.y;\r\n        let localYSin = localY * sin;\r\n        let localX2Cos = localX2 * cos + this.x;\r\n        let localX2Sin = localX2 * sin;\r\n        let localY2Cos = localY2 * cos + this.y;\r\n        let localY2Sin = localY2 * sin;\r\n        let offset = this.offset;\r\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n    }\r\n\r\n    setRegion(region: TextureRegion): void {\r\n        this.region = region;\r\n        let uvs = this.uvs;\r\n        if (region.rotate) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        let vertexOffset = this.offset;\r\n        let mat = bone instanceof Slot? bone.bone.matrix : bone.matrix;\r\n        let x = mat.tx, y = mat.ty;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let offsetX = 0, offsetY = 0;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX1];\r\n        offsetY = vertexOffset[RegionAttachment.OY1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX2];\r\n        offsetY = vertexOffset[RegionAttachment.OY2];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX3];\r\n        offsetY = vertexOffset[RegionAttachment.OY3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX4];\r\n        offsetY = vertexOffset[RegionAttachment.OY4];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new RegionAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.rendererObject = this.rendererObject;\r\n        copy.path = this.path;\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.scaleX = this.scaleX;\r\n        copy.scaleY = this.scaleY;\r\n        copy.rotation = this.rotation;\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class JitterEffect implements VertexEffect {\r\n    jitterX = 0;\r\n    jitterY = 0;\r\n\r\n    constructor (jitterX: number, jitterY: number) {\r\n        this.jitterX = jitterX;\r\n        this.jitterY = jitterY;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n    }\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n", "import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, PowOut, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SwirlEffect implements VertexEffect {\r\n    static interpolation = new PowOut(2);\r\n    centerX = 0;\r\n    centerY = 0;\r\n    radius = 0;\r\n    angle = 0;\r\n    private worldX = 0;\r\n    private worldY = 0;\r\n\r\n    constructor (radius: number) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n        this.worldX = skeleton.x + this.centerX;\r\n        this.worldY = skeleton.y + this.centerY;\r\n    }\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        let radAngle = this.angle * MathUtils.degreesToRadians;\r\n        let x = position.x - this.worldX;\r\n        let y = position.y - this.worldY;\r\n        let dist = Math.sqrt(x * x + y * y);\r\n        if (dist < this.radius) {\r\n            let theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n            let cos = Math.cos(theta);\r\n            let sin = Math.sin(theta);\r\n            position.x = cos * x - sin * y + this.worldX;\r\n            position.y = sin * x + cos * y + this.worldY;\r\n        }\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n", "import {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport {Attachment, VertexAttachment} from \"./attachments\";\r\nimport {ArrayLike, MathUtils, Utils, MixBlend, MixDirection} from '@pixi-spine/base';\r\nimport {Slot} from \"./Slot\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\n/** A simple container for a list of timelines and a name. */\r\n/**\r\n * @public\r\n */\r\nexport class Animation {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    timelineIds: Array<boolean>;\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.timelineIds = [];\r\n        for (var i = 0; i < timelines.length; i++)\r\n            this.timelineIds[timelines[i].getPropertyId()] = true;\r\n        this.duration = duration;\r\n    }\r\n\r\n    hasTimeline (id: number) {\r\n        return this.timelineIds[id] == true;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n\r\n    /** @param target After the first and before the last value.\r\n     * @returns index of first value greater than the target. */\r\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target)\r\n                low = current + 1;\r\n            else\r\n                high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step)\r\n            if (values[i] > target) return i;\r\n        return -1;\r\n    }\r\n}\r\n\r\n/** The interface for all timelines. */\r\n/**\r\n * @public\r\n */\r\nexport interface Timeline {\r\n    /** Applies this timeline to the skeleton.\r\n     * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\r\n     *           skeleton components the timeline may change.\r\n     * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\r\n     *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\r\n     *           (exclusive) and `time` (inclusive).\r\n     * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\r\n     *           interpolate between the keys.\r\n     * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\r\n     *           does not fire events.\r\n     * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\r\n     *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\r\n     *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\r\n     *           apply animations on top of each other (layering).\r\n     * @param blend Controls how mixing is applied when `alpha` < 1.\r\n     * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\r\n     *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\r\n    getPropertyId (): number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TimelineType {\r\n    rotate, translate, scale, shear,\r\n    attachment, color, deform,\r\n    event, drawOrder,\r\n    ikConstraint, transformConstraint,\r\n    pathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\r\n    twoColor\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values. */\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    abstract getPropertyId(): number;\r\n\r\n    constructor (frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount () {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    /** Returns the interpolation type for the specified key frame.\r\n     * @returns Linear is 0, stepped is 1, Bezier is 2. */\r\n    getCurveType (frameIndex: number): number {\r\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        let type = this.curves[index];\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\r\n     * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\r\n     * difference between the key frame's values. */\r\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let curves = this.curves;\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx, y = dfy;\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    /** Returns the interpolated percentage for the specified key frame and linear percentage. */\r\n    getCurvePercent (frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        let curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let type = curves[i];\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number, prevY: number;\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        let y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}. */\r\n/**\r\n * @public\r\n */\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds and rotation in degrees for each key frame. */\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.rotate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, degrees: number) {\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                    return;\r\n                case MixBlend.first:\r\n                    let r = bone.data.rotation - bone.rotation;\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\r\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + r * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n                case MixBlend.add:\r\n                    bone.rotation += r * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent((frame >> 1) - 1,\r\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\r\n/**\r\n * @public\r\n */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\r\n    static X = 1; static Y = 2;\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds, x, and y values for each key frame. */\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.translate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, x, and y values for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + TranslateTimeline.PREV_X];\r\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n            x = frames[frame + TranslateTimeline.PREV_X];\r\n            y = frames[frame + TranslateTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.scale << 24) + this.boneIndex;\r\n    }\r\n\r\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n            x = frames[frame + ScaleTimeline.PREV_X];\r\n            y = frames[frame + ScaleTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n        }\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0, by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.shear << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + ShearTimeline.PREV_X];\r\n            y = frames[frames.length + ShearTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n            x = frames[frame + ShearTimeline.PREV_X];\r\n            y = frames[frame + ShearTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}. */\r\n/**\r\n * @public\r\n */\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\r\n    static R = 1; static G = 2; static B = 3; static A = 4;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.color << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    return;\r\n                case MixBlend.first:\r\n                    let color = slot.color, setup = slot.data.color;\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\r\n                        (setup.a - color.a) * alpha);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0;\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        if (alpha == 1)\r\n            slot.color.set(r, g, b, a);\r\n        else {\r\n            let color = slot.color;\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\r\n/**\r\n * @public\r\n */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 8;\r\n    static PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\r\n    static PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\r\n    static R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\r\n     * null. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.twoColor << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frameIndex *= TwoColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    slot.darkColor.setFromColor(slot.data.darkColor);\r\n                    return;\r\n                case MixBlend.first:\r\n                    let light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\r\n                        (setupLight.a - light.a) * alpha);\r\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            r = frames[i + TwoColorTimeline.PREV_R];\r\n            g = frames[i + TwoColorTimeline.PREV_G];\r\n            b = frames[i + TwoColorTimeline.PREV_B];\r\n            a = frames[i + TwoColorTimeline.PREV_A];\r\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n            r = frames[frame + TwoColorTimeline.PREV_R];\r\n            g = frames[frame + TwoColorTimeline.PREV_G];\r\n            b = frames[frame + TwoColorTimeline.PREV_B];\r\n            a = frames[frame + TwoColorTimeline.PREV_A];\r\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n        }\r\n        if (alpha == 1) {\r\n            slot.color.set(r, g, b, a);\r\n            slot.darkColor.set(r2, g2, b2, 1);\r\n        } else {\r\n            let light = slot.color, dark = slot.darkColor;\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                dark.setFromColor(slot.data.darkColor);\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class AttachmentTimeline implements Timeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number> // time, ...\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.attachment << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup)\r\n                this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        let frameIndex = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        let attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex]\r\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nlet zeros : ArrayLike<number> = null;\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class DeformTimeline extends CurveTimeline {\r\n    /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The vertices for each key frame. */\r\n    frameVertices: Array<ArrayLike<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n        if (zeros == null) zeros = Utils.newFloatArray(64);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot: Slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let slotAttachment: Attachment = slot.getAttachment();\r\n        if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\r\n\r\n        let deformArray: Array<number> = slot.deform;\r\n        if (deformArray.length == 0) blend = MixBlend.setup;\r\n\r\n        let frameVertices = this.frameVertices;\r\n        let vertexCount = frameVertices[0].length;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            let vertexAttachment = <VertexAttachment>slotAttachment;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deformArray.length = 0;\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deformArray.length = 0;\r\n                        break;\r\n                    }\r\n                    let deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] *= alpha;\r\n                    }\r\n            }\r\n            return;\r\n        }\r\n\r\n        let deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n            let lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += lastVertices[i];\r\n                    }\r\n                } else {\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let setup = setupVertices[i];\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time);\r\n        let prevVertices = frameVertices[frame - 1];\r\n        let nextVertices = frameVertices[frame];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                let vertexAttachment = slotAttachment as VertexAttachment;\r\n                if (vertexAttachment.bones == null) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    let setupVertices = vertexAttachment.vertices;\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    let prev = prevVertices[i];\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i], setup = setupVertices[i];\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached. */\r\n/**\r\n * @public\r\n */\r\nexport class EventTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return TimelineType.event << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame (frameIndex: number, event: Event) {\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (firedEvents == null) return;\r\n        let frames = this.frames;\r\n        let frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n        if (lastTime < frames[0])\r\n            frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            let frameTime = frames[frame];\r\n            while (frame > 0) { // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++)\r\n            firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\r\n/**\r\n * @public\r\n */\r\nexport class DrawOrderTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return TimelineType.drawOrder << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        let slots: Array<Slot> = skeleton.slots;\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let frame = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else\r\n            frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        let drawOrderToSetupIndex = this.drawOrders[frame];\r\n        if (drawOrderToSetupIndex == null)\r\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 6;\r\n    static PREV_TIME = -6; static PREV_MIX = -5; static PREV_SOFTNESS = -4; static PREV_BEND_DIRECTION = -3; static PREV_COMPRESS = -2; static PREV_STRETCH = -1;\r\n    static MIX = 1; static SOFTNESS = 2; static BEND_DIRECTION = 3; static COMPRESS = 4; static STRETCH = 5;\r\n\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number;\r\n\r\n    /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\r\n    frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            if (blend == MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                constraint.softness = constraint.data.softness\r\n                    + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                if (direction == MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                } else {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            } else {\r\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                if (direction == MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        let softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n            constraint.softness = constraint.data.softness\r\n                + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n            constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\r\n\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            let data = constraint.data;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate = 0, translate = 0, scale = 0, shear = 0;\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds and path constraint position for each key frame. */\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and path constraint position for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, value: number) {\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let position = 0;\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\r\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\r\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n        }\r\n        if (blend == MixBlend.setup)\r\n            constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else\r\n            constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let spacing = 0;\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\r\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\r\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else\r\n            constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\r\n * {@link TransformConstraint#translateMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = constraint.data.rotateMix;\r\n                    constraint.translateMix = constraint.data.translateMix;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate = 0, translate = 0;\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\r\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\r\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n        }\r\n    }\r\n}\r\n", "import {\r\n    IAnimationState,\r\n    IAnimationStateListener,\r\n    ITrackEntry,\r\n    MixBlend,\r\n    MixDirection,\r\n    MathUtils,\r\n    Pool,\r\n    IntSet,\r\n    Utils\r\n} from \"@pixi-spine/base\";\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    RotateTimeline, Timeline\r\n} from './Animation';\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport type {Slot} from \"./Slot\";\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\r\n/**\r\n * @public\r\n */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static emptyAnimation = new Animation(\"<empty>\", [], 0);\r\n\r\n    /** 1. A previously applied timeline has set this property.\r\n     *\r\n     * Result: Mix from the current pose to the timeline pose. */\r\n    static SUBSEQUENT = 0;\r\n    /** 1. This is the first timeline to set this property.\r\n     * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n     *\r\n     * Result: Mix from the setup pose to the timeline pose. */\r\n    static FIRST = 1;\r\n    /** 1) A previously applied timeline has set this property.<br>\r\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n     * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n     * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\n    static HOLD_SUBSEQUENT = 2;\r\n    /** 1) This is the first timeline to set this property.<br>\r\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n     * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n     * that key the same property. A subsequent timeline will set this property using a mix. */\r\n    static HOLD_FIRST = 3;\r\n    /** 1. This is the first timeline to set this property.\r\n     * 2. The next track entry to be applied does have a timeline to set this property.\r\n     * 3. The next track entry after that one does have a timeline to set this property.\r\n     * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n     *\r\n     * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n     * 2 track entries in a row have a timeline that sets the same property.\r\n     *\r\n     * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n     * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n     * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n     * place. */\r\n    static HOLD_MIX = 4;\r\n\r\n    static SETUP = 1;\r\n    static CURRENT = 2;\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new IntSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor (data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (current == null) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n            if (next != null) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                let nextTime = current.trackLast - next.delay;\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom != null) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from = current.mixingFrom;\r\n                current.mixingFrom = null;\r\n                if (from != null) from.mixingTo = null;\r\n                while (from != null) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom (to: TrackEntry, delta: number): boolean {\r\n        let from = to.mixingFrom;\r\n        if (from == null) return true;\r\n\r\n        let finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply (skeleton: Skeleton) : boolean {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        let events = this.events;\r\n        let tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (current == null || current.delay > 0) continue;\r\n            applied = true;\r\n            let blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n            if (current.mixingFrom != null)\r\n                mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && current.next == null)\r\n                mix = 0;\r\n\r\n            // Apply current entry.\r\n            let animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n            let timelineCount = current.animation.timelines.length;\r\n            let timelines = current.animation.timelines;\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    var timeline = timelines[ii];\r\n                    if (timeline instanceof AttachmentTimeline)\r\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                    else\r\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                let timelineMode = current.timelineMode;\r\n\r\n                let firstFrame = current.timelinesRotation.length == 0;\r\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                let timelinesRotation = current.timelinesRotation;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    let timeline = timelines[ii];\r\n                    let timelineBlend = timelineMode[ii]  == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\r\n                    if (timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        var setupState = this.unkeyedState + AnimationState.SETUP;\r\n        var slots = skeleton.slots;\r\n        for (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            var slot = slots[i];\r\n            if (slot.attachmentState == setupState) {\r\n                var attachmentName = slot.data.attachmentName;\r\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        let from = to.mixingFrom;\r\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n        if (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        let events = mix < from.eventThreshold ? this.events : null;\r\n        let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n        let animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n        let timelineCount = from.animation.timelines.length;\r\n        let timelines = from.animation.timelines;\r\n        let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++)\r\n                timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            let timelineMode = from.timelineMode;\r\n            let timelineHoldMix = from.timelineHoldMix;\r\n\r\n            let firstFrame = from.timelinesRotation.length == 0;\r\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n            let timelinesRotation = from.timelinesRotation;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                let timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n                switch (timelineMode[i]) {\r\n                    case AnimationState.SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case AnimationState.HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        let holdMix = timelineHoldMix[i];\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline)\r\n                    this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\r\n                        direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n\r\n        var slot = skeleton.slots[timeline.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        var frames = timeline.frames;\r\n        if (time < frames[0]) { // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        }\r\n        else {\r\n            var frameIndex;\r\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n                frameIndex = frames.length - 1;\r\n            else\r\n                frameIndex = Animation.binarySearch(frames, time) - 1;\r\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\r\n        }\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\r\n    }\r\n\r\n    setAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\r\n    }\r\n\r\n\r\n    applyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\r\n                         timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n            return;\r\n        }\r\n\r\n        let rotateTimeline = timeline as RotateTimeline;\r\n        let frames = rotateTimeline.frames;\r\n        let bone = skeleton.bones[rotateTimeline.boneIndex];\r\n        if (!bone.active) return;\r\n        let r1 = 0, r2 = 0;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\r\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n            else {\r\n                // Interpolate between the previous frame and the current frame.\r\n                let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n                let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n                let frameTime = frames[frame];\r\n                let percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\r\n                    1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n            }\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0, diff = r2 - r1;\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0, lastDiff = 0;\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            let current = diff > 0, dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        r1 += total * alpha;\r\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n    }\r\n\r\n    queueEvents (entry: TrackEntry, animationTime: number) {\r\n        let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n        let duration = animationEnd - animationStart;\r\n        let trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        let events = this.events;\r\n        let i = 0, n = events.length;\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n        if (entry.loop)\r\n            complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else\r\n            complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, events[i]);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks () {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (current == null) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.disposeNext(current);\r\n\r\n        let entry = current;\r\n        while (true) {\r\n            let from = entry.mixingFrom;\r\n            if (from == null) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\r\n        let from = this.expandToIndex(index);\r\n        this.tracks[index] = current;\r\n\r\n        if (from != null) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom != null && from.mixDuration > 0)\r\n                current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * {@link #setAnimationWith(}. */\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\r\n        if (animation == null) throw new Error(\"animation cannot be null.\");\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current != null) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else\r\n                this.disposeNext(current);\r\n        }\r\n        let entry = this.trackEntry(trackIndex, animation, loop, current);\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n        if (animation == null) throw new Error(\"animation cannot be null.\");\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last != null) {\r\n            while (last.next != null)\r\n                last = last.next;\r\n        }\r\n\r\n        let entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (last == null) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            if (delay <= 0) {\r\n                let duration = last.animationEnd - last.animationStart;\r\n                if (duration != 0) {\r\n                    if (last.loop)\r\n                        delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                    else\r\n                        delay += Math.max(duration, last.trackTime);\r\n                    delay -= this.data.getMix(last.animation, animation);\r\n                } else\r\n                    delay = last.trackTime;\r\n            }\r\n        }\r\n\r\n        entry.delay = delay;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation (trackIndex: number, mixDuration: number) {\r\n        let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\r\n        if (delay <= 0) delay -= mixDuration;\r\n        let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations (mixDuration: number) {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let current = this.tracks[i];\r\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\r\n        let entry = this.trackEntryPool.obtain();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.interruptAlpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n        entry.mixBlend = MixBlend.replace;\r\n        return entry;\r\n    }\r\n\r\n    disposeNext (entry: TrackEntry) {\r\n        let next = entry.next;\r\n        while (next != null) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged () {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let entry = this.tracks[i];\r\n            if (entry == null) continue;\r\n            while (entry.mixingFrom != null)\r\n                entry = entry.mixingFrom;\r\n\r\n            do {\r\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry != null)\r\n        }\r\n    }\r\n\r\n    computeHold (entry: TrackEntry) {\r\n        let to = entry.mixingTo;\r\n        let timelines = entry.animation.timelines;\r\n        let timelinesCount = entry.animation.timelines.length;\r\n        let timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n        entry.timelineHoldMix.length = 0;\r\n        let timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n        let propertyIDs = this.propertyIDs;\r\n\r\n        if (to != null && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\r\n            }\r\n            return;\r\n        }\r\n\r\n        outer:\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                let timeline = timelines[i];\r\n                let id = timeline.getPropertyId();\r\n                if (!propertyIDs.add(id))\r\n                    timelineMode[i] = AnimationState.SUBSEQUENT;\r\n                else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\r\n                    || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {\r\n                    timelineMode[i] = AnimationState.FIRST;\r\n                } else {\r\n                    for (let next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                        if (next.animation.hasTimeline(id)) continue;\r\n                        if (entry.mixDuration > 0) {\r\n                            timelineMode[i] = AnimationState.HOLD_MIX;\r\n                            timelineDipMix[i] = next;\r\n                            continue outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                    timelineMode[i] = AnimationState.HOLD_FIRST;\r\n                }\r\n            }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener (listener: AnimationStateListener) {\r\n        if (listener == null) throw new Error(\"listener cannot be null.\");\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener (listener: AnimationStateListener) {\r\n        let index = this.listeners.indexOf(listener);\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners () {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications () {\r\n        this.queue.clear();\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\r\n/**\r\n * @public\r\n */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex: number;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop: boolean;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious: boolean;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold: number;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart: number;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd: number;\r\n\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast: number;\r\n\r\n    nextAnimationLast: number;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay: number;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime: number;\r\n\r\n    trackLast: number; nextTrackLast: number;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd: number;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale: number;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha: number;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime: number;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration: number; interruptAlpha: number; totalAlpha: number;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset () {\r\n        this.next = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime () {\r\n        if (this.loop) {\r\n            let duration = this.animationEnd - this.animationStart;\r\n            if (duration == 0) return this.animationStart;\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete () {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections () {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start (entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n\r\n    deprecateStuff() {\r\n        if (!EventQueue.deprecatedWarning1) {\r\n            EventQueue.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    drain () {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        let objects = this.objects;\r\n        let listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            let type = objects[i] as EventType;\r\n            let entry = objects[i + 1] as TrackEntry;\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].start) listeners[ii].start(entry);\r\n                    //deprecation\r\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\r\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].end) listeners[ii].end(entry);\r\n                    //deprecation\r\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\r\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].dispose) listeners[ii].dispose(entry);\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].complete) listeners[ii].complete(entry);\r\n                    //deprecation\r\n\r\n                    let count = MathUtils.toInt(entry.loopsCount()) ;\r\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\r\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\r\n                    break;\r\n                case EventType.event:\r\n                    let event = objects[i++ + 2] as Event;\r\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].event) listeners[ii].event(entry, event);\r\n                    //deprecation\r\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\r\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear () {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start, interrupt, end, dispose, complete, event\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose? (entry: TrackEntry): void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event? (entry: TrackEntry, event: Event): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start (entry: TrackEntry) {\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n    }\r\n}\r\n", "import {SkeletonData} from \"./SkeletonData\";\r\nimport {IAnimation, IAnimationStateData, Map} from '@pixi-spine/base';\r\nimport type { Animation } from \"./Animation\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\r\n    skeletonData: SkeletonData;\r\n    animationToMixTime: Map<number> = {};\r\n    defaultMix = 0;\r\n\r\n    constructor(skeletonData: SkeletonData) {\r\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    setMix(fromName: string, toName: string, duration: number) {\r\n        let from = this.skeletonData.findAnimation(fromName);\r\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\r\n        let to = this.skeletonData.findAnimation(toName);\r\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setMixByName(fromName: string, toName: string, duration: number) {\r\n        if (!AnimationStateData.deprecatedWarning1) {\r\n            AnimationStateData.deprecatedWarning1 = true;\r\n            console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\r\n        }\r\n        this.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    setMixWith(from: IAnimation, to: IAnimation, duration: number) {\r\n        if (from == null) throw new Error(\"from cannot be null.\");\r\n        if (to == null) throw new Error(\"to cannot be null.\");\r\n        let key = from.name + \".\" + to.name;\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    getMix(from: IAnimation, to: IAnimation) {\r\n        let key = from.name + \".\" + to.name;\r\n        let value = this.animationToMixTime[key];\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n", "import {AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment,\r\n    PathAttachment, PointAttachment, ClippingAttachment} from './attachments';\r\nimport type {TextureAtlas} from \"@pixi-spine/base\";\r\nimport type {Skin} from \"./Skin\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor(atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n        let attachment = new RegionAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n        let attachment = new MeshAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    /** @return May be null to not load an attachment */\r\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n", "import {Matrix} from '@pixi/math';\r\nimport {Updatable} from \"./Updatable\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {IBone, MathUtils, settings, TransformMode, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Bone implements Updatable, IBone {\r\n    //be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    data: BoneData;\r\n    skeleton: Skeleton;\r\n    parent: Bone;\r\n    children = new Array<Bone>();\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 0;\r\n    scaleY = 0;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    ax = 0;\r\n    ay = 0;\r\n    arotation = 0;\r\n    ascaleX = 0;\r\n    ascaleY = 0;\r\n    ashearX = 0;\r\n    ashearY = 0;\r\n    appliedValid = false;\r\n\r\n    sorted = false;\r\n    active = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\r\n    update() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform. */\r\n    updateWorldTransform() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. */\r\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n        this.appliedValid = true;\r\n\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n\r\n        let sx = this.skeleton.scaleX;\r\n        let sy = settings.yDown? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n\r\n        if (parent == null) { // Root bone.\r\n            let skeleton = this.skeleton;\r\n            let rotationY = rotation + 90 + shearY;\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pa /= this.skeleton.scaleX;\r\n                    pc /= this.skeleton.scaleY;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                let rx = rotation + shearX - prx;\r\n                let ry = rotation + shearY - prx + 90;\r\n                let la = MathUtils.cosDeg(rx) * scaleX;\r\n                let lb = MathUtils.cosDeg(ry) * scaleY;\r\n                let lc = MathUtils.sinDeg(rx) * scaleX;\r\n                let ld = MathUtils.sinDeg(ry) * scaleY;\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                let cos = MathUtils.cosDeg(rotation);\r\n                let sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (\r\n                    this.data.transformMode == TransformMode.NoScale\r\n                    && (pa * pd - pb * pc < 0) != (settings.yDown?\r\n                    (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\r\n                        (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\r\n                ) s = -s;\r\n                let r = Math.PI / 2 + Math.atan2(zc, za);\r\n                let zb = Math.cos(r) * s;\r\n                let zd = Math.sin(r) * s;\r\n                let la = MathUtils.cosDeg(shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                let lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    setToSetupPose() {\r\n        let data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    getWorldRotationX() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldRotationY() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldScaleX() {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.a * m.a + m.c * m.c);\r\n    }\r\n\r\n    getWorldScaleY() {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.b * m.b + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\r\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\r\n     * <p>\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\r\n    updateAppliedTransform() {\r\n        this.appliedValid = true;\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (parent == null) {\r\n            this.ax = m.tx;\r\n            this.ay = m.ty;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n            return;\r\n        }\r\n        let pm = parent.matrix;\r\n        let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n        this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n        this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n        let ia = pid * pm.d;\r\n        let id = pid * pm.a;\r\n        let ib = pid * pm.c;\r\n        let ic = pid * pm.b;\r\n        let ra = ia * m.a - ib * m.b;\r\n        let rb = ia * m.c - ib * m.d;\r\n        let rc = id * m.b - ic * m.a;\r\n        let rd = id * m.d - ic * m.c;\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            let det = ra * rd - rb * rc;\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    worldToLocal(world: Vector2) {\r\n        let m = this.matrix;\r\n        let a = m.a, b = m.c, c = m.b, d = m.d;\r\n        let invDet = 1 / (a * d - b * c);\r\n        let x = world.x - m.tx, y = world.y - m.ty;\r\n        world.x = (x * d * invDet - y * b * invDet);\r\n        world.y = (y * a * invDet - x * c * invDet);\r\n        return world;\r\n    }\r\n\r\n    localToWorld(local: Vector2) {\r\n        let m = this.matrix;\r\n        let x = local.x, y = local.y;\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n        return local;\r\n    }\r\n\r\n    worldToLocalRotation (worldRotation: number) {\r\n        let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    localToWorldRotation (localRotation: number) {\r\n        let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    rotateWorld (degrees: number) {\r\n        let mat = this.matrix;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n        this.appliedValid = false;\r\n    }\r\n}\r\n", "import {Color, TransformMode} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: BoneData;\r\n    length: number;\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    transformMode = TransformMode.Normal;\r\n    skinRequired = false;\r\n\r\n    color = new Color();\r\n\r\n    constructor(index: number, name: string, parent: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n", "/**\r\n * @public\r\n */\r\nexport abstract class ConstraintData {\r\n    constructor(public name: string, public order: number, public skinRequired: boolean) { }\r\n}\r\n", "import {EventData} from \"./EventData\";\r\nimport {IEvent} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Event implements IEvent {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n    volume: number;\r\n    balance: number;\r\n\r\n\r\n    constructor(time: number, data: EventData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n", "import {IEventData} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventData implements IEventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    audioPath: string;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n", "import {Updatable} from \"./Updatable\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {IIkConstraint, MathUtils, TransformMode} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraint implements IIkConstraint, Updatable {\r\n    data: IkConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    bendDirection = 0;\r\n    compress = false;\r\n    stretch = false;\r\n    mix = 1;\r\n    softness = 0;\r\n    active = false;\r\n\r\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.softness = data.softness;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let target = this.target;\r\n        let bones = this.bones;\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n     * coordinate system. */\r\n    apply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        if (!bone.appliedValid) bone.updateAppliedTransform();\r\n        let p = bone.parent.matrix;\r\n\r\n\r\n        let pa = p.a, pb = p.c, pc = p.b, pd = p.d;\r\n        let rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n\r\n        switch(bone.data.transformMode) {\r\n            case TransformMode.OnlyTranslation:\r\n                tx = targetX - bone.worldX;\r\n                ty = targetY - bone.worldY;\r\n                break;\r\n            case TransformMode.NoRotationOrReflection:\r\n                let s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                let sa = pa / bone.skeleton.scaleX;\r\n                let sc = pc / bone.skeleton.scaleY;\r\n                pb = -sc * s * bone.skeleton.scaleX;\r\n                pd = sa * s * bone.skeleton.scaleY;\r\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n            // Fall through\r\n            default:\r\n                let x = targetX - p.tx, y = targetY - p.ty;\r\n                let d = pa * pd - pb * pc;\r\n                tx = (x * pd - y * pb) / d - bone.ax;\r\n                ty = (y * pa - x * pc) / d - bone.ay;\r\n        }\r\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180) rotationIK += 360;\r\n        let sx = bone.ascaleX, sy = bone.ascaleY;\r\n        if (compress || stretch) {\r\n            switch (bone.data.transformMode) {\r\n                case TransformMode.NoScale:\r\n                case TransformMode.NoScaleOrReflection:\r\n                    tx = targetX - bone.worldX;\r\n                    ty = targetY - bone.worldY;\r\n            }\r\n            let b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                let s = (dd / b - 1) * alpha + 1;\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\r\n            bone.ashearY);\r\n    }\r\n\r\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n     * target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\r\n        if (alpha == 0) {\r\n            child.updateWorldTransform();\r\n            return;\r\n        }\r\n        if (!parent.appliedValid) parent.updateAppliedTransform();\r\n        if (!child.appliedValid) child.updateAppliedTransform();\r\n        let px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n        let pmat = parent.matrix;\r\n        let os1 = 0, os2 = 0, s2 = 0;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else\r\n            os2 = 0;\r\n        let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n        let u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        let pp = parent.parent.matrix;\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        let id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\r\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n        if (l1 < 0.0001) {\r\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n            return;\r\n        }\r\n        x = targetX - pp.tx;\r\n        y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n        let dd = tx * tx + ty * ty;\r\n        if (softness != 0) {\r\n            softness *= psx * (csx + 1) / 2;\r\n            let td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n            if (sd > 0) {\r\n                let p = Math.min(1, sd / (softness * 2)) - 1;\r\n                p = (sd - softness * (1 - p * p)) / td;\r\n                tx -= p * tx;\r\n                ty -= p * ty;\r\n                dd = tx * tx + ty * ty;\r\n            }\r\n        }\r\n        outer:\r\n            if (u) {\r\n                l2 *= psx;\r\n                let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                if (cos < -1)\r\n                    cos = -1;\r\n                else if (cos > 1) {\r\n                    cos = 1;\r\n                    if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                }\r\n                a2 = Math.acos(cos) * bendDir;\r\n                a = l1 + l2 * cos;\r\n                b = l2 * Math.sin(a2);\r\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n            } else {\r\n                a = psx * l2;\r\n                b = psy * l2;\r\n                let aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                let c1 = -2 * bb * l1, c2 = bb - aa;\r\n                d = c1 * c1 - 4 * c2 * c;\r\n                if (d >= 0) {\r\n                    let q = Math.sqrt(d);\r\n                    if (c1 < 0) q = -q;\r\n                    q = -(c1 + q) / 2;\r\n                    let r0 = q / c2, r1 = c / q;\r\n                    let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                    if (r * r <= dd) {\r\n                        y = Math.sqrt(dd - r * r) * bendDir;\r\n                        a1 = ta - Math.atan2(y, r);\r\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                        break outer;\r\n                    }\r\n                }\r\n                let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                c = -a * l1 / (aa - bb);\r\n                if (c >= -1 && c <= 1) {\r\n                    c = Math.acos(c);\r\n                    x = a * Math.cos(c) + l1;\r\n                    y = b * Math.sin(c);\r\n                    d = x * x + y * y;\r\n                    if (d < minDist) {\r\n                        minAngle = c;\r\n                        minDist = d;\r\n                        minX = x;\r\n                        minY = y;\r\n                    }\r\n                    if (d > maxDist) {\r\n                        maxAngle = c;\r\n                        maxDist = d;\r\n                        maxX = x;\r\n                        maxY = y;\r\n                    }\r\n                }\r\n                if (dd <= (minDist + maxDist) / 2) {\r\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                    a2 = minAngle * bendDir;\r\n                } else {\r\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                    a2 = maxAngle * bendDir;\r\n                }\r\n            }\r\n        let os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180) a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180) a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n", "import {ConstraintData} from \"./Constraint\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {IIkConstraintData} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintData extends ConstraintData implements IIkConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    bendDirection = 1;\r\n    compress = false;\r\n    stretch = false;\r\n    uniform = false;\r\n    mix = 1;\r\n    softness = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n", "import {ConstraintData} from \"./Constraint\";\r\nimport type {SlotData} from \"./SlotData\";\r\nimport type {BoneData} from \"./BoneData\";\r\nimport { RotateMode, PositionMode } from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintData extends ConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: SlotData;\r\n    positionMode: PositionMode;\r\n    spacingMode: SpacingMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number; spacing: number; rotateMix: number; translateMix: number;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n/**\r\n * @public\r\n */\r\nexport enum SpacingMode {\r\n    Length, Fixed, Percent\r\n}\r\n", "import {PathAttachment} from \"./attachments\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {PathConstraintData, SpacingMode} from \"./PathConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, PositionMode, RotateMode, Utils} from \"@pixi-spine/base\";\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    data: PathConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Slot;\r\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\r\n\r\n    spaces = new Array<number>(); positions = new Array<number>();\r\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    active = false;\r\n\r\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findSlot(data.target.name);\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let attachment = this.target.getAttachment();\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n        let translate = translateMix > 0, rotate = rotateMix > 0;\r\n        if (!translate && !rotate) return;\r\n\r\n        let data = this.data;\r\n        let spacingMode = data.spacingMode;\r\n        let lengthSpacing = spacingMode == SpacingMode.Length;\r\n        let rotateMode = data.rotateMode;\r\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\r\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n        let bones = this.bones;\r\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\r\n        let spacing = this.spacing;\r\n        if (scale || lengthSpacing) {\r\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n            for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                let bone = bones[i];\r\n                let setupLength = bone.data.length;\r\n                if (setupLength < PathConstraint.epsilon) {\r\n                    if (scale) lengths[i] = 0;\r\n                    spaces[++i] = 0;\r\n                } else {\r\n                    let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                    let length = Math.sqrt(x * x + y * y);\r\n                    if (scale) lengths[i] = length;\r\n                    spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 1; i < spacesCount; i++)\r\n                spaces[i] = spacing;\r\n        }\r\n\r\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\r\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\r\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n        if (offsetRotation == 0)\r\n            tip = rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            let p = this.target.bone.matrix;\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            let bone = bones[i];\r\n            let mat = bone.matrix;\r\n            mat.tx += (boneX - mat.tx) * translateMix;\r\n            mat.ty += (boneY - mat.ty) * translateMix;\r\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n            if (scale) {\r\n                let length = lengths[i];\r\n                if (length != 0) {\r\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (rotate) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                if (tangents)\r\n                    r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0)\r\n                    r = positions[p + 2];\r\n                else\r\n                    r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    let length = bone.data.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\r\n                           percentSpacing: boolean) {\r\n        let target = this.target;\r\n        let position = this.position;\r\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n        let closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            let lengths = path.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            let pathLength = lengths[curveCount];\r\n            if (percentPosition) position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (let i = 0; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i];\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (;; curve++) {\r\n                    let length = lengths[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else\r\n                        path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                    tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        let curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        if (percentPosition) position *= pathLength;\r\n        if (percentSpacing) {\r\n            for (let i = 0; i < spacesCount; i++)\r\n                spaces[i] *= pathLength;\r\n        }\r\n\r\n        let segments = this.segments;\r\n        let curveLength = 0;\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            let space = spaces[i];\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (;; curve++) {\r\n                let length = curves[curve];\r\n                if (p > length) continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (;; segment++) {\r\n                let length = segments[segment];\r\n                if (p > length) continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n                      out: Array<number>, o: number, tangents: boolean) {\r\n        if (p == 0 || isNaN(p)) p = 0.0001;\r\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n    }\r\n}\r\n", "import {Updatable} from \"./Updatable\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraint implements Updatable {\r\n    data: TransformConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    rotateMix = 0;\r\n    translateMix = 0;\r\n    scaleMix = 0;\r\n    shearMix = 0;\r\n    temp = new Vector2();\r\n    active = false;\r\n\r\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n        this.scaleMix = data.scaleMix;\r\n        this.shearMix = data.shearMix;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    apply() {\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        if (this.data.local) {\r\n            if (this.data.relative)\r\n                this.applyRelativeLocal();\r\n            else\r\n                this.applyAbsoluteLocal();\r\n\r\n        } else {\r\n            if (this.data.relative)\r\n                this.applyRelativeWorld();\r\n            else\r\n                this.applyAbsoluteWorld();\r\n        }\r\n    }\r\n\r\n    applyAbsoluteWorld() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        let targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        let offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            let modified = false;\r\n            let mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += (temp.x - mat.tx) * translateMix;\r\n                mat.ty += (temp.y - mat.ty) * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                let ts = Math.sqrt(ta * ta + tc * tc);\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                ts = Math.sqrt(tb * tb + td * td);\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let b = mat.c, d = mat.d;\r\n                let by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r = by + (r + offsetShearY) * shearMix;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyRelativeWorld() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        let targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect,\r\n            offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            let modified = false;\r\n            let mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += temp.x * translateMix;\r\n                mat.ty += temp.y * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                let b = mat.c, d = mat.d;\r\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyAbsoluteLocal() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n            if (rotateMix != 0) {\r\n                let r = target.arotation - rotation + this.data.offsetRotation;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                rotation += r * rotateMix;\r\n            }\r\n\r\n            let x = bone.ax, y = bone.ay;\r\n            if (translateMix != 0) {\r\n                x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                y += (target.ay - y + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n            }\r\n\r\n            let shearY = bone.ashearY;\r\n            if (shearMix > 0) {\r\n                let r = target.ashearY - shearY + this.data.offsetShearY;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                bone.shearY += r * shearMix;\r\n            }\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    applyRelativeLocal() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\r\n            let x = bone.ax, y = bone.ay;\r\n            if (translateMix != 0) {\r\n                x += (target.ax + this.data.offsetX) * translateMix;\r\n                y += (target.ay + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                if (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n            }\r\n\r\n            let shearY = bone.ashearY;\r\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n}\r\n", "import {Attachment, RegionAttachment, MeshAttachment, PathAttachment} from './attachments';\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {SkeletonData} from \"./SkeletonData\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport {Skin} from \"./Skin\";\r\nimport {Color, Utils, Vector2, ISkeleton} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\r\n    data: SkeletonData;\r\n    bones: Array<Bone>;\r\n    slots: Array<Slot>;\r\n    drawOrder: Array<Slot>;\r\n    ikConstraints: Array<IkConstraint>;\r\n    transformConstraints: Array<TransformConstraint>;\r\n    pathConstraints: Array<PathConstraint>;\r\n    _updateCache = new Array<Updatable>();\r\n    updateCacheReset = new Array<Updatable>();\r\n    skin: Skin;\r\n    color: Color;\r\n    time = 0;\r\n    scaleX = 1; scaleY = 1;\r\n    x = 0; y = 0;\r\n\r\n    constructor (data: SkeletonData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let boneData = data.bones[i];\r\n            let bone: Bone;\r\n            if (boneData.parent == null)\r\n                bone = new Bone(boneData, this, null);\r\n            else {\r\n                let parent = this.bones[boneData.parent.index];\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            let slotData = data.slots[i];\r\n            let bone = this.bones[slotData.boneData.index];\r\n            let slot = new Slot(slotData, bone);\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            let ikConstraintData = data.ikConstraints[i];\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            let transformConstraintData = data.transformConstraints[i];\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            let pathConstraintData = data.pathConstraints[i];\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    updateCache () {\r\n        let updateCache = this._updateCache;\r\n        updateCache.length = 0;\r\n        this.updateCacheReset.length = 0;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            bone.sorted = bone.data.skinRequired;\r\n            bone.active = !bone.sorted;\r\n        }\r\n\r\n        if (this.skin != null) {\r\n            let skinBones = this.skin.bones;\r\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                let bone = this.bones[skinBones[i].index];\r\n                do {\r\n                    bone.sorted = false;\r\n                    bone.active = true;\r\n                    bone = bone.parent;\r\n                } while (bone != null);\r\n            }\r\n        }\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        let ikConstraints = this.ikConstraints;\r\n        let transformConstraints = this.transformConstraints;\r\n        let pathConstraints = this.pathConstraints;\r\n        let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n        let constraintCount = ikCount + transformCount + pathCount;\r\n\r\n        outer:\r\n            for (let i = 0; i < constraintCount; i++) {\r\n                for (let ii = 0; ii < ikCount; ii++) {\r\n                    let constraint = ikConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortIkConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < transformCount; ii++) {\r\n                    let constraint = transformConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortTransformConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < pathCount; ii++) {\r\n                    let constraint = pathConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortPathConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n            }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortIkConstraint (constraint: IkConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        let target = constraint.target;\r\n        this.sortBone(target);\r\n\r\n        let constrained = constraint.bones;\r\n        let parent = constrained[0];\r\n        this.sortBone(parent);\r\n\r\n        if (constrained.length > 1) {\r\n            let child = constrained[constrained.length - 1];\r\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        this.sortReset(parent.children);\r\n        constrained[constrained.length - 1].sorted = true;\r\n    }\r\n\r\n    sortPathConstraint (constraint: PathConstraint) {\r\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        let slot = constraint.target;\r\n        let slotIndex = slot.data.index;\r\n        let slotBone = slot.bone;\r\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n            this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n        for (let i = 0, n = this.data.skins.length; i < n; i++)\r\n            this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n        let attachment = slot.getAttachment();\r\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortBone(constrained[i]);\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++)\r\n            constrained[i].sorted = true;\r\n    }\r\n\r\n    sortTransformConstraint (constraint: TransformConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        this.sortBone(constraint.target);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        if (constraint.data.local) {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                let child = constrained[i];\r\n                this.sortBone(child.parent);\r\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n            }\r\n        } else {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                this.sortBone(constrained[i]);\r\n            }\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let ii = 0; ii < boneCount; ii++)\r\n            this.sortReset(constrained[ii].children);\r\n        for (let ii = 0; ii < boneCount; ii++)\r\n            constrained[ii].sorted = true;\r\n    }\r\n\r\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        let attachments = skin.attachments[slotIndex];\r\n        if (!attachments) return;\r\n        for (let key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        let pathBones = (<PathAttachment>attachment).bones;\r\n        if (pathBones == null)\r\n            this.sortBone(slotBone);\r\n        else {\r\n            let bones = this.bones;\r\n            let i = 0;\r\n            while (i < pathBones.length) {\r\n                let boneCount = pathBones[i++];\r\n                for (let n = i + boneCount; i < n; i++) {\r\n                    let boneIndex = pathBones[i];\r\n                    this.sortBone(bones[boneIndex]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone (bone: Bone) {\r\n        if (bone.sorted) return;\r\n        let parent = bone.parent;\r\n        if (parent != null) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset (bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.active) continue;\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies constraints. */\r\n    updateWorldTransform () {\r\n        let updateCacheReset = this.updateCacheReset;\r\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\r\n            let bone = updateCacheReset[i] as Bone;\r\n            bone.ax = bone.x;\r\n            bone.ay = bone.y;\r\n            bone.arotation = bone.rotation;\r\n            bone.ascaleX = bone.scaleX;\r\n            bone.ascaleY = bone.scaleY;\r\n            bone.ashearX = bone.shearX;\r\n            bone.ashearY = bone.shearY;\r\n            bone.appliedValid = true;\r\n        }\r\n        let updateCache = this._updateCache;\r\n        for (let i = 0, n = updateCache.length; i < n; i++)\r\n            updateCache[i].update();\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose () {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose () {\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            constraint.mix = constraint.data.mix;\r\n            constraint.softness = constraint.data.softness;\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.compress = constraint.data.compress;\r\n            constraint.stretch = constraint.data.stretch;\r\n        }\r\n\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n        }\r\n    }\r\n\r\n    setSlotsToSetupPose () {\r\n        let slots = this.slots;\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @return May return null. */\r\n    getRootBone () {\r\n        if (this.bones.length == 0) return null;\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findBone (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findSlot (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     * @see #setSkin(Skin) */\r\n    setSkinByName (skinName: string) {\r\n        let skin = this.data.findSkin(skinName);\r\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin (newSkin: Skin) {\r\n        if (newSkin == this.skin) return;\r\n        if (newSkin != null) {\r\n            if (this.skin != null)\r\n                newSkin.attachAll(this, this.skin);\r\n            else {\r\n                let slots = this.slots;\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    let slot = slots[i];\r\n                    let name = slot.data.attachmentName;\r\n                    if (name != null) {\r\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n        this.updateCache();\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\r\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\r\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\r\n        if (this.skin != null) {\r\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment != null) return attachment;\r\n        }\r\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    }\r\n\r\n    /** @param attachmentName May be null. */\r\n    setAttachment (slotName: string, attachmentName?: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment = null;\r\n                if (attachmentName != null) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (attachment == null)\r\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(\"Slot not found: \" + slotName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let ikConstraint = ikConstraints[i];\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size The width and height of the AABB.\r\n     * @param temp Working memory */\r\n    getBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n        if (offset == null) throw new Error(\"offset cannot be null.\");\r\n        if (size == null) throw new Error(\"size cannot be null.\");\r\n        let drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = drawOrder[i];\r\n            if (!slot.bone.active) continue;\r\n            let verticesLength = 0;\r\n            let vertices: ArrayLike<number> = null;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof RegionAttachment) {\r\n                verticesLength = 8;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\r\n            } else if (attachment instanceof MeshAttachment) {\r\n                let mesh = (<MeshAttachment>attachment);\r\n                verticesLength = mesh.worldVerticesLength;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n            }\r\n            if (vertices != null) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                    let x = vertices[ii], y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    update (delta: number) {\r\n        this.time += delta;\r\n    }\r\n\r\n    get flipX(): boolean {\r\n        return this.scaleX == -1;\r\n    }\r\n\r\n    set flipX(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleX = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    get flipY(): boolean {\r\n        return this.scaleY == -1;\r\n    }\r\n\r\n    set flipY(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleY = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n}\r\n", "import type {ISkeletonData} from '@pixi-spine/base';\r\nimport type {Animation} from \"./Animation\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {EventData} from \"./EventData\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData} from \"./PathConstraintData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\r\n    name: string;\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n    defaultSkin: Skin;\r\n    events = new Array<EventData>();\r\n    animations = new Array<Animation>();\r\n    ikConstraints = new Array<IkConstraintData>();\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n    pathConstraints = new Array<PathConstraintData>();\r\n    x: number; y: number; width: number; height: number;\r\n    version: string; hash: string;\r\n\r\n    // Nonessential\r\n    fps = 0;\r\n    imagesPath: string;\r\n    audioPath: string;\r\n\r\n    findBone (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findBoneIndex (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSlot (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findSlotIndex (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSkin (skinName: string) {\r\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\r\n        let skins = this.skins;\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            let skin = skins[i];\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findEvent (eventDataName: string) {\r\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\r\n        let events = this.events;\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findAnimation (animationName: string) {\r\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\r\n        let animations = this.animations;\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            let animation = animations[i];\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findIkConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findTransformConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraintIndex (pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n            if (pathConstraints[i].name == pathConstraintName) return i;\r\n        return -1;\r\n    }\r\n}\r\n", "import {Color} from '@pixi-spine/base';\r\n\r\nimport type {ISlotData} from '@pixi-spine/base';\r\nimport type {BLEND_MODES} from '@pixi/constants';\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SlotData implements ISlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: BoneData;\r\n    color = new Color(1, 1, 1, 1);\r\n    darkColor: Color;\r\n    attachmentName: string;\r\n    blendMode: BLEND_MODES;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n", "import {BoneData} from './BoneData';\r\nimport {ConstraintData} from './Constraint';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintData extends ConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\r\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n", "import {Attachment, MeshAttachment} from './attachments';\r\nimport {BoneData} from \"./BoneData\";\r\nimport {ConstraintData} from \"./Constraint\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\nimport type {Map, ISkin} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkinEntry {\r\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) { }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skin implements ISkin {\r\n    name: string;\r\n    attachments = new Array<Map<Attachment>>();\r\n    bones = Array<BoneData>();\r\n    constraints = new Array<ConstraintData>();\r\n\r\n    constructor (name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    setAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\r\n        let attachments = this.attachments;\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    addSkin (skin: Skin) {\r\n        for(let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let j = 0; j < this.bones.length; j++) {\r\n                if (this.bones[j] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for(let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let j = 0; j < this.constraints.length; j++) {\r\n                if (this.constraints[j] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n        }\r\n    }\r\n\r\n    copySkin (skin: Skin) {\r\n        for(let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let j = 0; j < this.bones.length; j++) {\r\n                if (this.bones[j] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for(let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let j = 0; j < this.constraints.length; j++) {\r\n                if (this.constraints[j] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            if (attachment.attachment == null) continue;\r\n            if (attachment.attachment instanceof MeshAttachment) {\r\n                attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            } else {\r\n                attachment.attachment = attachment.attachment.copy();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (slotIndex: number, name: string): Attachment {\r\n        let dictionary = this.attachments[slotIndex];\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    removeAttachment (slotIndex: number, name: string) {\r\n        let dictionary = this.attachments[slotIndex];\r\n        if (dictionary) dictionary[name] = null;\r\n    }\r\n\r\n    getAttachments (): Array<SkinEntry> {\r\n        let entries = new Array<SkinEntry>();\r\n        for (var i = 0; i < this.attachments.length; i++) {\r\n            let slotAttachments = this.attachments[i];\r\n            if (slotAttachments) {\r\n                for (let name in slotAttachments) {\r\n                    let attachment = slotAttachments[name];\r\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                }\r\n            }\r\n        }\r\n        return entries;\r\n    }\r\n\r\n    getAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\r\n        let slotAttachments = this.attachments[slotIndex];\r\n        if (slotAttachments) {\r\n            for (let name in slotAttachments) {\r\n                let attachment = slotAttachments[name];\r\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n            }\r\n        }\r\n    }\r\n\r\n    clear () {\r\n        this.attachments.length = 0;\r\n        this.bones.length = 0;\r\n        this.constraints.length = 0;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            let slot = skeleton.slots[i];\r\n            let slotAttachment = slot.getAttachment();\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                let dictionary = oldSkin.attachments[slotIndex];\r\n                for (let key in dictionary) {\r\n                    let skinAttachment:Attachment = dictionary[key];\r\n                    if (slotAttachment == skinAttachment) {\r\n                        let attachment = this.getAttachment(slotIndex, key);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n", "import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {Animation} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {\r\n    AttachmentTimeline,\r\n    ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline\r\n} from './Animation';\r\nimport {AttachmentType, BinaryInput, Color, PositionMode, RotateMode, TransformMode, Utils} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonBinary {\r\n    static AttachmentTypeValues = [ 0 /*AttachmentType.Region*/, 1/*AttachmentType.BoundingBox*/, 2/*AttachmentType.Mesh*/, 3/*AttachmentType.LinkedMesh*/, 4/*AttachmentType.Path*/, 5/*AttachmentType.Point*/, 6/*AttachmentType.Clipping*/ ];\r\n    static TransformModeValues = [TransformMode.Normal, TransformMode.OnlyTranslation, TransformMode.NoRotationOrReflection, TransformMode.NoScale, TransformMode.NoScaleOrReflection];\r\n    static PositionModeValues = [ PositionMode.Fixed, PositionMode.Percent ];\r\n    static SpacingModeValues = [ SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\r\n    static RotateModeValues = [ RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale ];\r\n    static BlendModeValues = [ BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\r\n\r\n    static BONE_ROTATE = 0;\r\n    static BONE_TRANSLATE = 1;\r\n    static BONE_SCALE = 2;\r\n    static BONE_SHEAR = 3;\r\n\r\n    static SLOT_ATTACHMENT = 0;\r\n    static SLOT_COLOR = 1;\r\n    static SLOT_TWO_COLOR = 2;\r\n\r\n    static PATH_POSITION = 0;\r\n    static PATH_SPACING = 1;\r\n    static PATH_MIX = 2;\r\n\r\n    static CURVE_LINEAR = 0;\r\n    static CURVE_STEPPED = 1;\r\n    static CURVE_BEZIER = 2;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (binary: Uint8Array): SkeletonData {\r\n        let scale = this.scale;\r\n\r\n        let skeletonData = new SkeletonData();\r\n        skeletonData.name = \"\"; // BOZO\r\n\r\n        let input = new BinaryInput(binary);\r\n\r\n        skeletonData.hash = input.readString();\r\n        skeletonData.version = input.readString();\r\n        if (skeletonData.version === '3.8.75')\r\n        {\r\n            let error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n            console.error(error);\r\n        }\r\n        skeletonData.x = input.readFloat();\r\n        skeletonData.y = input.readFloat();\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        let nonessential = input.readBoolean();\r\n        if (nonessential) {\r\n            skeletonData.fps = input.readFloat();\r\n\r\n            skeletonData.imagesPath = input.readString();\r\n            skeletonData.audioPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n        // Strings.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++)\r\n            input.strings.push(input.readString());\r\n\r\n        // Bones.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++) {\r\n            let name = input.readString();\r\n            let parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            let data = new BoneData(i, name, parent);\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n            data.skinRequired = input.readBoolean();\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let slotName = input.readString();\r\n            let boneData = skeletonData.bones[input.readInt(true)];\r\n            let data = new SlotData(i, slotName, boneData);\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n            let darkColor = input.readInt32();\r\n            if (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\r\n\r\n            data.attachmentName = input.readStringRef();\r\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new IkConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.softness = input.readFloat() * scale;\r\n            data.bendDirection = input.readByte();\r\n            data.compress = input.readBoolean();\r\n            data.stretch = input.readBoolean();\r\n            data.uniform = input.readBoolean();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new TransformConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.local = input.readBoolean();\r\n            data.relative = input.readBoolean();\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            data.scaleMix = input.readFloat();\r\n            data.shearMix = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new PathConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n            data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n            data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        let defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n        if (defaultSkin != null) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n            Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n            for (; i < n; i++)\r\n                skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent as VertexAttachment : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let data = new EventData(input.readStringRef());\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath != null) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++)\r\n            skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true)\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin(\"default\");\r\n        } else {\r\n            skin = new Skin(input.readStringRef());\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++)\r\n                skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let name = input.readStringRef();\r\n                let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n                if (attachment != null) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\r\n        let scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n        if (name == null) name = attachmentName;\r\n\r\n        let typeIndex = input.readByte();\r\n        let type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n        switch (type) {\r\n        case AttachmentType.Region: {\r\n            let path = input.readStringRef();\r\n            let rotation = input.readFloat();\r\n            let x = input.readFloat();\r\n            let y = input.readFloat();\r\n            let scaleX = input.readFloat();\r\n            let scaleY = input.readFloat();\r\n            let width = input.readFloat();\r\n            let height = input.readFloat();\r\n            let color = input.readInt32();\r\n\r\n            if (path == null) path = name;\r\n            let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n            if (region == null) return null;\r\n            region.path = path;\r\n            region.x = x * scale;\r\n            region.y = y * scale;\r\n            region.scaleX = scaleX;\r\n            region.scaleY = scaleY;\r\n            region.rotation = rotation;\r\n            region.width = width * scale;\r\n            region.height = height * scale;\r\n            Color.rgba8888ToColor(region.color, color);\r\n            // region.updateOffset();\r\n            return region;\r\n        }\r\n        case AttachmentType.BoundingBox: {\r\n            let vertexCount = input.readInt(true);\r\n            let vertices = this.readVertices(input, vertexCount);\r\n            let color = nonessential ? input.readInt32() : 0;\r\n\r\n            let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n            if (box == null) return null;\r\n            box.worldVerticesLength = vertexCount << 1;\r\n            box.vertices = vertices.vertices;\r\n            box.bones = vertices.bones;\r\n            if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n            return box;\r\n        }\r\n        case AttachmentType.Mesh: {\r\n            let path = input.readStringRef();\r\n            let color = input.readInt32();\r\n            let vertexCount = input.readInt(true);\r\n            let uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n            let triangles = this.readShortArray(input);\r\n            let vertices = this.readVertices(input, vertexCount);\r\n            let hullLength = input.readInt(true);\r\n            let edges = null;\r\n            let width = 0, height = 0;\r\n            if (nonessential) {\r\n                edges = this.readShortArray(input);\r\n                width = input.readFloat();\r\n                height = input.readFloat();\r\n            }\r\n\r\n            if (path == null) path = name;\r\n            let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n            if (mesh == null) return null;\r\n            mesh.path = path;\r\n            Color.rgba8888ToColor(mesh.color, color);\r\n            mesh.bones = vertices.bones;\r\n            mesh.vertices = vertices.vertices;\r\n            mesh.worldVerticesLength = vertexCount << 1;\r\n            mesh.triangles = triangles;\r\n            mesh.regionUVs = new Float32Array(uvs);\r\n            // mesh.updateUVs();\r\n            mesh.hullLength = hullLength << 1;\r\n            if (nonessential) {\r\n                mesh.edges = edges;\r\n                mesh.width = width * scale;\r\n                mesh.height = height * scale;\r\n            }\r\n            return mesh;\r\n        }\r\n        case AttachmentType.LinkedMesh: {\r\n            let path = input.readStringRef();\r\n            let color = input.readInt32();\r\n            let skinName = input.readStringRef();\r\n            let parent = input.readStringRef();\r\n            let inheritDeform = input.readBoolean();\r\n            let width = 0, height = 0;\r\n            if (nonessential) {\r\n                width = input.readFloat();\r\n                height = input.readFloat();\r\n            }\r\n\r\n            if (path == null) path = name;\r\n            let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n            if (mesh == null) return null;\r\n            mesh.path = path;\r\n            Color.rgba8888ToColor(mesh.color, color);\r\n            if (nonessential) {\r\n                mesh.width = width * scale;\r\n                mesh.height = height * scale;\r\n            }\r\n            this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\r\n            return mesh;\r\n        }\r\n        case AttachmentType.Path: {\r\n            let closed = input.readBoolean();\r\n            let constantSpeed = input.readBoolean();\r\n            let vertexCount = input.readInt(true);\r\n            let vertices = this.readVertices(input, vertexCount);\r\n            let lengths = Utils.newArray(vertexCount / 3, 0);\r\n            for (let i = 0, n = lengths.length; i < n; i++)\r\n                lengths[i] = input.readFloat() * scale;\r\n            let color = nonessential ? input.readInt32() : 0;\r\n\r\n            let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n            if (path == null) return null;\r\n            path.closed = closed;\r\n            path.constantSpeed = constantSpeed;\r\n            path.worldVerticesLength = vertexCount << 1;\r\n            path.vertices = vertices.vertices;\r\n            path.bones = vertices.bones;\r\n            path.lengths = lengths;\r\n            if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n            return path;\r\n        }\r\n        case AttachmentType.Point: {\r\n            let rotation = input.readFloat();\r\n            let x = input.readFloat();\r\n            let y = input.readFloat();\r\n            let color = nonessential ? input.readInt32() : 0;\r\n\r\n            let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n            if (point == null) return null;\r\n            point.x = x * scale;\r\n            point.y = y * scale;\r\n            point.rotation = rotation;\r\n            if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n            return point;\r\n        }\r\n        case AttachmentType.Clipping: {\r\n            let endSlotIndex = input.readInt(true);\r\n            let vertexCount = input.readInt(true);\r\n            let vertices = this.readVertices(input, vertexCount);\r\n            let color = nonessential ? input.readInt32() : 0;\r\n\r\n            let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n            if (clip == null) return null;\r\n            clip.endSlot = skeletonData.slots[endSlotIndex];\r\n            clip.worldVerticesLength = vertexCount << 1;\r\n            clip.vertices = vertices.vertices;\r\n            clip.bones = vertices.bones;\r\n            if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n            return clip;\r\n        }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private readVertices (input: BinaryInput, vertexCount: number): Vertices {\r\n        let verticesLength = vertexCount << 1;\r\n        let vertices = new Vertices();\r\n        let scale = this.scale;\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n            return vertices;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bonesArray = new Array<number>();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            let boneCount = input.readInt(true);\r\n            bonesArray.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                bonesArray.push(input.readInt(true));\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat());\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\r\n        let array = new Array<number>(n);\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat() * scale;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    private readShortArray (input: BinaryInput): number[] {\r\n        let n = input.readInt(true);\r\n        let array = new Array<number>(n);\r\n        for (let i = 0; i < n; i++)\r\n            array[i] = input.readShort();\r\n        return array;\r\n    }\r\n\r\n    private readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        let timelines = new Array<Timeline>();\r\n        let scale = this.scale;\r\n        let duration = 0;\r\n        let tempColor1 = new Color();\r\n        let tempColor2 = new Color();\r\n\r\n        // Slot timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let timelineType = input.readByte();\r\n                let frameCount = input.readInt(true);\r\n                switch (timelineType) {\r\n                case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                    let timeline = new AttachmentTimeline(frameCount);\r\n                    timeline.slotIndex = slotIndex;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++)\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                    break;\r\n                }\r\n                case SkeletonBinary.SLOT_COLOR: {\r\n                    let timeline = new ColorTimeline(frameCount);\r\n                    timeline.slotIndex = slotIndex;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        let time = input.readFloat();\r\n                        Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                        timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                case SkeletonBinary.SLOT_TWO_COLOR: {\r\n                    let timeline = new TwoColorTimeline(frameCount);\r\n                    timeline.slotIndex = slotIndex;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        let time = input.readFloat();\r\n                        Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                        Color.rgb888ToColor(tempColor2, input.readInt32());\r\n                        timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r,\r\n                            tempColor2.g, tempColor2.b);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let boneIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let timelineType = input.readByte();\r\n                let frameCount = input.readInt(true);\r\n                switch (timelineType) {\r\n                case SkeletonBinary.BONE_ROTATE: {\r\n                    let timeline = new RotateTimeline(frameCount);\r\n                    timeline.boneIndex = boneIndex;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                case SkeletonBinary.BONE_TRANSLATE:\r\n                case SkeletonBinary.BONE_SCALE:\r\n                case SkeletonBinary.BONE_SHEAR: {\r\n                    let timeline;\r\n                    let timelineScale = 1;\r\n                    if (timelineType == SkeletonBinary.BONE_SCALE)\r\n                        timeline = new ScaleTimeline(frameCount);\r\n                    else if (timelineType == SkeletonBinary.BONE_SHEAR)\r\n                        timeline = new ShearTimeline(frameCount);\r\n                    else {\r\n                        timeline = new TranslateTimeline(frameCount);\r\n                        timelineScale = scale;\r\n                    }\r\n                    timeline.boneIndex = boneIndex;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale,\r\n                            input.readFloat() * timelineScale);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true);\r\n            let frameCount = input.readInt(true);\r\n            let timeline = new IkConstraintTimeline(frameCount);\r\n            timeline.ikConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(),\r\n                    input.readBoolean());\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true);\r\n            let frameCount = input.readInt(true);\r\n            let timeline = new TransformConstraintTimeline(frameCount);\r\n            timeline.transformConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(),\r\n                    input.readFloat());\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true);\r\n            let data = skeletonData.pathConstraints[index];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let timelineType = input.readByte();\r\n                let frameCount = input.readInt(true);\r\n                switch (timelineType) {\r\n                case SkeletonBinary.PATH_POSITION:\r\n                case SkeletonBinary.PATH_SPACING: {\r\n                    let timeline;\r\n                    let timelineScale = 1;\r\n                    if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                        timeline = new PathConstraintSpacingTimeline(frameCount);\r\n                        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                    } else {\r\n                        timeline = new PathConstraintPositionTimeline(frameCount);\r\n                        if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                    }\r\n                    timeline.pathConstraintIndex = index;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                case SkeletonBinary.PATH_MIX: {\r\n                    let timeline = new PathConstraintMixTimeline(frameCount);\r\n                    timeline.pathConstraintIndex = index;\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    break;\r\n                }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let skin = skeletonData.skins[input.readInt(true)];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let slotIndex = input.readInt(true);\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    let attachment = skin.getAttachment(slotIndex, input.readStringRef()) as VertexAttachment;\r\n                    let weighted = attachment.bones != null;\r\n                    let vertices = attachment.vertices;\r\n                    let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                    let frameCount = input.readInt(true);\r\n                    let timeline = new DeformTimeline(frameCount);\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        let time = input.readFloat();\r\n                        let deform;\r\n                        let end = input.readInt(true);\r\n                        if (end == 0)\r\n                            deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                        else {\r\n                            deform = Utils.newFloatArray(deformLength);\r\n                            let start = input.readInt(true);\r\n                            end += start;\r\n                            if (scale == 1) {\r\n                                for (let v = start; v < end; v++)\r\n                                    deform[v] = input.readFloat();\r\n                            } else {\r\n                                for (let v = start; v < end; v++)\r\n                                    deform[v] = input.readFloat() * scale;\r\n                            }\r\n                            if (!weighted) {\r\n                                for (let v = 0, vn = deform.length; v < vn; v++)\r\n                                    deform[v] += vertices[v];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, time, deform);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderCount = input.readInt(true);\r\n        if (drawOrderCount > 0) {\r\n            let timeline = new DrawOrderTimeline(drawOrderCount);\r\n            let slotCount = skeletonData.slots.length;\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                let time = input.readFloat();\r\n                let offsetCount = input.readInt(true);\r\n                let drawOrder = Utils.newArray(slotCount, 0);\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    drawOrder[ii] = -1;\r\n                let unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0, unchangedIndex = 0;\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    let slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n                    while (originalIndex != slotIndex)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount)\r\n                    unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        let eventCount = input.readInt(true);\r\n        if (eventCount > 0) {\r\n            let timeline = new EventTimeline(eventCount);\r\n            for (let i = 0; i < eventCount; i++) {\r\n                let time = input.readFloat();\r\n                let eventData = skeletonData.events[input.readInt(true)];\r\n                let event = new Event(time, eventData);\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n        }\r\n\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n\r\n    private readCurve (input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\r\n        switch (input.readByte()) {\r\n        case SkeletonBinary.CURVE_STEPPED:\r\n            timeline.setStepped(frameIndex);\r\n            break;\r\n        case SkeletonBinary.CURVE_BEZIER:\r\n            this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n            break;\r\n        }\r\n    }\r\n\r\n    setCurve (timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) { }\r\n}\r\n", "import {BoundingBoxAttachment} from \"./attachments\";\r\nimport {SkeletonBoundsBase} from \"@pixi-spine/base\";\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\n export class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment>{};", "import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {Animation} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {\r\n    AttachmentTimeline,\r\n    ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline\r\n} from './Animation';\r\nimport {ArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (json: string | any): SkeletonData {\r\n        let scale = this.scale;\r\n        let skeletonData = new SkeletonData();\r\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        let skeletonMap = root.skeleton;\r\n        if (skeletonMap != null) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            if (skeletonData.version.substr(0, 3) !== '3.8') {\r\n                let error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n                console.error(error);\r\n            }\r\n            if (skeletonData.version === '3.8.75')\r\n            {\r\n                let error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                let boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                }\r\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n                data.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                let slotMap = root.slots[i];\r\n                let slotName: string = slotMap.name;\r\n                let boneName: string = slotMap.bone;\r\n                let boneData = skeletonData.findBone(boneName);\r\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                let color: string = this.getValue(slotMap, \"color\", null);\r\n                if (color != null) data.color.setFromString(color);\r\n\r\n                let dark: string = this.getValue(slotMap, \"dark\", null);\r\n                if (dark != null) {\r\n                    data.darkColor = new Color(1, 1, 1, 1);\r\n                    data.darkColor.setFromString(dark);\r\n                }\r\n\r\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                let constraintMap = root.ik[i];\r\n                let data = new IkConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\r\n\r\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n                data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                data.compress = this.getValue(constraintMap, \"compress\", false);\r\n                data.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n                data.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                let constraintMap = root.transform[i];\r\n                let data = new TransformConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n                data.local = this.getValue(constraintMap, \"local\", false);\r\n                data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                let constraintMap = root.path[i];\r\n                let data = new PathConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.position = this.getValue(constraintMap, \"position\", 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                let skinMap = root.skins[i]\r\n                let skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        let bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                        if (bone == null) throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        let constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        let constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        let constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (let slotName in skinMap.attachments) {\r\n                    let slot = skeletonData.findSlot(slotName);\r\n                    if (slot == null) throw new Error(\"Slot not found: \" + slotName);\r\n                    let slotMap = skinMap.attachments[slotName];\r\n                    for (let entryName in slotMap) {\r\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                        if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (let eventName in root.events) {\r\n                let eventMap = root.events[eventName];\r\n                let data = new EventData(eventName);\r\n                data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                if (data.audioPath != null) {\r\n                    data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                    data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (let animationName in root.animations) {\r\n                let animationMap = root.animations[animationName];\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n        let scale = this.scale;\r\n        name = this.getValue(map, \"name\", name);\r\n\r\n        let type = this.getValue(map, \"type\", \"region\");\r\n\r\n        switch (type) {\r\n            case \"region\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = this.getValue(map, \"x\", 0) * scale;\r\n                region.y = this.getValue(map, \"y\", 0) * scale;\r\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                region.rotation = this.getValue(map, \"rotation\", 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) region.color.setFromString(color);\r\n\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case \"boundingbox\": {\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (box == null) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) box.color.setFromString(color);\r\n                return box;\r\n            }\r\n            case \"mesh\":\r\n            case \"linkedmesh\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n\r\n                let color = this.getValue(map, \"color\", null);\r\n                if (color != null) mesh.color.setFromString(color);\r\n\r\n                mesh.width = this.getValue(map, \"width\", 0) * scale;\r\n                mesh.height = this.getValue(map, \"height\", 0) * scale;\r\n\r\n                let parent: string = this.getValue(map, \"parent\", null);\r\n                if (parent != null) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent, this.getValue(map, \"deform\", true)));\r\n                    return mesh;\r\n                }\r\n\r\n                let uvs: Array<number> = map.uvs;\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n\r\n                mesh.edges = this.getValue(map, \"edges\", null);\r\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                return mesh;\r\n            }\r\n            case \"path\": {\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (path == null) return null;\r\n                path.closed = this.getValue(map, \"closed\", false);\r\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0; i < map.lengths.length; i++)\r\n                    lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) path.color.setFromString(color);\r\n                return path;\r\n            }\r\n            case \"point\": {\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (point == null) return null;\r\n                point.x = this.getValue(map, \"x\", 0) * scale;\r\n                point.y = this.getValue(map, \"y\", 0) * scale;\r\n                point.rotation = this.getValue(map, \"rotation\", 0);\r\n\r\n                let color = this.getValue(map, \"color\", null);\r\n                if (color != null) point.color.setFromString(color);\r\n                return point;\r\n            }\r\n            case \"clipping\": {\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (clip == null) return null;\r\n\r\n                let end = this.getValue(map, \"end\", null);\r\n                if (end != null) {\r\n                    let slot = skeletonData.findSlot(end);\r\n                    if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) clip.color.setFromString(color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        let scale = this.scale;\r\n        attachment.worldVerticesLength = verticesLength;\r\n        let vertices: Array<number> = map.vertices;\r\n        if (verticesLength == vertices.length) {\r\n            let scaledVertices = Utils.toFloatArray(vertices);\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++)\r\n                    scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n            return;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bones = new Array<number>();\r\n        for (let i = 0, n = vertices.length; i < n;) {\r\n            let boneCount = vertices[i++];\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n        let scale = this.scale;\r\n        let timelines = new Array<Timeline>();\r\n        let duration = 0;\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (let slotName in map.slots) {\r\n                let slotMap = map.slots[slotName];\r\n                let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                for (let timelineName in slotMap) {\r\n                    let timelineMap = slotMap[timelineName];\r\n                    if (timelineName == \"attachment\") {\r\n                        let timeline = new AttachmentTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    } else if (timelineName == \"color\") {\r\n                        let timeline = new ColorTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let color = new Color();\r\n                            color.setFromString(valueMap.color || \"ffffffff\");\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName == \"twoColor\") {\r\n                        let timeline = new TwoColorTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let light = new Color();\r\n                            let dark = new Color();\r\n                            light.setFromString(valueMap.light);\r\n                            dark.setFromString(valueMap.dark);\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (let boneName in map.bones) {\r\n                let boneMap = map.bones[boneName];\r\n                let boneIndex = skeletonData.findBoneIndex(boneName);\r\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n                for (let timelineName in boneMap) {\r\n                    let timelineMap = boneMap[timelineName];\r\n                    if (timelineName === \"rotate\") {\r\n                        let timeline = new RotateTimeline(timelineMap.length);\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                        let timeline: TranslateTimeline = null;\r\n                        let timelineScale = 1, defaultValue = 0;\r\n                        if (timelineName === \"scale\") {\r\n                            timeline = new ScaleTimeline(timelineMap.length);\r\n                            defaultValue = 1;\r\n                        } else if (timelineName === \"shear\")\r\n                            timeline = new ShearTimeline(timelineMap.length);\r\n                        else {\r\n                            timeline = new TranslateTimeline(timelineMap.length);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (let constraintName in map.ik) {\r\n                let constraintMap = map.ik[constraintName];\r\n                let constraint = skeletonData.findIkConstraint(constraintName);\r\n                let timeline = new IkConstraintTimeline(constraintMap.length);\r\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale,\r\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (let constraintName in map.transform) {\r\n                let constraintMap = map.transform[constraintName];\r\n                let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\r\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration,\r\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (let constraintName in map.path) {\r\n                let constraintMap = map.path[constraintName];\r\n                let index = skeletonData.findPathConstraintIndex(constraintName);\r\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                let data = skeletonData.pathConstraints[index];\r\n                for (let timelineName in constraintMap) {\r\n                    let timelineMap = constraintMap[timelineName];\r\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                        let timeline: PathConstraintPositionTimeline = null;\r\n                        let timelineScale = 1;\r\n                        if (timelineName === \"spacing\") {\r\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    } else if (timelineName === \"mix\") {\r\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n                                this.getValue(valueMap, \"translateMix\", 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (let deformName in map.deform) {\r\n                let deformMap = map.deform[deformName];\r\n                let skin = skeletonData.findSkin(deformName);\r\n                if (skin == null) {\r\n                   if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                       throw new Error(\"Skin not found: \" + deformName);\r\n                   } else {\r\n                       continue;\r\n                   }\r\n                }\r\n                for (let slotName in deformMap) {\r\n                    let slotMap = deformMap[slotName];\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n                    for (let timelineName in slotMap) {\r\n                        let timelineMap = slotMap[timelineName];\r\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                        let weighted = attachment.bones != null;\r\n                        let vertices = attachment.vertices;\r\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                        let timeline = new DeformTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let j = 0; j < timelineMap.length; j++) {\r\n                            let valueMap = timelineMap[j];\r\n                            let deform: ArrayLike<number>;\r\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\r\n                            if (verticesValue == null)\r\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                        deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++)\r\n                                        deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderNode = map.drawOrder;\r\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n        if (drawOrderNode != null) {\r\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n            let slotCount = skeletonData.slots.length;\r\n            let frameIndex = 0;\r\n            for (let j = 0; j < drawOrderNode.length; j++) {\r\n                let drawOrderMap = drawOrderNode[j];\r\n                let drawOrder: Array<number> = null;\r\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                if (offsets != null) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0, unchangedIndex = 0;\r\n                    for (let i = 0; i < offsets.length; i++) {\r\n                        let offsetMap = offsets[i];\r\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let i = slotCount - 1; i >= 0; i--)\r\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        if (map.events) {\r\n            let timeline = new EventTimeline(map.events.length);\r\n            let frameIndex = 0;\r\n            for (let i = 0; i < map.events.length; i++) {\r\n                let eventMap = map.events[i];\r\n                let eventData = skeletonData.findEvent(eventMap.name);\r\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\r\n                let event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = this.getValue(eventMap, \"volume\", 1);\r\n                    event.balance = this.getValue(eventMap, \"balance\", 0);\r\n                }\r\n                timeline.setFrame(frameIndex++, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        if (isNaN(duration)) {\r\n            throw new Error(\"Error while parsing animation, duration is NaN\");\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n\r\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\r\n        if (!map.hasOwnProperty(\"curve\")) return;\r\n        if (map.curve === \"stepped\")\r\n            timeline.setStepped(frameIndex);\r\n        else {\r\n            let curve: number = map.curve;\r\n            timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n        }\r\n    }\r\n\r\n    getValue (map: any, prop: string, defaultValue: any) {\r\n        return map[prop] !== undefined ? map[prop] : defaultValue;\r\n    }\r\n\r\n    static blendModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return BLEND_MODES.NORMAL;\r\n        if (str == \"additive\") return BLEND_MODES.ADD;\r\n        if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\r\n        if (str == \"screen\") return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n\r\n    static positionModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"fixed\") return PositionMode.Fixed;\r\n        if (str == \"percent\") return PositionMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static spacingModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"length\") return SpacingMode.Length;\r\n        if (str == \"fixed\") return SpacingMode.Fixed;\r\n        if (str == \"percent\") return SpacingMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static rotateModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"tangent\") return RotateMode.Tangent;\r\n        if (str == \"chain\") return RotateMode.Chain;\r\n        if (str == \"chainscale\") return RotateMode.ChainScale;\r\n        throw new Error(`Unknown rotate mode: ${str}`);\r\n    }\r\n\r\n    static transformModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return TransformMode.Normal;\r\n        if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\r\n        if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\r\n        if (str == \"noscale\") return TransformMode.NoScale;\r\n        if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\r\n        throw new Error(`Unknown transform mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n", "import {SpineBase} from '@pixi-spine/base';\r\nimport {Skeleton} from \"./core/Skeleton\";\r\nimport {SkeletonData} from \"./core/SkeletonData\";\r\nimport {AnimationState} from \"./core/AnimationState\";\r\nimport {AnimationStateData} from \"./core/AnimationStateData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "import {AttachmentType} from '@pixi-spine/base';\r\nimport type {IAttachment, ArrayLike} from '@pixi-spine/base';\r\n\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    id = (VertexAttachment.nextID++ & 65535) << 11;\r\n    bones: Array<number>;\r\n    vertices: ArrayLike<number>;\r\n    worldVerticesLength = 0;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n\r\n    /** Transforms local vertices to world coordinates.\r\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n     * @param offset The worldVertices index to begin writing values. */\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        let skeleton = slot.bone.skeleton;\r\n        let deformArray = slot.attachmentVertices;\r\n        let vertices = this.vertices;\r\n        let bones = this.bones;\r\n        if (bones == null) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            let mat = slot.bone.matrix;\r\n            let x = mat.tx;\r\n            let y = mat.ty;\r\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                let vx = vertices[v], vy = vertices[v + 1];\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n            return;\r\n        }\r\n        let v = 0, skip = 0;\r\n        for (let i = 0; i < start; i += 2) {\r\n            let n = bones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        let skeletonBones = skeleton.bones;\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            let deform = deformArray;\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1],\r\n                        weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\r\n    applyDeform(sourceAttachment: VertexAttachment) {\r\n        return this == sourceAttachment;\r\n    }\r\n}\r\n", "import {VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n", "import {VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IClippingAttachment} from '@pixi-spine/base';\r\nimport type {SlotData} from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    endSlot: SlotData;\r\n\r\n    // Nonessential.\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n", "import {VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IMeshAttachment, TextureRegion} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion;\r\n    path: string;\r\n    regionUVs: Float32Array; uvs: ArrayLike<number>;\r\n    triangles: Array<number>;\r\n    color = new Color(1, 1, 1, 1);\r\n    hullLength: number;\r\n    private parentMesh: MeshAttachment;\r\n    inheritDeform = false;\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    applyDeform (sourceAttachment: VertexAttachment): boolean {\r\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\r\n    }\r\n\r\n    getParentMesh () {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh (parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength\r\n        }\r\n    }\r\n\r\n    //computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\r\n}\r\n", "import {VertexAttachment} from \"./Attachment\";\r\nimport {AttachmentType, Color} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n    lengths: Array<number>;\r\n    closed = false;\r\n    constantSpeed = false;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n", "import {VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport type {Bone} from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n    x: number;\r\n    y: number;\r\n    rotation: number;\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition(bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation(bone: Bone) {\r\n        const mat = bone.matrix;\r\n        let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\r\n        let x = cos * mat.a + sin * mat.c;\r\n        let y = cos * mat.b + sin * mat.d;\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n}\r\n", "import {Color, ISlot} from '@pixi-spine/base';\r\n\r\nimport type {Attachment} from './attachments/Attachment';\r\nimport type {Bone} from './Bone';\r\nimport type {SlotData} from './SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Slot implements ISlot {\r\n    blendMode: number;\r\n\r\n    //this is canon\r\n    data: SlotData;\r\n    bone: Bone;\r\n    color: Color;\r\n    darkColor: Color;\r\n    attachment: Attachment;\r\n    private attachmentTime: number;\r\n    attachmentVertices = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (bone == null) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = data.darkColor == null ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\r\n     * @param attachment May be null. */\r\n    setAttachment (attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    }\r\n\r\n    setAttachmentTime (time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** Returns the time since the attachment was set. */\r\n    getAttachmentTime (): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\r\n        if (this.data.attachmentName == null)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n", "\r\nimport {Attachment} from './Attachment';\r\nimport {AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment} from \"@pixi-spine/base\";\r\n\r\nimport type {Bone} from '../Bone';\r\nimport { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\r\n    type = AttachmentType.Region;\r\n\r\n    static OX1 = 0;\r\n    static OY1 = 1;\r\n    static OX2 = 2;\r\n    static OY2 = 3;\r\n    static OX3 = 4;\r\n    static OY3 = 5;\r\n    static OX4 = 6;\r\n    static OY4 = 7;\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n\r\n    x = 0;\r\n    y = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    rotation = 0;\r\n    width = 0;\r\n    height = 0;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    path: string;\r\n    rendererObject: any;\r\n    region: TextureRegion;\r\n\r\n    offset = Utils.newFloatArray(8);\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    updateOffset(): void {\r\n        let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n        let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n        let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n        let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n        let localX2 = localX + this.region.width * regionScaleX;\r\n        let localY2 = localY + this.region.height * regionScaleY;\r\n        let radians = this.rotation * Math.PI / 180;\r\n        let cos = Math.cos(radians);\r\n        let sin = Math.sin(radians);\r\n        let localXCos = localX * cos + this.x;\r\n        let localXSin = localX * sin;\r\n        let localYCos = localY * cos + this.y;\r\n        let localYSin = localY * sin;\r\n        let localX2Cos = localX2 * cos + this.x;\r\n        let localX2Sin = localX2 * sin;\r\n        let localY2Cos = localY2 * cos + this.y;\r\n        let localY2Sin = localY2 * sin;\r\n        let offset = this.offset;\r\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n    }\r\n\r\n    setRegion(region: TextureRegion): void {\r\n        this.region = region;\r\n        let uvs = this.uvs;\r\n        if (region.rotate) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        let vertexOffset = this.offset;\r\n        let mat = bone instanceof Slot? bone.bone.matrix : bone.matrix;\r\n        let x = mat.tx, y = mat.ty;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let offsetX = 0, offsetY = 0;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX1];\r\n        offsetY = vertexOffset[RegionAttachment.OY1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX2];\r\n        offsetY = vertexOffset[RegionAttachment.OY2];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX3];\r\n        offsetY = vertexOffset[RegionAttachment.OY3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX4];\r\n        offsetY = vertexOffset[RegionAttachment.OY4];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n}\r\n", "import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class JitterEffect implements VertexEffect {\r\n    jitterX = 0;\r\n    jitterY = 0;\r\n\r\n    constructor (jitterX: number, jitterY: number) {\r\n        this.jitterX = jitterX;\r\n        this.jitterY = jitterY;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n    }\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n", "import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, PowOut, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SwirlEffect implements VertexEffect {\r\n    static interpolation = new PowOut(2);\r\n    centerX = 0;\r\n    centerY = 0;\r\n    radius = 0;\r\n    angle = 0;\r\n    private worldX = 0;\r\n    private worldY = 0;\r\n\r\n    constructor (radius: number) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n        this.worldX = skeleton.x + this.centerX;\r\n        this.worldY = skeleton.y + this.centerY;\r\n    }\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        let radAngle = this.angle * MathUtils.degreesToRadians;\r\n        let x = position.x - this.worldX;\r\n        let y = position.y - this.worldY;\r\n        let dist = Math.sqrt(x * x + y * y);\r\n        if (dist < this.radius) {\r\n            let theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n            let cos = Math.cos(theta);\r\n            let sin = Math.sin(theta);\r\n            position.x = cos * x - sin * y + this.worldX;\r\n            position.y = sin * x + cos * y + this.worldY;\r\n        }\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n", "import {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport {Attachment, VertexAttachment} from \"./attachments\";\r\nimport {ArrayLike, MathUtils, Utils, MixBlend, MixDirection, IAnimation, ITimeline} from '@pixi-spine/base';\r\nimport {Slot} from \"./Slot\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Animation implements IAnimation<Timeline> {\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    duration: number;\r\n\r\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.duration = duration;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n\r\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target)\r\n                low = current + 1;\r\n            else\r\n                high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step)\r\n            if (values[i] > target) return i;\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Timeline extends ITimeline {\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n    getPropertyId (): number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TimelineType {\r\n    rotate, translate, scale, shear,\r\n    attachment, color, deform,\r\n    event, drawOrder,\r\n    ikConstraint, transformConstraint,\r\n    pathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\r\n    twoColor\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    abstract getPropertyId(): number;\r\n\r\n    constructor (frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    setLinear (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    setStepped (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    getCurveType (frameIndex: number): number {\r\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        let type = this.curves[index];\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let curves = this.curves;\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx, y = dfy;\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    getCurvePercent (frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        let curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let type = curves[i];\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number, prevY: number;\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        let y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    boneIndex: number;\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.rotate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, degrees: number) {\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                    return;\r\n                case MixBlend.first:\r\n                    let r = bone.data.rotation - bone.rotation;\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\r\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + r * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n                case MixBlend.add:\r\n                    bone.rotation += r * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent((frame >> 1) - 1,\r\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\r\n    static X = 1; static Y = 2;\r\n\r\n    boneIndex: number;\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.translate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + TranslateTimeline.PREV_X];\r\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n            x = frames[frame + TranslateTimeline.PREV_X];\r\n            y = frames[frame + TranslateTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.scale << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n            x = frames[frame + ScaleTimeline.PREV_X];\r\n            y = frames[frame + ScaleTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n        }\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0, by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.shear << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\r\n            x = frames[frames.length + ShearTimeline.PREV_X];\r\n            y = frames[frames.length + ShearTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n            x = frames[frame + ShearTimeline.PREV_X];\r\n            y = frames[frame + ShearTimeline.PREV_Y];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\r\n    static R = 1; static G = 2; static B = 3; static A = 4;\r\n\r\n    slotIndex: number;\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.color << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    return;\r\n                case MixBlend.first:\r\n                    let color = slot.color, setup = slot.data.color;\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\r\n                        (setup.a - color.a) * alpha);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0;\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        if (alpha == 1)\r\n            slot.color.set(r, g, b, a);\r\n        else {\r\n            let color = slot.color;\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 8;\r\n    static PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\r\n    static PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\r\n    static R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\r\n\r\n    slotIndex: number;\r\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.twoColor << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frameIndex *= TwoColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    slot.darkColor.setFromColor(slot.data.darkColor);\r\n                    return;\r\n                case MixBlend.first:\r\n                    let light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\r\n                        (setupLight.a - light.a) * alpha);\r\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            r = frames[i + TwoColorTimeline.PREV_R];\r\n            g = frames[i + TwoColorTimeline.PREV_G];\r\n            b = frames[i + TwoColorTimeline.PREV_B];\r\n            a = frames[i + TwoColorTimeline.PREV_A];\r\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n            r = frames[frame + TwoColorTimeline.PREV_R];\r\n            g = frames[frame + TwoColorTimeline.PREV_G];\r\n            b = frames[frame + TwoColorTimeline.PREV_B];\r\n            a = frames[frame + TwoColorTimeline.PREV_A];\r\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n        }\r\n        if (alpha == 1) {\r\n            slot.color.set(r, g, b, a);\r\n            slot.darkColor.set(r2, g2, b2, 1);\r\n        } else {\r\n            let light = slot.color, dark = slot.darkColor;\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                dark.setFromColor(slot.data.darkColor);\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AttachmentTimeline implements Timeline {\r\n    slotIndex: number;\r\n    frames: ArrayLike<number> // time, ...\r\n    attachmentNames: Array<string>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.attachment << 24) + this.slotIndex;\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            let attachmentName = slot.data.attachmentName;\r\n            slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n            return;\r\n        }\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) {\r\n                let attachmentName = slot.data.attachmentName;\r\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n            }\r\n            return;\r\n        }\r\n\r\n        let frameIndex = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        let attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex]\r\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nlet zeros : ArrayLike<number> = null;\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DeformTimeline extends CurveTimeline {\r\n    slotIndex: number;\r\n    attachment: VertexAttachment;\r\n    frames: ArrayLike<number>; // time, ...\r\n    frameVertices: Array<ArrayLike<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n        if (zeros == null) zeros = Utils.newFloatArray(64);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot: Slot = skeleton.slots[this.slotIndex];\r\n        let slotAttachment: Attachment = slot.getAttachment();\r\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\r\n\r\n        let verticesArray: Array<number> = slot.attachmentVertices;\r\n        if (verticesArray.length == 0) blend = MixBlend.setup;\r\n\r\n        let frameVertices = this.frameVertices;\r\n        let vertexCount = frameVertices[0].length;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            let vertexAttachment = <VertexAttachment>slotAttachment;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    verticesArray.length = 0;\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        verticesArray.length = 0;\r\n                        break;\r\n                    }\r\n                    let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            vertices[i] += (setupVertices[i] - vertices[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            vertices[i] *= alpha;\r\n                    }\r\n            }\r\n            return;\r\n        }\r\n\r\n        let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\r\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n            let lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            vertices[i] += lastVertices[i] - setupVertices[i];\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            vertices[i] += lastVertices[i];\r\n                    }\r\n                } else {\r\n                    Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let setup = setupVertices[i];\r\n                                vertices[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                vertices[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n                    case MixBlend.add:\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                vertices[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time);\r\n        let prevVertices = frameVertices[frame - 1];\r\n        let nextVertices = frameVertices[frame];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                let vertexAttachment = slotAttachment as VertexAttachment;\r\n                if (vertexAttachment.bones == null) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    let setupVertices = vertexAttachment.vertices;\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    let prev = prevVertices[i];\r\n                    vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i], setup = setupVertices[i];\r\n                            vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventTimeline implements Timeline {\r\n    frames: ArrayLike<number>; // time, ...\r\n    events: Array<Event>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return TimelineType.event << 24;\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe. */\r\n    setFrame (frameIndex: number, event: Event) {\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (firedEvents == null) return;\r\n        let frames = this.frames;\r\n        let frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n        if (lastTime < frames[0])\r\n            frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            let frameTime = frames[frame];\r\n            while (frame > 0) { // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++)\r\n            firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DrawOrderTimeline implements Timeline {\r\n    frames: ArrayLike<number>; // time, ...\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return TimelineType.drawOrder << 24;\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe.\r\n     * @param drawOrder May be null to use bind pose draw order. */\r\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        let slots: Array<Slot> = skeleton.slots;\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let frame = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else\r\n            frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        let drawOrderToSetupIndex = this.drawOrders[frame];\r\n        if (drawOrderToSetupIndex == null)\r\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_MIX = -4; static PREV_BEND_DIRECTION = -3; static PREV_COMPRESS = -2; static PREV_STRETCH = -1;\r\n    static MIX = 1; static BEND_DIRECTION = 2; static COMPRESS = 3; static STRETCH = 4;\r\n\r\n    ikConstraintIndex: number;\r\n    frames: ArrayLike<number>; // time, mix, bendDirection, compress, stretch, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time, mix and bend direction of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, mix: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            if (blend == MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                if (direction == MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                } else {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            } else {\r\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                if (direction == MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\r\n\r\n    transformConstraintIndex: number;\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time and mixes of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n\r\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n        if (time < frames[0]) {\r\n            let data = constraint.data;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate = 0, translate = 0, scale = 0, shear = 0;\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    pathConstraintIndex: number;\r\n\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, value: number) {\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let position = 0;\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\r\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\r\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n        }\r\n        if (blend == MixBlend.setup)\r\n            constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else\r\n            constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let spacing = 0;\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\r\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\r\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else\r\n            constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2;\r\n\r\n    pathConstraintIndex: number;\r\n\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId () {\r\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time and mixes of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let frames = this.frames;\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = constraint.data.rotateMix;\r\n                    constraint.translateMix = constraint.data.translateMix;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate = 0, translate = 0;\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\r\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\r\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n        }\r\n    }\r\n}\r\n", "import {\r\n    IAnimationState,\r\n    IAnimationStateListener,\r\n    ITrackEntry,\r\n    MathUtils,\r\n    MixBlend,\r\n    MixDirection,\r\n    Pool,\r\n    IntSet,\r\n    Utils\r\n} from \"@pixi-spine/base\";\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    DrawOrderTimeline,\r\n    RotateTimeline, Timeline\r\n} from './Animation';\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static emptyAnimation = new Animation(\"<empty>\", [], 0);\r\n    static SUBSEQUENT = 0;\r\n    static FIRST = 1;\r\n    static HOLD = 2;\r\n    static HOLD_MIX = 3;\r\n\r\n    data: AnimationStateData;\r\n    tracks = new Array<TrackEntry>();\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new IntSet();\r\n    animationsChanged = false;\r\n    timeScale = 1;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor (data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (current == null) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n            if (next != null) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                let nextTime = current.trackLast - next.delay;\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom != null) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from = current.mixingFrom;\r\n                current.mixingFrom = null;\r\n                if (from != null) from.mixingTo = null;\r\n                while (from != null) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    updateMixingFrom (to: TrackEntry, delta: number): boolean {\r\n        let from = to.mixingFrom;\r\n        if (from == null) return true;\r\n\r\n        let finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n        return false;\r\n    }\r\n\r\n    apply (skeleton: Skeleton) : boolean {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        let events = this.events;\r\n        let tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (current == null || current.delay > 0) continue;\r\n            applied = true;\r\n            let blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n            if (current.mixingFrom != null)\r\n                mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && current.next == null)\r\n                mix = 0;\r\n\r\n            // Apply current entry.\r\n            let animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n            let timelineCount = current.animation.timelines.length;\r\n            let timelines = current.animation.timelines;\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                let timelineMode = current.timelineMode;\r\n\r\n                let firstFrame = current.timelinesRotation.length == 0;\r\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                let timelinesRotation = current.timelinesRotation;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    let timeline = timelines[ii];\r\n                    let timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\r\n                    if (timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        this.queue.drain();\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        let from = to.mixingFrom;\r\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n        if (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        let events = mix < from.eventThreshold ? this.events : null;\r\n        let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n        let animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n        let timelineCount = from.animation.timelines.length;\r\n        let timelines = from.animation.timelines;\r\n        let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++)\r\n                timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            let timelineMode = from.timelineMode;\r\n            let timelineHoldMix = from.timelineHoldMix;\r\n\r\n            let firstFrame = from.timelinesRotation.length == 0;\r\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n            let timelinesRotation = from.timelinesRotation;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                let timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n                switch (timelineMode[i]) {\r\n                    case AnimationState.SUBSEQUENT:\r\n                        if (!attachments && timeline instanceof AttachmentTimeline) continue;\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.HOLD:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        let holdMix = timelineHoldMix[i];\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n                if (timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (timelineBlend == MixBlend.setup) {\r\n                        if (timeline instanceof AttachmentTimeline) {\r\n                            if (attachments) direction = MixDirection.mixOut;\r\n                        } else if (timeline instanceof DrawOrderTimeline) {\r\n                            if (drawOrder) direction = MixDirection.mixOut;\r\n                        }\r\n                    }\r\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\r\n                         timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n            return;\r\n        }\r\n\r\n        let rotateTimeline = timeline as RotateTimeline;\r\n        let frames = rotateTimeline.frames;\r\n        let bone = skeleton.bones[rotateTimeline.boneIndex];\r\n        let r1 = 0, r2 = 0;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\r\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n            else {\r\n                // Interpolate between the previous frame and the current frame.\r\n                let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n                let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n                let frameTime = frames[frame];\r\n                let percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\r\n                    1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n            }\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0, diff = r2 - r1;\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0, lastDiff = 0;\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            let current = diff > 0, dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        r1 += total * alpha;\r\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n    }\r\n\r\n    queueEvents (entry: TrackEntry, animationTime: number) {\r\n        let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n        let duration = animationEnd - animationStart;\r\n        let trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        let events = this.events;\r\n        let i = 0, n = events.length;\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n        if (entry.loop)\r\n            complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else\r\n            complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, events[i]);\r\n        }\r\n    }\r\n\r\n    clearTracks () {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (current == null) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.disposeNext(current);\r\n\r\n        let entry = current;\r\n        while (true) {\r\n            let from = entry.mixingFrom;\r\n            if (from == null) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\r\n        let from = this.expandToIndex(index);\r\n        this.tracks[index] = current;\r\n\r\n        if (from != null) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom != null && from.mixDuration > 0)\r\n                current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\r\n        if (animation == null) throw new Error(\"animation cannot be null.\");\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current != null) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else\r\n                this.disposeNext(current);\r\n        }\r\n        let entry = this.trackEntry(trackIndex, animation, loop, current);\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n        return entry;\r\n    }\r\n\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n        if (animation == null) throw new Error(\"animation cannot be null.\");\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last != null) {\r\n            while (last.next != null)\r\n                last = last.next;\r\n        }\r\n\r\n        let entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (last == null) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            if (delay <= 0) {\r\n                let duration = last.animationEnd - last.animationStart;\r\n                if (duration != 0) {\r\n                    if (last.loop)\r\n                        delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                    else\r\n                        delay += Math.max(duration, last.trackTime);\r\n                    delay -= this.data.getMix(last.animation, animation);\r\n                } else\r\n                    delay = last.trackTime;\r\n            }\r\n        }\r\n\r\n        entry.delay = delay;\r\n        return entry;\r\n    }\r\n\r\n    setEmptyAnimation (trackIndex: number, mixDuration: number) {\r\n        let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\r\n        if (delay <= 0) delay -= mixDuration;\r\n        let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    setEmptyAnimations (mixDuration: number) {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let current = this.tracks[i];\r\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\r\n        let entry = this.trackEntryPool.obtain();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.interruptAlpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n        return entry;\r\n    }\r\n\r\n    disposeNext (entry: TrackEntry) {\r\n        let next = entry.next;\r\n        while (next != null) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged () {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let entry = this.tracks[i];\r\n            if (entry == null) continue;\r\n            while (entry.mixingFrom != null)\r\n                entry = entry.mixingFrom;\r\n\r\n            do {\r\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.setTimelineModes(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry != null)\r\n        }\r\n    }\r\n\r\n    setTimelineModes (entry: TrackEntry) {\r\n        let to = entry.mixingTo;\r\n        let timelines = entry.animation.timelines;\r\n        let timelinesCount = entry.animation.timelines.length;\r\n        let timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n        entry.timelineHoldMix.length = 0;\r\n        let timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n        let propertyIDs = this.propertyIDs;\r\n\r\n        if (to != null && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                propertyIDs.add(timelines[i].getPropertyId());\r\n                timelineMode[i] = AnimationState.HOLD;\r\n            }\r\n            return;\r\n        }\r\n\r\n        outer:\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                let id = timelines[i].getPropertyId();\r\n                if (!propertyIDs.add(id))\r\n                    timelineMode[i] = AnimationState.SUBSEQUENT;\r\n                else if (to == null || !this.hasTimeline(to, id))\r\n                    timelineMode[i] = AnimationState.FIRST;\r\n                else {\r\n                    for (let next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                        if (this.hasTimeline(next, id)) continue;\r\n                        if (entry.mixDuration > 0) {\r\n                            timelineMode[i] = AnimationState.HOLD_MIX;\r\n                            timelineDipMix[i] = next;\r\n                            continue outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                    timelineMode[i] = AnimationState.HOLD;\r\n                }\r\n            }\r\n    }\r\n\r\n    hasTimeline (entry: TrackEntry, id: number) : boolean {\r\n        let timelines = entry.animation.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            if (timelines[i].getPropertyId() == id) return true;\r\n        return false;\r\n    }\r\n\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    addListener (listener: AnimationStateListener) {\r\n        if (listener == null) throw new Error(\"listener cannot be null.\");\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\r\n    removeListener (listener: AnimationStateListener) {\r\n        let index = this.listeners.indexOf(listener);\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    clearListeners () {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    clearListenerNotifications () {\r\n        this.queue.clear();\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TrackEntry implements ITrackEntry {\r\n    animation: Animation;\r\n    next: TrackEntry; mixingFrom: TrackEntry; mixingTo: TrackEntry;\r\n    listener: AnimationStateListener;\r\n    trackIndex: number;\r\n    loop: boolean;\r\n    holdPrevious: boolean;\r\n    eventThreshold: number; attachmentThreshold: number; drawOrderThreshold: number;\r\n    animationStart: number; animationEnd: number; animationLast: number; nextAnimationLast: number;\r\n    delay: number; trackTime: number; trackLast: number; nextTrackLast: number; trackEnd: number; timeScale: number;\r\n    alpha: number; mixTime: number; mixDuration: number; interruptAlpha: number; totalAlpha: number;\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset () {\r\n        this.next = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    getAnimationTime () {\r\n        if (this.loop) {\r\n            let duration = this.animationEnd - this.animationStart;\r\n            if (duration == 0) return this.animationStart;\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    isComplete () {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    resetRotationDirections () {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start (entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n\r\n    deprecateStuff() {\r\n        if (!EventQueue.deprecatedWarning1) {\r\n            EventQueue.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    drain () {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        let objects = this.objects;\r\n        let listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            let type = objects[i] as EventType;\r\n            let entry = objects[i + 1] as TrackEntry;\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].start) listeners[ii].start(entry);\r\n                    //deprecation\r\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\r\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].end) listeners[ii].end(entry);\r\n                    //deprecation\r\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\r\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].dispose) listeners[ii].dispose(entry);\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].complete) listeners[ii].complete(entry);\r\n                    //deprecation\r\n\r\n                    let count = MathUtils.toInt(entry.loopsCount()) ;\r\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\r\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\r\n                    break;\r\n                case EventType.event:\r\n                    let event = objects[i++ + 2] as Event;\r\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].event) listeners[ii].event(entry, event);\r\n                    //deprecation\r\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\r\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear () {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start, interrupt, end, dispose, complete, event\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose? (entry: TrackEntry): void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete? (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event? (entry: TrackEntry, event: Event): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter2 implements AnimationStateListener {\r\n    start (entry: TrackEntry) {\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n    }\r\n}\r\n", "import {SkeletonData} from \"./SkeletonData\";\r\nimport {IAnimationStateData, Map} from '@pixi-spine/base';\r\nimport type {Animation} from './Animation';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\r\n    skeletonData: SkeletonData;\r\n    animationToMixTime: Map<number> = {};\r\n    defaultMix = 0;\r\n\r\n    constructor(skeletonData: SkeletonData) {\r\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    setMix(fromName: string, toName: string, duration: number) {\r\n        let from = this.skeletonData.findAnimation(fromName);\r\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\r\n        let to = this.skeletonData.findAnimation(toName);\r\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setMixByName(fromName: string, toName: string, duration: number) {\r\n        if (!AnimationStateData.deprecatedWarning1) {\r\n            AnimationStateData.deprecatedWarning1 = true;\r\n            console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\r\n        }\r\n        this.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    setMixWith(from: Animation, to: Animation, duration: number) {\r\n        if (from == null) throw new Error(\"from cannot be null.\");\r\n        if (to == null) throw new Error(\"to cannot be null.\");\r\n        let key = from.name + \".\" + to.name;\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    getMix(from: Animation, to: Animation) {\r\n        let key = from.name + \".\" + to.name;\r\n        let value = this.animationToMixTime[key];\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n", "\r\nimport {AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment,\r\n    PathAttachment, PointAttachment, ClippingAttachment} from './attachments';\r\nimport type {TextureAtlas} from \"@pixi-spine/base\";\r\nimport type {Skin} from \"./Skin\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor(atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n        let attachment = new RegionAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n        let attachment = new MeshAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    /** @return May be null to not load an attachment */\r\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n", "import {Matrix} from '@pixi/math';\r\nimport {Updatable} from \"./Updatable\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {IBone, MathUtils, settings, TransformMode, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Bone implements Updatable, IBone {\r\n    //be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    data: BoneData;\r\n    skeleton: Skeleton;\r\n    parent: Bone;\r\n    children = new Array<Bone>();\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 0;\r\n    scaleY = 0;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    ax = 0;\r\n    ay = 0;\r\n    arotation = 0;\r\n    ascaleX = 0;\r\n    ascaleY = 0;\r\n    ashearX = 0;\r\n    ashearY = 0;\r\n    appliedValid = false;\r\n\r\n    sorted = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** NOT USED IN 3.7. Needed for the debug graph code */\r\n    active: boolean = true;\r\n\r\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\r\n    update() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform. */\r\n    updateWorldTransform() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. */\r\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n        this.appliedValid = true;\r\n\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n\r\n        let sx = this.skeleton.scaleX;\r\n        let sy = settings.yDown? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n\r\n        if (parent == null) { // Root bone.\r\n            let skeleton = this.skeleton;\r\n            let rotationY = rotation + 90 + shearY;\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                let rx = rotation + shearX - prx;\r\n                let ry = rotation + shearY - prx + 90;\r\n                let la = MathUtils.cosDeg(rx) * scaleX;\r\n                let lb = MathUtils.cosDeg(ry) * scaleY;\r\n                let lc = MathUtils.sinDeg(rx) * scaleX;\r\n                let ld = MathUtils.sinDeg(ry) * scaleY;\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                let cos = MathUtils.cosDeg(rotation);\r\n                let sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (\r\n                    this.data.transformMode == TransformMode.NoScale\r\n                    && (pa * pd - pb * pc < 0) != (settings.yDown?\r\n                    (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\r\n                        (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\r\n                ) s = -s;\r\n                let r = Math.PI / 2 + Math.atan2(zc, za);\r\n                let zb = Math.cos(r) * s;\r\n                let zd = Math.sin(r) * s;\r\n                let la = MathUtils.cosDeg(shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                let lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    setToSetupPose() {\r\n        let data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    getWorldRotationX() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldRotationY() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldScaleX() {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.a * m.a + m.c * m.c);\r\n    }\r\n\r\n    getWorldScaleY() {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.b * m.b + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\r\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\r\n     * <p>\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\r\n    updateAppliedTransform() {\r\n        this.appliedValid = true;\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (parent == null) {\r\n            this.ax = m.tx;\r\n            this.ay = m.ty;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n            return;\r\n        }\r\n        let pm = parent.matrix;\r\n        let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n        this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n        this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n        let ia = pid * pm.d;\r\n        let id = pid * pm.a;\r\n        let ib = pid * pm.c;\r\n        let ic = pid * pm.b;\r\n        let ra = ia * m.a - ib * m.b;\r\n        let rb = ia * m.c - ib * m.d;\r\n        let rc = id * m.b - ic * m.a;\r\n        let rd = id * m.d - ic * m.c;\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            let det = ra * rd - rb * rc;\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    worldToLocal(world: Vector2) {\r\n        let m = this.matrix;\r\n        let a = m.a, b = m.c, c = m.b, d = m.d;\r\n        let invDet = 1 / (a * d - b * c);\r\n        let x = world.x - m.tx, y = world.y - m.ty;\r\n        world.x = (x * d * invDet - y * b * invDet);\r\n        world.y = (y * a * invDet - x * c * invDet);\r\n        return world;\r\n    }\r\n\r\n    localToWorld(local: Vector2) {\r\n        let m = this.matrix;\r\n        let x = local.x, y = local.y;\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n        return local;\r\n    }\r\n\r\n    worldToLocalRotation (worldRotation: number) {\r\n        let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    localToWorldRotation (localRotation: number) {\r\n        let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    rotateWorld (degrees: number) {\r\n        let mat = this.matrix;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n        this.appliedValid = false;\r\n    }\r\n}\r\n", "import { TransformMode } from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: BoneData;\r\n    length: number;\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    transformMode = TransformMode.Normal;\r\n\r\n    constructor(index: number, name: string, parent: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n", "import {EventData} from \"./EventData\";\r\nimport {IEvent} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Event implements IEvent {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n    volume: number;\r\n    balance: number;\r\n\r\n\r\n    constructor(time: number, data: EventData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n", "import {IEventData} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventData implements IEventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    audioPath: string;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n", "import {Constraint} from \"./Constraint\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraint implements Constraint {\r\n    data: IkConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    bendDirection = 0;\r\n    compress = false;\r\n    stretch = false;\r\n    mix = 1;\r\n\r\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    getOrder () {\r\n        return this.data.order;\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let target = this.target;\r\n        let bones = this.bones;\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n     * coordinate system. */\r\n    apply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        if (!bone.appliedValid) bone.updateAppliedTransform();\r\n        let p = bone.parent.matrix;\r\n        let id = 1 / (p.a * p.d - p.b * p.c);\r\n        let x = targetX - p.tx, y = targetY - p.ty;\r\n        let tx = (x * p.d - y * p.c) * id - bone.ax, ty = (y * p.a - x * p.b) * id - bone.ay;\r\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180) rotationIK += 360;\r\n        let sx = bone.ascaleX, sy = bone.ascaleY;\r\n        if (compress || stretch) {\r\n            let b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                let s = (dd / b - 1) * alpha + 1;\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\r\n            bone.ashearY);\r\n    }\r\n\r\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n     * target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, alpha: number) {\r\n        if (alpha == 0) {\r\n            child.updateWorldTransform();\r\n            return;\r\n        }\r\n        if (!parent.appliedValid) parent.updateAppliedTransform();\r\n        if (!child.appliedValid) child.updateAppliedTransform();\r\n        let px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n        let pmat = parent.matrix;\r\n        let os1 = 0, os2 = 0, s2 = 0;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else\r\n            os2 = 0;\r\n        let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n        let u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        let pp = parent.parent.matrix;\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        let id = 1 / (a * d - b * c), x = targetX - pp.tx, y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py, dd = tx * tx + ty * ty;\r\n        x = cwx - pp.tx;\r\n        y = cwy - pp.ty;\r\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\r\n        outer:\r\n            if (u) {\r\n                l2 *= psx;\r\n                let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                if (cos < -1)\r\n                    cos = -1;\r\n                else if (cos > 1) {\r\n                    cos = 1;\r\n                    if (stretch && l1 + l2 > 0.0001) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                }\r\n                a2 = Math.acos(cos) * bendDir;\r\n                a = l1 + l2 * cos;\r\n                b = l2 * Math.sin(a2);\r\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n            } else {\r\n                a = psx * l2;\r\n                b = psy * l2;\r\n                let aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                let c1 = -2 * bb * l1, c2 = bb - aa;\r\n                d = c1 * c1 - 4 * c2 * c;\r\n                if (d >= 0) {\r\n                    let q = Math.sqrt(d);\r\n                    if (c1 < 0) q = -q;\r\n                    q = -(c1 + q) / 2;\r\n                    let r0 = q / c2, r1 = c / q;\r\n                    let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                    if (r * r <= dd) {\r\n                        y = Math.sqrt(dd - r * r) * bendDir;\r\n                        a1 = ta - Math.atan2(y, r);\r\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                        break outer;\r\n                    }\r\n                }\r\n                let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                c = -a * l1 / (aa - bb);\r\n                if (c >= -1 && c <= 1) {\r\n                    c = Math.acos(c);\r\n                    x = a * Math.cos(c) + l1;\r\n                    y = b * Math.sin(c);\r\n                    d = x * x + y * y;\r\n                    if (d < minDist) {\r\n                        minAngle = c;\r\n                        minDist = d;\r\n                        minX = x;\r\n                        minY = y;\r\n                    }\r\n                    if (d > maxDist) {\r\n                        maxAngle = c;\r\n                        maxDist = d;\r\n                        maxX = x;\r\n                        maxY = y;\r\n                    }\r\n                }\r\n                if (dd <= (minDist + maxDist) / 2) {\r\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                    a2 = minAngle * bendDir;\r\n                } else {\r\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                    a2 = maxAngle * bendDir;\r\n                }\r\n            }\r\n        let os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180) a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180) a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n", "import {BoneData} from \"./BoneData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintData {\r\n    name: string;\r\n    order = 0;\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    bendDirection = 1;\r\n    compress = false;\r\n    stretch = false;\r\n    uniform = false;\r\n    mix = 1;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n", "import type {SlotData} from \"./SlotData\";\r\nimport type {BoneData} from \"./BoneData\";\r\nimport { RotateMode, PositionMode, IPathConstraintData } from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintData implements IPathConstraintData {\r\n    name: string;\r\n    order = 0;\r\n    bones = new Array<BoneData>();\r\n    target: SlotData;\r\n    positionMode: PositionMode;\r\n    spacingMode: SpacingMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number;\r\n    spacing: number;\r\n    rotateMix: number;\r\n    translateMix: number;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum SpacingMode {\r\n    Length, Fixed, Percent\r\n}\r\n", "import {PathAttachment} from \"./attachments\";\r\nimport {Constraint} from \"./Constraint\";\r\nimport {PathConstraintData, SpacingMode} from \"./PathConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, PositionMode, RotateMode, Utils} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraint implements Constraint {\r\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    data: PathConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Slot;\r\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\r\n\r\n    spaces = new Array<number>(); positions = new Array<number>();\r\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findSlot(data.target.name);\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let attachment = this.target.getAttachment();\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n        let translate = translateMix > 0, rotate = rotateMix > 0;\r\n        if (!translate && !rotate) return;\r\n\r\n        let data = this.data;\r\n        let spacingMode = data.spacingMode;\r\n        let lengthSpacing = spacingMode == SpacingMode.Length;\r\n        let rotateMode = data.rotateMode;\r\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\r\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n        let bones = this.bones;\r\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\r\n        let spacing = this.spacing;\r\n        if (scale || lengthSpacing) {\r\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n            for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                let bone = bones[i];\r\n                let setupLength = bone.data.length;\r\n                if (setupLength < PathConstraint.epsilon) {\r\n                    if (scale) lengths[i] = 0;\r\n                    spaces[++i] = 0;\r\n                } else {\r\n                    let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                    let length = Math.sqrt(x * x + y * y);\r\n                    if (scale) lengths[i] = length;\r\n                    spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 1; i < spacesCount; i++)\r\n                spaces[i] = spacing;\r\n        }\r\n\r\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\r\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\r\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n        if (offsetRotation == 0)\r\n            tip = rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            let p = this.target.bone.matrix;\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            let bone = bones[i];\r\n            let mat = bone.matrix;\r\n            mat.tx += (boneX - mat.tx) * translateMix;\r\n            mat.ty += (boneY - mat.ty) * translateMix;\r\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n            if (scale) {\r\n                let length = lengths[i];\r\n                if (length != 0) {\r\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (rotate) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                if (tangents)\r\n                    r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0)\r\n                    r = positions[p + 2];\r\n                else\r\n                    r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    let length = bone.data.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\r\n                           percentSpacing: boolean) {\r\n        let target = this.target;\r\n        let position = this.position;\r\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n        let closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            let lengths = path.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            let pathLength = lengths[curveCount];\r\n            if (percentPosition) position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (let i = 0; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i];\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (;; curve++) {\r\n                    let length = lengths[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else\r\n                        path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                    tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        let curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        if (percentPosition) position *= pathLength;\r\n        if (percentSpacing) {\r\n            for (let i = 0; i < spacesCount; i++)\r\n                spaces[i] *= pathLength;\r\n        }\r\n\r\n        let segments = this.segments;\r\n        let curveLength = 0;\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            let space = spaces[i];\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (;; curve++) {\r\n                let length = curves[curve];\r\n                if (p > length) continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (;; segment++) {\r\n                let length = segments[segment];\r\n                if (p > length) continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n                      out: Array<number>, o: number, tangents: boolean) {\r\n        if (p == 0 || isNaN(p)) p = 0.0001;\r\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n    }\r\n\r\n    getOrder () {\r\n        return this.data.order;\r\n    }\r\n}\r\n", "import {Constraint} from \"./Constraint\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraint implements Constraint {\r\n    data: TransformConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    rotateMix = 0;\r\n    translateMix = 0;\r\n    scaleMix = 0;\r\n    shearMix = 0;\r\n    temp = new Vector2();\r\n\r\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n        this.scaleMix = data.scaleMix;\r\n        this.shearMix = data.shearMix;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    apply() {\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        if (this.data.local) {\r\n            if (this.data.relative)\r\n                this.applyRelativeLocal();\r\n            else\r\n                this.applyAbsoluteLocal();\r\n\r\n        } else {\r\n            if (this.data.relative)\r\n                this.applyRelativeWorld();\r\n            else\r\n                this.applyAbsoluteWorld();\r\n        }\r\n    }\r\n\r\n    applyAbsoluteWorld() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        let targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        let offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            let modified = false;\r\n            let mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += (temp.x - mat.tx) * translateMix;\r\n                mat.ty += (temp.y - mat.ty) * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                let ts = Math.sqrt(ta * ta + tc * tc);\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                ts = Math.sqrt(tb * tb + td * td);\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let b = mat.c, d = mat.d;\r\n                let by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r = by + (r + offsetShearY) * shearMix;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyRelativeWorld() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        let targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect,\r\n            offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            let modified = false;\r\n            let mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += temp.x * translateMix;\r\n                mat.ty += temp.y * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                let b = mat.c, d = mat.d;\r\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyAbsoluteLocal() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n            if (rotateMix != 0) {\r\n                let r = target.arotation - rotation + this.data.offsetRotation;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                rotation += r * rotateMix;\r\n            }\r\n\r\n            let x = bone.ax, y = bone.ay;\r\n            if (translateMix != 0) {\r\n                x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                y += (target.ay - y + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n            }\r\n\r\n            let shearY = bone.ashearY;\r\n            if (shearMix > 0) {\r\n                let r = target.ashearY - shearY + this.data.offsetShearY;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                bone.shearY += r * shearMix;\r\n            }\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    applyRelativeLocal() {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n            shearMix = this.shearMix;\r\n        let target = this.target;\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\r\n            let x = bone.ax, y = bone.ay;\r\n            if (translateMix != 0) {\r\n                x += (target.ax + this.data.offsetX) * translateMix;\r\n                y += (target.ay + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                if (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n            }\r\n\r\n            let shearY = bone.ashearY;\r\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    getOrder() {\r\n        return this.data.order;\r\n    }\r\n}\r\n", "import {Attachment, RegionAttachment, MeshAttachment, PathAttachment} from './attachments';\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {SkeletonData} from \"./SkeletonData\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport {Skin} from \"./Skin\";\r\nimport {Color, Utils, Vector2, ISkeleton} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\r\n    data: SkeletonData;\r\n    bones: Array<Bone>;\r\n    slots: Array<Slot>;\r\n    drawOrder: Array<Slot>;\r\n    ikConstraints: Array<IkConstraint>;\r\n    transformConstraints: Array<TransformConstraint>;\r\n    pathConstraints: Array<PathConstraint>;\r\n    _updateCache = new Array<Updatable>();\r\n    updateCacheReset = new Array<Updatable>();\r\n    skin: Skin;\r\n    color: Color;\r\n    time = 0;\r\n    scaleX = 1; scaleY = 1;\r\n    x = 0; y = 0;\r\n\r\n    constructor (data: SkeletonData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let boneData = data.bones[i];\r\n            let bone: Bone;\r\n            if (boneData.parent == null)\r\n                bone = new Bone(boneData, this, null);\r\n            else {\r\n                let parent = this.bones[boneData.parent.index];\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            let slotData = data.slots[i];\r\n            let bone = this.bones[slotData.boneData.index];\r\n            let slot = new Slot(slotData, bone);\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            let ikConstraintData = data.ikConstraints[i];\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            let transformConstraintData = data.transformConstraints[i];\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            let pathConstraintData = data.pathConstraints[i];\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    updateCache () {\r\n        let updateCache = this._updateCache;\r\n        updateCache.length = 0;\r\n        this.updateCacheReset.length = 0;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].sorted = false;\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        let ikConstraints = this.ikConstraints;\r\n        let transformConstraints = this.transformConstraints;\r\n        let pathConstraints = this.pathConstraints;\r\n        let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n        let constraintCount = ikCount + transformCount + pathCount;\r\n\r\n        outer:\r\n            for (let i = 0; i < constraintCount; i++) {\r\n                for (let ii = 0; ii < ikCount; ii++) {\r\n                    let constraint = ikConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortIkConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < transformCount; ii++) {\r\n                    let constraint = transformConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortTransformConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < pathCount; ii++) {\r\n                    let constraint = pathConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortPathConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n            }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortIkConstraint (constraint: IkConstraint) {\r\n        let target = constraint.target;\r\n        this.sortBone(target);\r\n\r\n        let constrained = constraint.bones;\r\n        let parent = constrained[0];\r\n        this.sortBone(parent);\r\n\r\n        if (constrained.length > 1) {\r\n            let child = constrained[constrained.length - 1];\r\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        this.sortReset(parent.children);\r\n        constrained[constrained.length - 1].sorted = true;\r\n    }\r\n\r\n    sortPathConstraint (constraint: PathConstraint) {\r\n        let slot = constraint.target;\r\n        let slotIndex = slot.data.index;\r\n        let slotBone = slot.bone;\r\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n            this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n        for (let i = 0, n = this.data.skins.length; i < n; i++)\r\n            this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n        let attachment = slot.getAttachment();\r\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortBone(constrained[i]);\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++)\r\n            constrained[i].sorted = true;\r\n    }\r\n\r\n    sortTransformConstraint (constraint: TransformConstraint) {\r\n        this.sortBone(constraint.target);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        if (constraint.data.local) {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                let child = constrained[i];\r\n                this.sortBone(child.parent);\r\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n            }\r\n        } else {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                this.sortBone(constrained[i]);\r\n            }\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let ii = 0; ii < boneCount; ii++)\r\n            this.sortReset(constrained[ii].children);\r\n        for (let ii = 0; ii < boneCount; ii++)\r\n            constrained[ii].sorted = true;\r\n    }\r\n\r\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        let attachments = skin.attachments[slotIndex];\r\n        if (!attachments) return;\r\n        for (let key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        let pathBones = (<PathAttachment>attachment).bones;\r\n        if (pathBones == null)\r\n            this.sortBone(slotBone);\r\n        else {\r\n            let bones = this.bones;\r\n            let i = 0;\r\n            while (i < pathBones.length) {\r\n                let boneCount = pathBones[i++];\r\n                for (let n = i + boneCount; i < n; i++) {\r\n                    let boneIndex = pathBones[i];\r\n                    this.sortBone(bones[boneIndex]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone (bone: Bone) {\r\n        if (bone.sorted) return;\r\n        let parent = bone.parent;\r\n        if (parent != null) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset (bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies constraints. */\r\n    updateWorldTransform () {\r\n        let updateCacheReset = this.updateCacheReset;\r\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\r\n            let bone = updateCacheReset[i] as Bone;\r\n            bone.ax = bone.x;\r\n            bone.ay = bone.y;\r\n            bone.arotation = bone.rotation;\r\n            bone.ascaleX = bone.scaleX;\r\n            bone.ascaleY = bone.scaleY;\r\n            bone.ashearX = bone.shearX;\r\n            bone.ashearY = bone.shearY;\r\n            bone.appliedValid = true;\r\n        }\r\n        let updateCache = this._updateCache;\r\n        for (let i = 0, n = updateCache.length; i < n; i++)\r\n            updateCache[i].update();\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose () {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose () {\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.mix = constraint.data.mix;\r\n        }\r\n\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n        }\r\n    }\r\n\r\n    setSlotsToSetupPose () {\r\n        let slots = this.slots;\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @return May return null. */\r\n    getRootBone () {\r\n        if (this.bones.length == 0) return null;\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findBone (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findSlot (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     * @see #setSkin(Skin) */\r\n    setSkinByName (skinName: string) {\r\n        let skin = this.data.findSkin(skinName);\r\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin (newSkin: Skin | null) {\r\n        if (newSkin != null) {\r\n            if (this.skin != null)\r\n                newSkin.attachAll(this, this.skin);\r\n            else {\r\n                let slots = this.slots;\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    let slot = slots[i];\r\n                    let name = slot.data.attachmentName;\r\n                    if (name != null) {\r\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\r\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\r\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\r\n        if (this.skin != null) {\r\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment != null) return attachment;\r\n        }\r\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    }\r\n\r\n    /** @param attachmentName May be null. */\r\n    setAttachment (slotName: string, attachmentName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment = null;\r\n                if (attachmentName != null) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (attachment == null)\r\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(\"Slot not found: \" + slotName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let ikConstraint = ikConstraints[i];\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size The width and height of the AABB.\r\n     * @param temp Working memory */\r\n    getBounds (offset: Vector2, size: Vector2, temp: Array<number>) {\r\n        if (offset == null) throw new Error(\"offset cannot be null.\");\r\n        if (size == null) throw new Error(\"size cannot be null.\");\r\n        let drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = drawOrder[i];\r\n            let verticesLength = 0;\r\n            let vertices: ArrayLike<number> = null;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof RegionAttachment) {\r\n                verticesLength = 8;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\r\n            } else if (attachment instanceof MeshAttachment) {\r\n                let mesh = (<MeshAttachment>attachment);\r\n                verticesLength = mesh.worldVerticesLength;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n            }\r\n            if (vertices != null) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                    let x = vertices[ii], y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    update (delta: number) {\r\n        this.time += delta;\r\n    }\r\n\r\n    get flipX(): boolean {\r\n        return this.scaleX == -1;\r\n    }\r\n\r\n    set flipX(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleX = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    get flipY(): boolean {\r\n        return this.scaleY == -1;\r\n    }\r\n\r\n    set flipY(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleY = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n}\r\n", "import {BoundingBoxAttachment} from \"./attachments\";\r\nimport {SkeletonBoundsBase} from \"@pixi-spine/base\";\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\n export class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment>{};", "import type {ISkeletonData} from \"@pixi-spine/base\";\r\nimport type {Animation} from \"./Animation\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {EventData} from \"./EventData\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData} from \"./PathConstraintData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\r\n    name: string;\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n    defaultSkin: Skin;\r\n    events = new Array<EventData>();\r\n    animations = new Array<Animation>();\r\n    ikConstraints = new Array<IkConstraintData>();\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n    pathConstraints = new Array<PathConstraintData>();\r\n    width: number;\r\n    height: number;\r\n    version: string;\r\n    hash: string;\r\n\r\n    // Nonessential\r\n    fps = 0;\r\n    imagesPath: string;\r\n\r\n    findBone(boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findBoneIndex(boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSlot(slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findSlotIndex(slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSkin(skinName: string) {\r\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\r\n        let skins = this.skins;\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            let skin = skins[i];\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findEvent(eventDataName: string) {\r\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\r\n        let events = this.events;\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findAnimation(animationName: string) {\r\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\r\n        let animations = this.animations;\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            let animation = animations[i];\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findIkConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findTransformConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraintIndex(pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n            if (pathConstraints[i].name == pathConstraintName) return i;\r\n        return -1;\r\n    }\r\n}\r\n", "import {Color} from '@pixi-spine/base';\r\n\r\nimport type {ISlotData} from '@pixi-spine/base';\r\nimport type {BLEND_MODES} from '@pixi/constants';\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SlotData implements ISlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: BoneData;\r\n    color = new Color(1, 1, 1, 1);\r\n    darkColor: Color;\r\n    attachmentName: string;\r\n    blendMode: BLEND_MODES;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n", "import {BoneData} from './BoneData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintData {\r\n    name: string;\r\n    order = 0;\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\r\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor (name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n}\r\n", "import {Attachment} from './attachments';\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\nimport type {Map, ISkin} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skin implements ISkin {\r\n    name: string;\r\n    attachments = new Array<Map<Attachment>>();\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    addAttachment(slotIndex: number, name: string, attachment: Attachment) {\r\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\r\n        let attachments = this.attachments;\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment(slotIndex: number, name: string): Attachment {\r\n        let dictionary = this.attachments[slotIndex];\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            let slot = skeleton.slots[i];\r\n            let slotAttachment = slot.getAttachment();\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                let dictionary = oldSkin.attachments[slotIndex];\r\n                for (let key in dictionary) {\r\n                    let skinAttachment: Attachment = dictionary[key];\r\n                    if (slotAttachment == skinAttachment) {\r\n                        let attachment = this.getAttachment(slotIndex, key);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n", "import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {Animation} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {\r\n    AttachmentTimeline,\r\n    ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline\r\n} from './Animation';\r\nimport {ArrayLike, Color, Utils, PositionMode, RotateMode, TransformMode, settings} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (json: string | any): SkeletonData {\r\n        let scale = this.scale;\r\n        let skeletonData = new SkeletonData();\r\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        let skeletonMap = root.skeleton;\r\n        if (skeletonMap != null) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                let boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                }\r\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                let slotMap = root.slots[i];\r\n                let slotName: string = slotMap.name;\r\n                let boneName: string = slotMap.bone;\r\n                let boneData = skeletonData.findBone(boneName);\r\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                let color: string = this.getValue(slotMap, \"color\", null);\r\n                if (color != null) data.color.setFromString(color);\r\n\r\n                let dark: string = this.getValue(slotMap, \"dark\", null);\r\n                if (dark != null) {\r\n                    data.darkColor = new Color(1, 1, 1, 1);\r\n                    data.darkColor.setFromString(dark);\r\n                }\r\n\r\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                let constraintMap = root.ik[i];\r\n                let data = new IkConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\r\n\r\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                let constraintMap = root.transform[i];\r\n                let data = new TransformConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n                data.local = this.getValue(constraintMap, \"local\", false);\r\n                data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                let constraintMap = root.path[i];\r\n                let data = new PathConstraintData(constraintMap.name);\r\n                data.order = this.getValue(constraintMap, \"order\", 0);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.position = this.getValue(constraintMap, \"position\", 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let skinName in root.skins) {\r\n                let skinMap = root.skins[skinName]\r\n                let skin = new Skin(skinName);\r\n                for (let slotName in skinMap) {\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                    let slotMap = skinMap[slotName];\r\n                    for (let entryName in slotMap) {\r\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\r\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n            //linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (let eventName in root.events) {\r\n                let eventMap = root.events[eventName];\r\n                let data = new EventData(eventName);\r\n                data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                if (data.audioPath != null) {\r\n                    data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                    data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (let animationName in root.animations) {\r\n                let animationMap = root.animations[animationName];\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n        let scale = this.scale;\r\n        name = this.getValue(map, \"name\", name);\r\n\r\n        let type = this.getValue(map, \"type\", \"region\");\r\n\r\n        switch (type) {\r\n            case \"region\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = this.getValue(map, \"x\", 0) * scale;\r\n                region.y = this.getValue(map, \"y\", 0) * scale;\r\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                region.rotation = this.getValue(map, \"rotation\", 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) region.color.setFromString(color);\r\n\r\n                //region.updateOffset();\r\n                return region;\r\n            }\r\n            case \"boundingbox\": {\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (box == null) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) box.color.setFromString(color);\r\n                return box;\r\n            }\r\n            case \"mesh\":\r\n            case \"linkedmesh\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n\r\n                let color = this.getValue(map, \"color\", null);\r\n                if (color != null) mesh.color.setFromString(color);\r\n\r\n                let parent: string = this.getValue(map, \"parent\", null);\r\n                if (parent != null) {\r\n                    mesh.inheritDeform = this.getValue(map, \"deform\", true);\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\r\n                    return mesh;\r\n                }\r\n\r\n                let uvs: Array<number> = map.uvs;\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                //mesh.updateUVs();\r\n\r\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                return mesh;\r\n            }\r\n            case \"path\": {\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (path == null) return null;\r\n                path.closed = this.getValue(map, \"closed\", false);\r\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0; i < map.lengths.length; i++)\r\n                    lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) path.color.setFromString(color);\r\n                return path;\r\n            }\r\n            case \"point\": {\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (point == null) return null;\r\n                point.x = this.getValue(map, \"x\", 0) * scale;\r\n                point.y = this.getValue(map, \"y\", 0) * scale;\r\n                point.rotation = this.getValue(map, \"rotation\", 0);\r\n\r\n                let color = this.getValue(map, \"color\", null);\r\n                if (color != null) point.color.setFromString(color);\r\n                return point;\r\n            }\r\n            case \"clipping\": {\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (clip == null) return null;\r\n\r\n                let end = this.getValue(map, \"end\", null);\r\n                if (end != null) {\r\n                    let slot = skeletonData.findSlot(end);\r\n                    if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) clip.color.setFromString(color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        let scale = this.scale;\r\n        attachment.worldVerticesLength = verticesLength;\r\n        let vertices: Array<number> = map.vertices;\r\n        if (verticesLength == vertices.length) {\r\n            let scaledVertices = Utils.toFloatArray(vertices);\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++)\r\n                    scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n            return;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bones = new Array<number>();\r\n        for (let i = 0, n = vertices.length; i < n;) {\r\n            let boneCount = vertices[i++];\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n        let scale = this.scale;\r\n        let timelines = new Array<Timeline>();\r\n        let duration = 0;\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (let slotName in map.slots) {\r\n                let slotMap = map.slots[slotName];\r\n                let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                for (let timelineName in slotMap) {\r\n                    let timelineMap = slotMap[timelineName];\r\n                    if (timelineName == \"attachment\") {\r\n                        let timeline = new AttachmentTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    } else if (timelineName == \"color\") {\r\n                        let timeline = new ColorTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let color = new Color();\r\n                            color.setFromString(valueMap.color || \"ffffffff\");\r\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName == \"twoColor\") {\r\n                        let timeline = new TwoColorTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let light = new Color();\r\n                            let dark = new Color();\r\n                            light.setFromString(valueMap.light);\r\n                            dark.setFromString(valueMap.dark);\r\n                            timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (let boneName in map.bones) {\r\n                let boneMap = map.bones[boneName];\r\n                let boneIndex = skeletonData.findBoneIndex(boneName);\r\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n                for (let timelineName in boneMap) {\r\n                    let timelineMap = boneMap[timelineName];\r\n                    if (timelineName === \"rotate\") {\r\n                        let timeline = new RotateTimeline(timelineMap.length);\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                        let timeline: TranslateTimeline = null;\r\n                        let timelineScale = 1;\r\n                        if (timelineName === \"scale\")\r\n                            timeline = new ScaleTimeline(timelineMap.length);\r\n                        else if (timelineName === \"shear\")\r\n                            timeline = new ShearTimeline(timelineMap.length);\r\n                        else {\r\n                            timeline = new TranslateTimeline(timelineMap.length);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\r\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (let constraintName in map.ik) {\r\n                let constraintMap = map.ik[constraintName];\r\n                let constraint = skeletonData.findIkConstraint(constraintName);\r\n                let timeline = new IkConstraintTimeline(constraintMap.length);\r\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\r\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (let constraintName in map.transform) {\r\n                let constraintMap = map.transform[constraintName];\r\n                let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\r\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\r\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration,\r\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.paths) {\r\n            for (let constraintName in map.paths) {\r\n                let constraintMap = map.paths[constraintName];\r\n                let index = skeletonData.findPathConstraintIndex(constraintName);\r\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                let data = skeletonData.pathConstraints[index];\r\n                for (let timelineName in constraintMap) {\r\n                    let timelineMap = constraintMap[timelineName];\r\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                        let timeline: PathConstraintPositionTimeline = null;\r\n                        let timelineScale = 1;\r\n                        if (timelineName === \"spacing\") {\r\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    } else if (timelineName === \"mix\") {\r\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\r\n                                this.getValue(valueMap, \"translateMix\", 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (let deformName in map.deform) {\r\n                let deformMap = map.deform[deformName];\r\n                let skin = skeletonData.findSkin(deformName);\r\n                if (skin == null) {\r\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                        throw new Error(\"Skin not found: \" + deformName);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }                for (let slotName in deformMap) {\r\n                    let slotMap = deformMap[slotName];\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n                    for (let timelineName in slotMap) {\r\n                        let timelineMap = slotMap[timelineName];\r\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                        let weighted = attachment.bones != null;\r\n                        let vertices = attachment.vertices;\r\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                        let timeline = new DeformTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let j = 0; j < timelineMap.length; j++) {\r\n                            let valueMap = timelineMap[j];\r\n                            let deform: ArrayLike<number>;\r\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\r\n                            if (verticesValue == null)\r\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                        deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++)\r\n                                        deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderNode = map.drawOrder;\r\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n        if (drawOrderNode != null) {\r\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n            let slotCount = skeletonData.slots.length;\r\n            let frameIndex = 0;\r\n            for (let j = 0; j < drawOrderNode.length; j++) {\r\n                let drawOrderMap = drawOrderNode[j];\r\n                let drawOrder: Array<number> = null;\r\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                if (offsets != null) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0, unchangedIndex = 0;\r\n                    for (let i = 0; i < offsets.length; i++) {\r\n                        let offsetMap = offsets[i];\r\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let i = slotCount - 1; i >= 0; i--)\r\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        if (map.events) {\r\n            let timeline = new EventTimeline(map.events.length);\r\n            let frameIndex = 0;\r\n            for (let i = 0; i < map.events.length; i++) {\r\n                let eventMap = map.events[i];\r\n                let eventData = skeletonData.findEvent(eventMap.name);\r\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\r\n                let event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\r\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = this.getValue(eventMap, \"volume\", 1);\r\n                    event.balance = this.getValue(eventMap, \"balance\", 0);\r\n                }\r\n                timeline.setFrame(frameIndex++, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        if (isNaN(duration)) {\r\n            throw new Error(\"Error while parsing animation, duration is NaN\");\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n\r\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\r\n        if (!map.curve) return;\r\n        if (map.curve === \"stepped\")\r\n            timeline.setStepped(frameIndex);\r\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\r\n            let curve: Array<number> = map.curve;\r\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n        }\r\n    }\r\n\r\n    getValue (map: any, prop: string, defaultValue: any) {\r\n        return map[prop] !== undefined ? map[prop] : defaultValue;\r\n    }\r\n\r\n    static blendModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return BLEND_MODES.NORMAL;\r\n        if (str == \"additive\") return BLEND_MODES.ADD;\r\n        if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\r\n        if (str == \"screen\") return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n\r\n    static positionModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"fixed\") return PositionMode.Fixed;\r\n        if (str == \"percent\") return PositionMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static spacingModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"length\") return SpacingMode.Length;\r\n        if (str == \"fixed\") return SpacingMode.Fixed;\r\n        if (str == \"percent\") return SpacingMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static rotateModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"tangent\") return RotateMode.Tangent;\r\n        if (str == \"chain\") return RotateMode.Chain;\r\n        if (str == \"chainscale\") return RotateMode.ChainScale;\r\n        throw new Error(`Unknown rotate mode: ${str}`);\r\n    }\r\n\r\n    static transformModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return TransformMode.Normal;\r\n        if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\r\n        if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\r\n        if (str == \"noscale\") return TransformMode.NoScale;\r\n        if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\r\n        throw new Error(`Unknown transform mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n    }\r\n}\r\n", "import {SpineBase} from '@pixi-spine/base';\r\nimport {Skeleton} from \"./core/Skeleton\";\r\nimport {SkeletonData} from \"./core/SkeletonData\";\r\nimport {AnimationState} from \"./core/AnimationState\";\r\nimport {AnimationStateData} from \"./core/AnimationStateData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "import {AttachmentType, Utils} from '@pixi-spine/base';\r\nimport type {IAttachment, NumberArrayLike} from '@pixi-spine/base';\r\n\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * The base class for all attachments.\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor (name: string) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy (): Attachment;\r\n}\r\n\r\n/**\r\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}.\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    /** The unique ID for this attachment. */\r\n    id = VertexAttachment.nextID++;\r\n\r\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n     * if this attachment has no weights. */\r\n    bones: Array<number> | null = null;\r\n\r\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n     * each vertex. */\r\n    vertices: NumberArrayLike = [];\r\n\r\n    /** The maximum number of world vertex values that can be output by\r\n     * {@link #computeWorldVertices()} using the `count` parameter. */\r\n    worldVerticesLength = 0;\r\n\r\n    /** Timelines for the timeline attachment are also applied to this attachment.\r\n     * May be null if no attachment-specific timelines should be applied. */\r\n    timelineAttachment: Attachment = this;\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n     * not empty, it is used to deform the vertices.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide.\r\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n     *           `stride` / 2.\r\n     * @param offset The `worldVertices` index to begin writing values.\r\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n    computeWorldVertices (slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        let skeleton = slot.bone.skeleton;\r\n        let deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        let bones = this.bones;\r\n        if (!bones) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            let mat = slot.bone.matrix;\r\n            let x = mat.tx;\r\n            let y = mat.ty;\r\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                let vx = vertices[v], vy = vertices[v + 1];\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n            return;\r\n        }\r\n        let v = 0, skip = 0;\r\n        for (let i = 0; i < start; i += 2) {\r\n            let n = bones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        let skeletonBones = skeleton.bones;\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            let deform = deformArray;\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does not copy id (generated) or name (set on construction). **/\r\n    copyTo (attachment: VertexAttachment) {\r\n        if (this.bones) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else\r\n            attachment.bones = null;\r\n\r\n        if (this.vertices) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        }\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.timelineAttachment = this.timelineAttachment;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new BoundingBoxAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IClippingAttachment} from '@pixi-spine/base';\r\nimport type {SlotData} from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\r\n     * the skeleton's rendering. */\r\n    endSlot: SlotData | null = null;\r\n\r\n    // Nonessential.\r\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new ClippingAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.endSlot = this.endSlot;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IMeshAttachment, IHasTextureRegion,\r\n    NumberArrayLike, TextureRegion, Utils} from '@pixi-spine/base';\r\nimport {Sequence} from './Sequence';\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion | null = null;\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    /** The UV pair for each vertex, normalized within the texture region. */\r\n    regionUVs: Float32Array;\r\n\r\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\r\n    triangles: Array<number> = [];\r\n\r\n    /** The color to tint the mesh. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\r\n    width: number = 0;\r\n\r\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\r\n    height: number = 0;\r\n\r\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\r\n    hullLength: number = 0;\r\n\r\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n     * nonessential data was exported. Triangulation is not performed at runtime. */\r\n    edges: Array<number> = [];\r\n\r\n    private parentMesh: MeshAttachment | null = null;\r\n\r\n    sequence: Sequence | null = null;\r\n\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor (name: string, path: string) {\r\n        super(name);\r\n        this.path = path;\r\n    }\r\n\r\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\r\n    getParentMesh () {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh (parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength\r\n        }\r\n    }\r\n\r\n    copy (): Attachment {\r\n        if (this.parentMesh) return this.newLinkedMesh();\r\n\r\n        let copy = new MeshAttachment(this.name, this.path);\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\r\n\r\n        // Nonessential.\r\n        if (this.edges) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    computeWorldVertices (slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        if (this.sequence != null) this.sequence.apply(slot, this);\r\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\r\n    }\r\n\r\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\r\n    newLinkedMesh (): MeshAttachment {\r\n        let copy = new MeshAttachment(this.name, this.path);\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n        copy.timelineAttachment = this.timelineAttachment;\r\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\r\n        // if (copy.region != null) copy.updateRegion();\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from \"./Attachment\";\r\nimport {AttachmentType, Color, Utils} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n\r\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\r\n    lengths: Array<number> = [];\r\n\r\n    /** If true, the start and end knots are connected. */\r\n    closed = false;\r\n\r\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\r\n     * calculations are performed but calculating positions along the path is less accurate. */\r\n    constantSpeed = false;\r\n\r\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\r\n     * rendered at runtime. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PathAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.lengths = new Array<number>(this.lengths.length);\r\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n        copy.closed = closed;\r\n        copy.constantSpeed = this.constantSpeed;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport type {Bone} from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n\r\n    x: number = 0;\r\n    y: number = 0;\r\n    rotation: number = 0;\r\n\r\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition (bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation (bone: Bone) {\r\n        const mat = bone.matrix;\r\n        let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\r\n        let x = cos * mat.a + sin * mat.c;\r\n        let y = cos * mat.b + sin * mat.d;\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PointAttachment(this.name);\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.rotation = this.rotation;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n", "import {Attachment} from './Attachment';\r\nimport {AttachmentType, NumberArrayLike, Color, TextureRegion, Utils,\r\n    IHasTextureRegion, IRegionAttachment} from \"@pixi-spine/base\";\r\nimport {Sequence} from './Sequence';\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment, IHasTextureRegion {\r\n    type = AttachmentType.Region;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The width of the region attachment in Spine. */\r\n    width = 0;\r\n\r\n    /** The height of the region attachment in Spine. */\r\n    height = 0;\r\n\r\n    /** The color to tint the region attachment. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    private rendererObject: any = null;\r\n    region: TextureRegion | null = null;\r\n    sequence: Sequence | null = null;\r\n\r\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\r\n     *\r\n     * See {@link #updateOffset()}. */\r\n    offset = Utils.newFloatArray(8);\r\n\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string, path: string) {\r\n        super(name);\r\n        this.path = path;\r\n    }\r\n\r\n    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\r\n    updateRegion (): void {\r\n        if (!this.region) throw new Error(\"Region not set.\");\r\n        let region = this.region;\r\n        let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n        let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n        let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n        let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n        let localX2 = localX + this.region.width * regionScaleX;\r\n        let localY2 = localY + this.region.height * regionScaleY;\r\n        let radians = this.rotation * Math.PI / 180;\r\n        let cos = Math.cos(radians);\r\n        let sin = Math.sin(radians);\r\n        let x = this.x, y = this.y;\r\n        let localXCos = localX * cos + x;\r\n        let localXSin = localX * sin;\r\n        let localYCos = localY * cos + y;\r\n        let localYSin = localY * sin;\r\n        let localX2Cos = localX2 * cos + x;\r\n        let localX2Sin = localX2 * sin;\r\n        let localY2Cos = localY2 * cos + y;\r\n        let localY2Sin = localY2 * sin;\r\n        let offset = this.offset;\r\n        offset[0] = localXCos - localYSin;\r\n        offset[1] = localYCos + localXSin;\r\n        offset[2] = localXCos - localY2Sin;\r\n        offset[3] = localY2Cos + localXSin;\r\n        offset[4] = localX2Cos - localY2Sin;\r\n        offset[5] = localY2Cos + localX2Sin;\r\n        offset[6] = localX2Cos - localYSin;\r\n        offset[7] = localYCos + localX2Sin;\r\n\r\n        let uvs = this.uvs;\r\n        if (region.degrees == 90) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\r\n     * be changed.\r\n     * <p>\r\n     * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\r\n     * Runtimes Guide.\r\n     * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\r\n     * @param offset The <code>worldVertices</code> index to begin writing values.\r\n     * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\r\n    computeWorldVertices (slot: Slot, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        if (this.sequence != null)\r\n            this.sequence.apply(slot, this);\r\n\r\n        let bone = slot.bone;\r\n        let vertexOffset = this.offset;\r\n        let mat = bone.matrix;\r\n        let x = mat.tx, y = mat.ty;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let offsetX = 0, offsetY = 0;\r\n\r\n        offsetX = vertexOffset[0];\r\n        offsetY = vertexOffset[1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[2];\r\n        offsetY = vertexOffset[3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[4];\r\n        offsetY = vertexOffset[5];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[6];\r\n        offsetY = vertexOffset[7];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new RegionAttachment(this.name, this.path);\r\n        copy.region = this.region;\r\n        copy.rendererObject = this.rendererObject;\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.scaleX = this.scaleX;\r\n        copy.scaleY = this.scaleY;\r\n        copy.rotation = this.rotation;\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n        copy.color.setFromColor(this.color);\r\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\r\n        return copy;\r\n    }\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n}\r\n", "import { Utils, TextureRegion, IHasTextureRegion, ISequence } from '@pixi-spine/base';\r\nimport { Slot } from \"../Slot\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Sequence implements ISequence {\r\n\tprivate static _nextID = 0;\r\n\r\n\tid = Sequence.nextID();\r\n\tregions: TextureRegion[];\r\n\tstart = 0;\r\n\tdigits = 0;\r\n\t/** The index of the region to show for the setup pose. */\r\n\tsetupIndex = 0;\r\n\r\n\tconstructor (count: number) {\r\n\t\tthis.regions = new Array<TextureRegion>(count);\r\n\t}\r\n\r\n\tcopy (): Sequence {\r\n\t\tlet copy = new Sequence(this.regions.length);\r\n\t\tUtils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\r\n\t\tcopy.start = this.start;\r\n\t\tcopy.digits = this.digits;\r\n\t\tcopy.setupIndex = this.setupIndex;\r\n\t\treturn copy;\r\n\t}\r\n\r\n\tapply (slot: Slot, attachment: IHasTextureRegion) {\r\n\t\tlet index = slot.sequenceIndex;\r\n\t\tif (index == -1) index = this.setupIndex;\r\n\t\tif (index >= this.regions.length) index = this.regions.length - 1;\r\n\t\tlet region = this.regions[index];\r\n\t\tif (attachment.region != region) {\r\n\t\t\tattachment.region = region;\r\n\t\t\t// attachment.updateRegion();\r\n\t\t}\r\n\t}\r\n\r\n\tgetPath (basePath: string, index: number): string {\r\n\t\tlet result = basePath;\r\n\t\tlet frame = (this.start + index).toString();\r\n\t\tfor (let i = this.digits - frame.length; i > 0; i--)\r\n\t\t\tresult += \"0\";\r\n\t\tresult += frame;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprivate static nextID (): number {\r\n\t\treturn Sequence._nextID++;\r\n\t}\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum SequenceMode {\r\n\thold = 0,\r\n\tonce = 1,\r\n\tloop = 2,\r\n\tpingpong = 3,\r\n\tonceReverse = 4,\r\n\tloopReverse = 5,\r\n\tpingpongReverse = 6\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const SequenceModeValues = [\r\n\tSequenceMode.hold,\r\n\tSequenceMode.once,\r\n\tSequenceMode.loop,\r\n\tSequenceMode.pingpong,\r\n\tSequenceMode.onceReverse,\r\n\tSequenceMode.loopReverse,\r\n\tSequenceMode.pingpongReverse\r\n];\r\n", "import {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport {Attachment, VertexAttachment} from \"./attachments\";\r\nimport {NumberArrayLike, IAnimation, ITimeline, MathUtils,\r\n    MixBlend, StringSet, Utils, MixDirection, IHasTextureRegion} from '@pixi-spine/base';\r\nimport {Slot} from \"./Slot\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport { SequenceMode, SequenceModeValues } from \"./attachments/Sequence\";\r\n\r\n/**\r\n * A simple container for a list of timelines and a name.\r\n * @public\r\n * */\r\nexport class Animation implements IAnimation<Timeline> {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline> = [];\r\n    timelineIds: StringSet = new StringSet();\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n        this.setTimelines(timelines);\r\n        this.duration = duration;\r\n    }\r\n\r\n    setTimelines (timelines: Array<Timeline>) {\r\n        if (!timelines) throw new Error(\"timelines cannot be null.\");\r\n        this.timelines = timelines;\r\n        this.timelineIds.clear();\r\n        for (var i = 0; i < timelines.length; i++)\r\n            this.timelineIds.addAll(timelines[i].getPropertyIds());\r\n    }\r\n\r\n    hasTimeline (ids: string[]): boolean {\r\n        for (let i = 0; i < ids.length; i++)\r\n            if (this.timelineIds.contains(ids[i])) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n}\r\n\r\nconst Property = {\r\n    rotate: 0,\r\n    x: 1,\r\n    y: 2,\r\n    scaleX: 3,\r\n    scaleY: 4,\r\n    shearX: 5,\r\n    shearY: 6,\r\n\r\n    rgb: 7,\r\n    alpha: 8,\r\n    rgb2: 9,\r\n\r\n    attachment: 10,\r\n    deform: 11,\r\n\r\n    event: 12,\r\n    drawOrder: 13,\r\n\r\n    ikConstraint: 14,\r\n    transformConstraint: 15,\r\n\r\n    pathConstraintPosition: 16,\r\n    pathConstraintSpacing: 17,\r\n    pathConstraintMix: 18,\r\n\r\n    sequence: 19\r\n}\r\n\r\n/** The interface for all timelines.\r\n * @public\r\n * */\r\nexport abstract class Timeline implements ITimeline {\r\n    propertyIds: string[];\r\n    frames: NumberArrayLike;\r\n\r\n    constructor (frameCount: number, propertyIds: string[]) {\r\n        this.propertyIds = propertyIds;\r\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\r\n    }\r\n\r\n    getPropertyIds () {\r\n        return this.propertyIds;\r\n    }\r\n\r\n    getFrameEntries (): number {\r\n        return 1;\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length / this.getFrameEntries();\r\n    }\r\n\r\n    getDuration (): number {\r\n        return this.frames[this.frames.length - this.getFrameEntries()];\r\n    }\r\n\r\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    static search1 (frames: NumberArrayLike, time: number) {\r\n        let n = frames.length;\r\n        for (let i = 1; i < n; i++)\r\n            if (frames[i] > time) return i - 1;\r\n        return n - 1;\r\n    }\r\n\r\n    static search (frames: NumberArrayLike, time: number, step: number) {\r\n        let n = frames.length;\r\n        for (let i = step; i < n; i += step)\r\n            if (frames[i] > time) return i - step;\r\n        return n - step;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface BoneTimeline {\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface SlotTimeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline extends Timeline {\r\n    protected curves: NumberArrayLike; // type, x, y, ...\r\n\r\n    constructor (frameCount: number, bezierCount: number, propertyIds: string[]) {\r\n        super(frameCount, propertyIds);\r\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18/*BEZIER_SIZE*/);\r\n        this.curves[frameCount - 1] = 1/*STEPPED*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear (frame: number) {\r\n        this.curves[frame] = 0/*LINEAR*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped (frame: number) {\r\n        this.curves[frame] = 1/*STEPPED*/;\r\n    }\r\n\r\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\r\n     * than the actual number of Bezier curves. */\r\n    shrink (bezierCount: number) {\r\n        let size = this.getFrameCount() + bezierCount * 18/*BEZIER_SIZE*/;\r\n        if (this.curves.length > size) {\r\n            let newCurves = Utils.newFloatArray(size);\r\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\r\n            this.curves = newCurves;\r\n        }\r\n    }\r\n\r\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\r\n     * one curve per frame.\r\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\r\n     *           in the constructor), inclusive.\r\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\r\n     * @param value The index of the value for this frame that this curve is used for.\r\n     * @param time1 The time for the first key.\r\n     * @param value1 The value for the first key.\r\n     * @param cx1 The time for the first Bezier handle.\r\n     * @param cy1 The value for the first Bezier handle.\r\n     * @param cx2 The time of the second Bezier handle.\r\n     * @param cy2 The value for the second Bezier handle.\r\n     * @param time2 The time for the second key.\r\n     * @param value2 The value for the second key. */\r\n    setBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\r\n               cy2: number, time2: number, value2: number) {\r\n        let curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\r\n        if (value == 0) curves[frame] = 2/*BEZIER*/ + i;\r\n        let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\r\n        let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\r\n        let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx, y = value1 + dy;\r\n        for (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    /** Returns the Bezier interpolated value for the specified time.\r\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\r\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\r\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\r\n    getBezierValue (time: number, frameIndex: number, valueOffset: number, i: number) {\r\n        let curves = this.curves;\r\n        if (curves[i] > time) {\r\n            let x = this.frames[frameIndex], y = this.frames[frameIndex + valueOffset];\r\n            return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n        }\r\n        let n = i + 18/*BEZIER_SIZE*/;\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                let x = curves[i - 2], y = curves[i - 1];\r\n                return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        frameIndex += this.getFrameEntries();\r\n        let x = curves[n - 2], y = curves[n - 1];\r\n        return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\r\n    }\r\n}\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline1 extends CurveTimeline {\r\n    constructor (frameCount: number, bezierCount: number, propertyId: string) {\r\n        super(frameCount, bezierCount, [propertyId]);\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 2/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and value for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame (frame: number, time: number, value: number) {\r\n        frame <<= 1;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*VALUE*/] = value;\r\n    }\r\n\r\n    /** Returns the interpolated value for the specified time. */\r\n    getCurveValue (time: number) {\r\n        let frames = this.frames;\r\n        let i = frames.length - 2;\r\n        for (let ii = 2; ii <= i; ii += 2) {\r\n            if (frames[ii] > time) {\r\n                i = ii - 2;\r\n                break;\r\n            }\r\n        }\r\n\r\n        let curveType = this.curves[i >> 1];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i], value = frames[i + 1/*VALUE*/];\r\n                return value + (time - before) / (frames[i + 2/*ENTRIES*/] - before) * (frames[i + 2/*ENTRIES*/ + 1/*VALUE*/] - value);\r\n            case 1/*STEPPED*/:\r\n                return frames[i + 1/*VALUE*/];\r\n        }\r\n        return this.getBezierValue(time, i, 1/*VALUE*/, curveType - 2/*BEZIER*/);\r\n    }\r\n}\r\n\r\n/** The base class for a {@link CurveTimeline} which sets two properties.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline2 extends CurveTimeline {\r\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\r\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\r\n    constructor (frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\r\n        super(frameCount, bezierCount, [propertyId1, propertyId2]);\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 3/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and values for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame (frame: number, time: number, value1: number, value2: number) {\r\n        frame *= 3/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*VALUE1*/] = value1;\r\n        this.frames[frame + 2/*VALUE2*/] = value2;\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}.\r\n * @public\r\n * */\r\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.rotate + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + r * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += r * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\r\n * @public\r\n * */\r\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.x + \"|\" + boneIndex,\r\n            Property.y + \"|\" + boneIndex,\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.x + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.y + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.scaleX + \"|\" + boneIndex,\r\n            Property.scaleY + \"|\" + boneIndex\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x, y;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n        x *= bone.data.scaleX;\r\n        y *= bone.data.scaleY;\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0, by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.scaleX + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time) * bone.data.scaleX;\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add)\r\n                bone.scaleX += x - bone.data.scaleX;\r\n            else\r\n                bone.scaleX = x;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let bx = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.scaleY + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time) * bone.data.scaleY;\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add)\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            else\r\n                bone.scaleY = y;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = bone.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.shearX + \"|\" + boneIndex,\r\n            Property.shearY + \"|\" + boneIndex\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.shearX + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.shearY + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.alpha + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 5/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frame *= 5/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*A*/] = a;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let color = slot.color;\r\n        if (time < frames[0]) {\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.setFromColor(setup);\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\r\n                        (setup.a - color.a) * alpha);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0;\r\n        let i = Timeline.search(frames, time, 5/*ENTRIES*/);\r\n        let curveType = this.curves[i / 5/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                let t = (time - before) / (frames[i + 5/*ENTRIES*/] - before);\r\n                r += (frames[i + 5/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 5/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 5/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                a += (frames[i + 5/*ENTRIES*/ + 4/*A*/] - a) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n        }\r\n        if (alpha == 1)\r\n            color.set(r, g, b, a);\r\n        else {\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 4/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number) {\r\n        frame <<= 2;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let color = slot.color;\r\n        if (time < frames[0]) {\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.r = setup.r;\r\n                    color.g = setup.g;\r\n                    color.b = setup.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.r += (setup.r - color.r) * alpha;\r\n                    color.g += (setup.g - color.g) * alpha;\r\n                    color.b += (setup.b - color.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0;\r\n        let i = Timeline.search(frames, time, 4/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 2];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                let t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\r\n                r += (frames[i + 4/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 4/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 4/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n        }\r\n        if (alpha == 1) {\r\n            color.r = r;\r\n            color.g = g;\r\n            color.b = b;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                let setup = slot.data.color;\r\n                color.r = setup.r;\r\n                color.g = setup.g;\r\n                color.b = setup.b;\r\n            }\r\n            color.r += (r - color.r) * alpha;\r\n            color.g += (g - color.g) * alpha;\r\n            color.b += (b - color.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, Property.alpha + \"|\" + slotIndex);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let color = slot.color;\r\n        if (time < this.frames[0]) { // Time is before first frame.\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.a = setup.a;\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.a += (setup.a - color.a) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let a = this.getCurveValue(time);\r\n        if (alpha == 1)\r\n            color.a = a;\r\n        else {\r\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\r\n            color.a += (a - color.a) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline{\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.alpha + \"|\" + slotIndex,\r\n            Property.rgb2 + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 8/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frame <<= 3;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*A*/] = a;\r\n        this.frames[frame + 5/*R2*/] = r2;\r\n        this.frames[frame + 6/*G2*/] = g2;\r\n        this.frames[frame + 7/*B2*/] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let light = slot.color, dark = slot.darkColor!;\r\n        if (time < frames[0]) {\r\n            let setupLight = slot.data.color, setupDark = slot.data.darkColor!;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.setFromColor(setupLight);\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\r\n                        (setupLight.a - light.a) * alpha);\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        let i = Timeline.search(frames, time, 8/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 3];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                r2 = frames[i + 5/*R2*/];\r\n                g2 = frames[i + 6/*G2*/];\r\n                b2 = frames[i + 7/*B2*/];\r\n                let t = (time - before) / (frames[i + 8/*ENTRIES*/] - before);\r\n                r += (frames[i + 8/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 8/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 8/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                a += (frames[i + 8/*ENTRIES*/ + 4/*A*/] - a) * t;\r\n                r2 += (frames[i + 8/*ENTRIES*/ + 5/*R2*/] - r2) * t;\r\n                g2 += (frames[i + 8/*ENTRIES*/ + 6/*G2*/] - g2) * t;\r\n                b2 += (frames[i + 8/*ENTRIES*/ + 7/*B2*/] - b2) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                r2 = frames[i + 5/*R2*/];\r\n                g2 = frames[i + 6/*G2*/];\r\n                b2 = frames[i + 7/*B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 5/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 6/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 7/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 6 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.set(r, g, b, a);\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                let setupDark = slot.data.darkColor!;\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline{\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.rgb2 + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 7/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\r\n        frame *= 7/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*R2*/] = r2;\r\n        this.frames[frame + 5/*G2*/] = g2;\r\n        this.frames[frame + 6/*B2*/] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let light = slot.color, dark = slot.darkColor!;\r\n        if (time < frames[0]) {\r\n            let setupLight = slot.data.color, setupDark = slot.data.darkColor!;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.r = setupLight.r;\r\n                    light.g = setupLight.g;\r\n                    light.b = setupLight.b;\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.r += (setupLight.r - light.r) * alpha;\r\n                    light.g += (setupLight.g - light.g) * alpha;\r\n                    light.b += (setupLight.b - light.b) * alpha;\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        let i = Timeline.search(frames, time, 7/*ENTRIES*/);\r\n        let curveType = this.curves[i / 7/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                r2 = frames[i + 4/*R2*/];\r\n                g2 = frames[i + 5/*G2*/];\r\n                b2 = frames[i + 6/*B2*/];\r\n                let t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\r\n                r += (frames[i + 7/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 7/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 7/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                r2 += (frames[i + 7/*ENTRIES*/ + 4/*R2*/] - r2) * t;\r\n                g2 += (frames[i + 7/*ENTRIES*/ + 5/*G2*/] - g2) * t;\r\n                b2 += (frames[i + 7/*ENTRIES*/ + 6/*B2*/] - b2) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                r2 = frames[i + 4/*R2*/];\r\n                g2 = frames[i + 5/*G2*/];\r\n                b2 = frames[i + 6/*B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 4/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 5/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 6/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.r = r;\r\n            light.g = g;\r\n            light.b = b;\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                let setupLight = slot.data.color, setupDark = slot.data.darkColor!;\r\n                light.r = setupLight.r;\r\n                light.g = setupLight.g;\r\n                light.b = setupLight.b;\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.r += (r - light.r) * alpha;\r\n            light.g += (g - light.g) * alpha;\r\n            light.b += (b - light.b) * alpha;\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}.\r\n * @public\r\n * */\r\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string | null>;\r\n\r\n    constructor (frameCount: number, slotIndex: number) {\r\n        super(frameCount, [\r\n            Property.attachment + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame (frame: number, time: number, attachmentName: string | null) {\r\n        this.frames[frame] = time;\r\n        this.attachmentNames[frame] = attachmentName;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\r\n    }\r\n\r\n    setAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\r\n * @public\r\n * */\r\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The vertices for each key frame. */\r\n    vertices: Array<NumberArrayLike>;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\r\n        super(frameCount, bezierCount, [\r\n            Property.deform + \"|\" + slotIndex + \"|\" + attachment.id\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachment = attachment;\r\n        this.vertices = new Array<NumberArrayLike>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame (frame: number, time: number, vertices: NumberArrayLike) {\r\n        this.frames[frame] = time;\r\n        this.vertices[frame] = vertices;\r\n    }\r\n\r\n    /** @param value1 Ignored (0 is used for a deform timeline).\r\n     * @param value2 Ignored (1 is used for a deform timeline). */\r\n    setBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\r\n               cy2: number, time2: number, value2: number) {\r\n        let curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\r\n        if (value == 0) curves[frame] = 2/*BEZIER*/ + i;\r\n        let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;\r\n        let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = (cy1 - cy2 + 0.33333333) * 0.018;\r\n        let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx, y = dy;\r\n        for (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    getCurvePercent (time: number, frame: number) {\r\n        let curves = this.curves;\r\n        let i = curves[frame];\r\n        switch (i) {\r\n            case 0/*LINEAR*/:\r\n                let x = this.frames[frame];\r\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\r\n            case 1/*STEPPED*/:\r\n                return 0;\r\n        }\r\n        i -= 2/*BEZIER*/;\r\n        if (curves[i] > time) {\r\n            let x = this.frames[frame];\r\n            return curves[i + 1] * (time - x) / (curves[i] - x);\r\n        }\r\n        let n = i + 18/*BEZIER_SIZE*/;\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                let x = curves[i - 2], y = curves[i - 1];\r\n                return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        let x = curves[n - 2], y = curves[n - 1];\r\n        return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot: Slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let slotAttachment: Attachment | null = slot.getAttachment();\r\n        if (!slotAttachment) return;\r\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment) return;\r\n\r\n        let deform: Array<number> = slot.deform;\r\n        if (deform.length == 0) blend = MixBlend.setup;\r\n\r\n        let vertices = this.vertices;\r\n        let vertexCount = vertices[0].length;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deform.length = 0;\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deform.length = 0;\r\n                        return;\r\n                    }\r\n                    deform.length = vertexCount;\r\n                    let vertexAttachment = <VertexAttachment>slotAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] *= alpha;\r\n                    }\r\n            }\r\n            return;\r\n        }\r\n\r\n        deform.length = vertexCount;\r\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n            let lastVertices = vertices[frames.length - 1];\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += lastVertices[i];\r\n                    }\r\n                } else\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let setup = setupVertices[i];\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Timeline.search1(frames, time);\r\n        let percent = this.getCurvePercent(time, frame);\r\n        let prevVertices = vertices[frame];\r\n        let nextVertices = vertices[frame + 1];\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                let vertexAttachment = slotAttachment as VertexAttachment;\r\n                if (!vertexAttachment.bones) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    let setupVertices = vertexAttachment.vertices;\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    let prev = prevVertices[i];\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i], setup = setupVertices[i];\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached.\r\n * @public\r\n * */\r\nexport class EventTimeline extends Timeline {\r\n    static propertyIds = [\"\" + Property.event];\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount, EventTimeline.propertyIds);\r\n\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame (frame: number, event: Event) {\r\n        this.frames[frame] = event.time;\r\n        this.events[frame] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!firedEvents) return;\r\n\r\n        let frames = this.frames;\r\n        let frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let i = 0;\r\n        if (lastTime < frames[0])\r\n            i = 0;\r\n        else {\r\n            i = Timeline.search1(frames, lastTime) + 1;\r\n            let frameTime = frames[i];\r\n            while (i > 0) { // Fire multiple events with the same frame.\r\n                if (frames[i - 1] != frameTime) break;\r\n                i--;\r\n            }\r\n        }\r\n        for (; i < frameCount && time >= frames[i]; i++)\r\n            firedEvents.push(this.events[i]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\r\n * @public\r\n * */\r\nexport class DrawOrderTimeline extends Timeline {\r\n    static propertyIds = [\"\" + Property.drawOrder];\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number> | null>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount, DrawOrderTimeline.propertyIds);\r\n        this.drawOrders = new Array<Array<number> | null>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame (frame: number, time: number, drawOrder: Array<number> | null) {\r\n        this.frames[frame] = time;\r\n        this.drawOrders[frame] = drawOrder;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let idx = Timeline.search1(this.frames, time);\r\n        let drawOrderToSetupIndex = this.drawOrders[idx];\r\n        if (!drawOrderToSetupIndex)\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n        else {\r\n            let drawOrder: Array<Slot> = skeleton.drawOrder;\r\n            let slots: Array<Slot> = skeleton.slots;\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\r\n * @public\r\n * */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, ikConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.ikConstraint + \"|\" + ikConstraintIndex\r\n        ]);\r\n        this.ikConstraintIndex = ikConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 6/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n    setFrame (frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frame *= 6/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*MIX*/] = mix;\r\n        this.frames[frame + 2/*SOFTNESS*/] = softness;\r\n        this.frames[frame + 3/*BEND_DIRECTION*/] = bendDirection;\r\n        this.frames[frame + 4/*COMPRESS*/] = compress ? 1 : 0;\r\n        this.frames[frame + 5/*STRETCH*/] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let mix = 0, softness = 0;\r\n        let i = Timeline.search(frames, time, 6/*ENTRIES*/)\r\n        let curveType = this.curves[i / 6/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                mix = frames[i + 1/*MIX*/];\r\n                softness = frames[i + 2/*SOFTNESS*/];\r\n                let t = (time - before) / (frames[i + 6/*ENTRIES*/] - before);\r\n                mix += (frames[i + 6/*ENTRIES*/ + 1/*MIX*/] - mix) * t;\r\n                softness += (frames[i + 6/*ENTRIES*/ + 2/*SOFTNESS*/] - softness) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                mix = frames[i + 1/*MIX*/];\r\n                softness = frames[i + 2/*SOFTNESS*/];\r\n                break;\r\n            default:\r\n                mix = this.getBezierValue(time, i, 1/*MIX*/, curveType - 2/*BEZIER*/);\r\n                softness = this.getBezierValue(time, i, 2/*SOFTNESS*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\r\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4/*COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5/*STRETCH*/] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix - constraint.mix) * alpha;\r\n            constraint.softness += (softness - constraint.softness) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4/*COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5/*STRETCH*/] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\r\n * @public\r\n * */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, transformConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.transformConstraint + \"|\" + transformConstraintIndex\r\n        ]);\r\n        this.transformConstraintIndex = transformConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 7/*ENTRIES*/;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number,\r\n              mixShearY: number) {\r\n        let frames = this.frames;\r\n        frame *= 7/*ENTRIES*/;\r\n        frames[frame] = time;\r\n        frames[frame + 1/*ROTATE*/] = mixRotate;\r\n        frames[frame + 2/*X*/] = mixX;\r\n        frames[frame + 3/*Y*/] = mixY;\r\n        frames[frame + 4/*SCALEX*/] = mixScaleX;\r\n        frames[frame + 5/*SCALEY*/] = mixScaleY;\r\n        frames[frame + 6/*SHEARY*/] = mixShearY;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            let data = constraint.data;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = data.mixRotate;\r\n                    constraint.mixX = data.mixX;\r\n                    constraint.mixY = data.mixY;\r\n                    constraint.mixScaleX = data.mixScaleX;\r\n                    constraint.mixScaleY = data.mixScaleY;\r\n                    constraint.mixShearY = data.mixShearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\r\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\r\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\r\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate, x, y, scaleX, scaleY, shearY;\r\n        let i = Timeline.search(frames, time, 7/*ENTRIES*/);\r\n        let curveType = this.curves[i / 7/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                scaleX = frames[i + 4/*SCALEX*/];\r\n                scaleY = frames[i + 5/*SCALEY*/];\r\n                shearY = frames[i + 6/*SHEARY*/];\r\n                let t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\r\n                rotate += (frames[i + 7/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 7/*ENTRIES*/ + 2/*X*/] - x) * t;\r\n                y += (frames[i + 7/*ENTRIES*/ + 3/*Y*/] - y) * t;\r\n                scaleX += (frames[i + 7/*ENTRIES*/ + 4/*SCALEX*/] - scaleX) * t;\r\n                scaleY += (frames[i + 7/*ENTRIES*/ + 5/*SCALEY*/] - scaleY) * t;\r\n                shearY += (frames[i + 7/*ENTRIES*/ + 6/*SHEARY*/] - shearY) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                scaleX = frames[i + 4/*SCALEX*/];\r\n                scaleY = frames[i + 5/*SCALEY*/];\r\n                shearY = frames[i + 6/*SHEARY*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                scaleX = this.getBezierValue(time, i, 4/*SCALEX*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                scaleY = this.getBezierValue(time, i, 5/*SCALEY*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                shearY = this.getBezierValue(time, i, 6/*SHEARY*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\r\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\r\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\r\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\r\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}.\r\n * @public\r\n * */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, Property.pathConstraintPosition + \"|\" + pathConstraintIndex);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let position = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else\r\n            constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}.\r\n * @public\r\n * */\r\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, Property.pathConstraintSpacing + \"|\" + pathConstraintIndex);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let spacing = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else\r\n            constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\r\n * {@link PathConstraint#getMixY()}.\r\n * @public\r\n * */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.pathConstraintMix + \"|\" + pathConstraintIndex\r\n        ]);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 4/*ENTRIES*/;\r\n    }\r\n\r\n    setFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\r\n        let frames = this.frames;\r\n        frame <<= 2;\r\n        frames[frame] = time;\r\n        frames[frame + 1/*ROTATE*/] = mixRotate;\r\n        frames[frame + 2/*X*/] = mixX;\r\n        frames[frame + 3/*Y*/] = mixY;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = constraint.data.mixRotate;\r\n                    constraint.mixX = constraint.data.mixX;\r\n                    constraint.mixY = constraint.data.mixY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate, x, y;\r\n        let i = Timeline.search(frames, time, 4/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 2];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                let t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\r\n                rotate += (frames[i + 4/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 4/*ENTRIES*/ + 2/*X*/] - x) * t;\r\n                y += (frames[i + 4/*ENTRIES*/ + 3/*Y*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}.\r\n * @public\r\n * */\r\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\r\n    static ENTRIES = 3;\r\n    static MODE = 1;\r\n    static DELAY = 2;\r\n\r\n    slotIndex: number;\r\n    attachment: IHasTextureRegion;\r\n\r\n    constructor (frameCount: number, slotIndex: number, attachment: IHasTextureRegion) {\r\n        super(frameCount, [\r\n            Property.sequence + \"|\" + slotIndex + \"|\" + attachment.sequence!.id\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachment = attachment;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return SequenceTimeline.ENTRIES;\r\n    }\r\n\r\n    getSlotIndex () {\r\n        return this.slotIndex;\r\n    }\r\n\r\n    getAttachment () {\r\n        return this.attachment as unknown as Attachment;\r\n    }\r\n\r\n    /** Sets the time, mode, index, and frame time for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time Seconds between frames. */\r\n    setFrame (frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\r\n        let frames = this.frames;\r\n        frame *= SequenceTimeline.ENTRIES;\r\n        frames[frame] = time;\r\n        frames[frame + SequenceTimeline.MODE] = mode | (index << 4);\r\n        frames[frame + SequenceTimeline.DELAY] = delay;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let slotAttachment = slot.attachment;\r\n        let attachment = this.attachment as unknown as Attachment;\r\n        if (slotAttachment != attachment) {\r\n            if (!(slotAttachment instanceof VertexAttachment)\r\n                || (slotAttachment as VertexAttachment).timelineAttachment != attachment) return;\r\n        }\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) { // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\r\n            return;\r\n        }\r\n\r\n        let i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\r\n        let before = frames[i];\r\n        let modeAndIndex = frames[i + SequenceTimeline.MODE];\r\n        let delay = frames[i + SequenceTimeline.DELAY];\r\n\r\n        if (!this.attachment.sequence) return;\r\n        let index = modeAndIndex >> 4, count = this.attachment.sequence!.regions.length;\r\n        let mode = SequenceModeValues[modeAndIndex & 0xf];\r\n        if (mode != SequenceMode.hold) {\r\n            index += (((time - before) / delay + 0.00001) | 0);\r\n            switch (mode) {\r\n                case SequenceMode.once:\r\n                    index = Math.min(count - 1, index);\r\n                    break;\r\n                case SequenceMode.loop:\r\n                    index %= count;\r\n                    break;\r\n                case SequenceMode.pingpong: {\r\n                    let n = (count << 1) - 2;\r\n                    index = n == 0 ? 0 : index % n;\r\n                    if (index >= count) index = n - index;\r\n                    break;\r\n                }\r\n                case SequenceMode.onceReverse:\r\n                    index = Math.max(count - 1 - index, 0);\r\n                    break;\r\n                case SequenceMode.loopReverse:\r\n                    index = count - 1 - (index % count);\r\n                    break;\r\n                case SequenceMode.pingpongReverse: {\r\n                    let n = (count << 1) - 2;\r\n                    index = n == 0 ? 0 : (index + count - 1) % n;\r\n                    if (index >= count) index = n - index;\r\n                }\r\n            }\r\n        }\r\n        slot.sequenceIndex = index;\r\n    }\r\n}\r\n", "import {\r\n    IAnimationState,\r\n    IAnimationStateListener,\r\n    ITrackEntry,\r\n    MathUtils,\r\n    MixBlend,\r\n    MixDirection,\r\n    Pool,\r\n    StringSet,\r\n    Utils\r\n} from \"@pixi-spine/base\";\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    RotateTimeline, Timeline\r\n} from './Animation';\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport type {Slot} from \"./Slot\";\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static _emptyAnimation = new Animation(\"<empty>\", [], 0);\r\n    private static emptyAnimation (): Animation {\r\n        return AnimationState._emptyAnimation;\r\n    }\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry | null>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new StringSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor (data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n            if (next) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                let nextTime = current.trackLast - next.delay;\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from: TrackEntry | null = current.mixingFrom;\r\n                current.mixingFrom = null;\r\n                if (from) from.mixingTo = null;\r\n                while (from) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom (to: TrackEntry, delta: number): boolean {\r\n        let from = to.mixingFrom;\r\n        if (!from) return true;\r\n\r\n        let finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply (skeleton: Skeleton): boolean {\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        let events = this.events;\r\n        let tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (!current || current.delay > 0) continue;\r\n            applied = true;\r\n            let blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n            if (current.mixingFrom)\r\n                mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && !current.next)\r\n                mix = 0;\r\n\r\n            // Apply current entry.\r\n            let animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;\r\n            let applyEvents: Event[] | null = events;\r\n            if (current.reverse) {\r\n                applyTime = current.animation!.duration - applyTime;\r\n                applyEvents = null;\r\n            }\r\n            let timelines = current.animation!.timelines;\r\n            let timelineCount = timelines.length;\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    var timeline = timelines[ii];\r\n                    if (timeline instanceof AttachmentTimeline)\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    else\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                let timelineMode = current.timelineMode;\r\n\r\n                let shortestRotation = current.shortestRotation;\r\n                let firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\r\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    let timeline = timelines[ii];\r\n                    let timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\r\n                    if (!shortestRotation && timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        var setupState = this.unkeyedState + SETUP;\r\n        var slots = skeleton.slots;\r\n        for (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            var slot = slots[i];\r\n            if (slot.attachmentState == setupState) {\r\n                var attachmentName = slot.data.attachmentName;\r\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        let from = to.mixingFrom!;\r\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n        if (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n        let timelines = from.animation!.timelines;\r\n        let timelineCount = timelines.length;\r\n        let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n        let animationLast = from.animationLast, animationTime = from.getAnimationTime(), applyTime = animationTime;\r\n        let events = null;\r\n        if (from.reverse)\r\n            applyTime = from.animation!.duration - applyTime;\r\n        else if (mix < from.eventThreshold)\r\n            events = this.events;\r\n\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++)\r\n                timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            let timelineMode = from.timelineMode;\r\n            let timelineHoldMix = from.timelineHoldMix;\r\n\r\n            let shortestRotation = from.shortestRotation;\r\n            let firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\r\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                let timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n                switch (timelineMode[i]) {\r\n                    case SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        let holdMix = timelineHoldMix[i];\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (!shortestRotation && timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline)\r\n                    this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\r\n                        direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n        var slot = skeleton.slots[timeline.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        if (time < timeline.frames[0]) { // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        } else\r\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\r\n    }\r\n\r\n    setAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\r\n    }\r\n\r\n    applyRotateTimeline (timeline: RotateTimeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\r\n                         timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n            return;\r\n        }\r\n\r\n        let bone = skeleton.bones[timeline.boneIndex];\r\n        if (!bone.active) return;\r\n        let frames = timeline.frames;\r\n        let r1 = 0, r2 = 0;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0, diff = r2 - r1;\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0, lastDiff = 0;\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            let current = diff > 0, dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        bone.rotation = r1 + total * alpha;\r\n    }\r\n\r\n    queueEvents (entry: TrackEntry, animationTime: number) {\r\n        let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n        let duration = animationEnd - animationStart;\r\n        let trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        let events = this.events;\r\n        let i = 0, n = events.length;\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n        if (entry.loop)\r\n            complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else\r\n            complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks () {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.clearNext(current);\r\n\r\n        let entry = current;\r\n        while (true) {\r\n            let from = entry.mixingFrom;\r\n            if (!from) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\r\n        let from = this.expandToIndex(index);\r\n        this.tracks[index] = current;\r\n        current.previous = null;\r\n\r\n        if (from) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom && from.mixDuration > 0)\r\n                current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * See {@link #setAnimationWith()}. */\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean = false) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false) {\r\n        if (!animation) throw new Error(\"animation cannot be null.\");\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else\r\n                this.clearNext(current);\r\n        }\r\n        let entry = this.trackEntry(trackIndex, animation, loop, current);\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean = false, delay: number = 0) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false, delay: number = 0) {\r\n        if (!animation) throw new Error(\"animation cannot be null.\");\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last) {\r\n            while (last.next)\r\n                last = last.next;\r\n        }\r\n\r\n        let entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (!last) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            entry.previous = last;\r\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\r\n        }\r\n\r\n        entry.delay = delay;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation (trackIndex: number, mixDuration: number = 0) {\r\n        let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation (trackIndex: number, mixDuration: number = 0, delay: number = 0) {\r\n        let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\r\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations (mixDuration: number = 0) {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let current = this.tracks[i];\r\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\r\n        let entry = this.trackEntryPool.obtain();\r\n        entry.reset();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.reverse = false;\r\n        entry.shortestRotation = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation!, animation);\r\n        entry.interruptAlpha = 1;\r\n        entry.totalAlpha = 0;\r\n        entry.mixBlend = MixBlend.replace;\r\n        return entry;\r\n    }\r\n\r\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\r\n    clearNext (entry: TrackEntry) {\r\n        let next = entry.next;\r\n        while (next) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged () {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let entry = tracks[i];\r\n            if (!entry) continue;\r\n            while (entry.mixingFrom)\r\n                entry = entry.mixingFrom;\r\n            do {\r\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry);\r\n        }\r\n    }\r\n\r\n    computeHold (entry: TrackEntry) {\r\n        let to = entry.mixingTo;\r\n        let timelines = entry.animation!.timelines;\r\n        let timelinesCount = entry.animation!.timelines.length;\r\n        let timelineMode = entry.timelineMode;\r\n        timelineMode.length = timelinesCount;\r\n        let timelineHoldMix = entry.timelineHoldMix;\r\n        timelineHoldMix.length = 0;\r\n        let propertyIDs = this.propertyIDs;\r\n\r\n        if (to && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++)\r\n                timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\r\n            return;\r\n        }\r\n\r\n        outer:\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                let timeline = timelines[i];\r\n                let ids = timeline.getPropertyIds();\r\n                if (!propertyIDs.addAll(ids))\r\n                    timelineMode[i] = SUBSEQUENT;\r\n                else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\r\n                    || timeline instanceof EventTimeline || !to.animation!.hasTimeline(ids)) {\r\n                    timelineMode[i] = FIRST;\r\n                } else {\r\n                    for (let next = to.mixingTo; next; next = next!.mixingTo) {\r\n                        if (next.animation!.hasTimeline(ids)) continue;\r\n                        if (entry.mixDuration > 0) {\r\n                            timelineMode[i] = HOLD_MIX;\r\n                            timelineHoldMix[i] = next;\r\n                            continue outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                    timelineMode[i] = HOLD_FIRST;\r\n                }\r\n            }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener (listener: AnimationStateListener) {\r\n        if (!listener) throw new Error(\"listener cannot be null.\");\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener (listener: AnimationStateListener) {\r\n        let index = this.listeners.indexOf(listener);\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners () {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications () {\r\n        this.queue.clear();\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\r\n * @public\r\n * */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation | null = null;\r\n\r\n    previous: TrackEntry | null = null;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry | null = null;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry | null = null;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry | null = null;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener | null = null;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex: number = 0;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop: boolean = false;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious: boolean = false;\r\n\r\n    reverse: boolean = false;\r\n\r\n    shortestRotation: boolean = false;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold: number = 0;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold: number = 0;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold: number = 0;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart: number = 0;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd: number = 0;\r\n\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast: number = 0;\r\n\r\n    nextAnimationLast: number = 0;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay: number = 0;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime: number = 0;\r\n\r\n    trackLast: number = 0; nextTrackLast: number = 0;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd: number = 0;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale: number = 0;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha: number = 0;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime: number = 0;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration: number = 0; interruptAlpha: number = 0; totalAlpha: number = 0;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset () {\r\n        this.next = null;\r\n        this.previous = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime () {\r\n        if (this.loop) {\r\n            let duration = this.animationEnd - this.animationStart;\r\n            if (duration == 0) return this.animationStart;\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast (animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete () {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections () {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    getTrackComplete () {\r\n        let duration = this.animationEnd - this.animationStart;\r\n        if (duration != 0) {\r\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\r\n            if (this.trackTime < duration) return duration; // Before duration.\r\n        }\r\n        return this.trackTime; // Next update.\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor (animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start (entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    drain () {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        let objects = this.objects;\r\n        let listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            let type = objects[i] as EventType;\r\n            let entry = objects[i + 1] as TrackEntry;\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.start) listener.start(entry);\r\n                    }\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.interrupt) listener.interrupt(entry);\r\n                    }\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.end) listener.end(entry);\r\n                    }\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.dispose) listener.dispose(entry);\r\n                    }\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.complete) listener.complete(entry);\r\n                    }\r\n                    break;\r\n                case EventType.event:\r\n                    let event = objects[i++ + 2] as Event;\r\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        let listener = listeners[ii];\r\n                        if (listener.event) listener.event(entry, event);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear () {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start, interrupt, end, dispose, complete, event\r\n}\r\n\r\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}.\r\n * @public\r\n * */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event?: (entry: TrackEntry, event: Event) => void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start (entry: TrackEntry) {\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n    }\r\n}\r\n\r\n/** 1. A previously applied timeline has set this property.\r\n *\r\n * Result: Mix from the current pose to the timeline pose. */\r\nconst SUBSEQUENT = 0;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n *\r\n * Result: Mix from the setup pose to the timeline pose. */\r\nconst FIRST = 1;\r\n/** 1) A previously applied timeline has set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_SUBSEQUENT = 2;\r\n/** 1) This is the first timeline to set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n * that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_FIRST = 3;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry to be applied does have a timeline to set this property.\r\n * 3. The next track entry after that one does have a timeline to set this property.\r\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n *\r\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n * 2 track entries in a row have a timeline that sets the same property.\r\n *\r\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n * place. */\r\nconst HOLD_MIX = 4;\r\n\r\nconst SETUP = 1;\r\nconst CURRENT = 2;\r\n", "import {SkeletonData} from \"./SkeletonData\";\r\nimport {IAnimationStateData, StringMap} from '@pixi-spine/base';\r\nimport type {Animation} from './Animation';\r\n\r\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\r\n * @public\r\n * */\r\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\r\n    /** The SkeletonData to look up animations when they are specified by name. */\r\n    skeletonData: SkeletonData;\r\n\r\n    animationToMixTime: StringMap<number> = {};\r\n\r\n    /** The mix duration to use when no mix duration has been defined between two animations. */\r\n    defaultMix = 0;\r\n\r\n    constructor (skeletonData: SkeletonData) {\r\n        if (!skeletonData) throw new Error(\"skeletonData cannot be null.\");\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    /** Sets a mix duration by animation name.\r\n     *\r\n     * See {@link #setMixWith()}. */\r\n    setMix (fromName: string, toName: string, duration: number) {\r\n        let from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw new Error(\"Animation not found: \" + fromName);\r\n        let to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw new Error(\"Animation not found: \" + toName);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    /** Sets the mix duration when changing from the specified animation to the other.\r\n     *\r\n     * See {@link TrackEntry#mixDuration}. */\r\n    setMixWith (from: Animation, to: Animation, duration: number) {\r\n        if (!from) throw new Error(\"from cannot be null.\");\r\n        if (!to) throw new Error(\"to cannot be null.\");\r\n        let key = from.name + \".\" + to.name;\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\r\n     * no mix duration has been set. */\r\n    getMix (from: Animation, to: Animation) {\r\n        let key = from.name + \".\" + to.name;\r\n        let value = this.animationToMixTime[key];\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n", "\r\nimport {\r\n    AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment,\r\n    PathAttachment, PointAttachment, ClippingAttachment, Sequence\r\n} from './attachments';\r\nimport type {TextureAtlas} from \"@pixi-spine/base\";\r\nimport type {Skin} from \"./Skin\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor (atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    loadSequence (name: string, basePath: string, sequence: Sequence) {\r\n        let regions = sequence.regions;\r\n        for (let i = 0, n = regions.length; i < n; i++) {\r\n            let path = sequence.getPath(basePath, i);\r\n            let region = this.atlas.findRegion(path);\r\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (sequence: \" + name + \")\");\r\n            regions[i] = region;\r\n            regions[i].renderObject = regions[i];\r\n        }\r\n    }\r\n\r\n    newRegionAttachment (skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\r\n        let attachment = new RegionAttachment(name, path);\r\n        if (sequence != null) {\r\n            this.loadSequence(name, path, sequence);\r\n        } else {\r\n            let region = this.atlas.findRegion(path);\r\n            if (!region) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n            region.renderObject = region;\r\n            attachment.region = region;\r\n        }\r\n        return attachment;\r\n    }\r\n\r\n    newMeshAttachment (skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\r\n        let attachment = new MeshAttachment(name, path);\r\n        if (sequence != null) {\r\n            this.loadSequence(name, path, sequence);\r\n        } else {\r\n            let region = this.atlas.findRegion(path);\r\n            if (!region) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n            region.renderObject = region;\r\n            attachment.region = region;\r\n        }\r\n        return attachment;\r\n    }\r\n\r\n    newBoundingBoxAttachment (skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    newPathAttachment (skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    newPointAttachment (skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    newClippingAttachment (skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n", "import {Matrix} from '@pixi/math';\r\nimport {Updatable} from \"./Updatable\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {IBone, MathUtils, settings, TransformMode, Vector2} from \"@pixi-spine/base\";\r\n\r\n/** Stores a bone's current pose.\r\n *\r\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\r\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\r\n * constraint or application code modifies the world transform after it was computed from the local transform.\r\n * @public\r\n * */\r\nexport class Bone implements Updatable, IBone {\r\n    //be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    /** The bone's setup pose data. */\r\n    data: BoneData;\r\n\r\n    /** The skeleton this bone belongs to. */\r\n    skeleton: Skeleton;\r\n\r\n    /** The parent bone, or null if this is the root bone. */\r\n    parent: Bone | null = null;\r\n\r\n    /** The immediate children of this bone. */\r\n    children = new Array<Bone>();\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation in degrees, counter clockwise. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 0;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 0;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearY. */\r\n    shearY = 0;\r\n\r\n    /** The applied local x translation. */\r\n    ax = 0;\r\n\r\n    /** The applied local y translation. */\r\n    ay = 0;\r\n\r\n    /** The applied local rotation in degrees, counter clockwise. */\r\n    arotation = 0;\r\n\r\n    /** The applied local scaleX. */\r\n    ascaleX = 0;\r\n\r\n    /** The applied local scaleY. */\r\n    ascaleY = 0;\r\n\r\n    /** The applied local shearX. */\r\n    ashearX = 0;\r\n\r\n    /** The applied local shearY. */\r\n    ashearY = 0;\r\n\r\n    sorted = false;\r\n    active = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone | null) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\r\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\r\n    update () {\r\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform.\r\n     *\r\n     * See {@link #updateWorldTransformWith()}. */\r\n    updateWorldTransform () {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\r\n     * specified local transform. Child bones are not updated.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide. */\r\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n\r\n        let sx = this.skeleton.scaleX;\r\n        let sy = settings.yDown? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n        if (!parent) { // Root bone.\r\n            let skeleton = this.skeleton;\r\n            let rotationY = rotation + 90 + shearY;\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pa /= sx;\r\n                    pc /= sy;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                let rx = rotation + shearX - prx;\r\n                let ry = rotation + shearY - prx + 90;\r\n                let la = MathUtils.cosDeg(rx) * scaleX;\r\n                let lb = MathUtils.cosDeg(ry) * scaleY;\r\n                let lc = MathUtils.sinDeg(rx) * scaleX;\r\n                let ld = MathUtils.sinDeg(ry) * scaleY;\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                let cos = MathUtils.cosDeg(rotation);\r\n                let sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (this.data.transformMode == TransformMode.NoScale\r\n                    && (pa * pd - pb * pc < 0) != (sx < 0 != sy < 0)) s = -s;\r\n                let r = Math.PI / 2 + Math.atan2(zc, za);\r\n                let zb = Math.cos(r) * s;\r\n                let zd = Math.sin(r) * s;\r\n                let la = MathUtils.cosDeg(shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                let lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    /** Sets this bone's local transform to the setup pose. */\r\n    setToSetupPose () {\r\n        let data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\r\n    getWorldRotationX () {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\r\n    getWorldRotationY () {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\r\n    getWorldScaleX () {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.a * m.a + m.b * m.b);\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\r\n    getWorldScaleY () {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.c * m.c + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the applied transform values from the world transform.\r\n     *\r\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\r\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\r\n     * constraints).\r\n     *\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\r\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\r\n    updateAppliedTransform () {\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (!parent) {\r\n            this.ax = m.tx - this.skeleton.x;\r\n            this.ay = m.ty - this.skeleton.y;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n            return;\r\n        }\r\n        let pm = parent.matrix;\r\n        let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n        this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n        this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n        let ia = pid * pm.d;\r\n        let id = pid * pm.a;\r\n        let ib = pid * pm.c;\r\n        let ic = pid * pm.b;\r\n        let ra = ia * m.a - ib * m.b;\r\n        let rb = ia * m.c - ib * m.d;\r\n        let rc = id * m.b - ic * m.a;\r\n        let rd = id * m.d - ic * m.c;\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            let det = ra * rd - rb * rc;\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\r\n    worldToLocal(world: Vector2) {\r\n        let m = this.matrix;\r\n        let a = m.a, b = m.c, c = m.b, d = m.d;\r\n        let invDet = 1 / (a * d - b * c);\r\n        let x = world.x - m.tx, y = world.y - m.ty;\r\n        world.x = (x * d * invDet - y * b * invDet);\r\n        world.y = (y * a * invDet - x * c * invDet);\r\n        return world;\r\n    }\r\n\r\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\r\n    localToWorld(local: Vector2) {\r\n        let m = this.matrix;\r\n        let x = local.x, y = local.y;\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n        return local;\r\n    }\r\n\r\n    /** Transforms a world rotation to a local rotation. */\r\n    worldToLocalRotation (worldRotation: number) {\r\n        let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Transforms a local rotation to a world rotation. */\r\n    localToWorldRotation (localRotation: number) {\r\n        localRotation -= this.rotation - this.shearX;\r\n        let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Rotates the world transform the specified amount.\r\n     * <p>\r\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\r\n     * need to be called on any child bones, recursively. */\r\n    rotateWorld (degrees: number) {\r\n        let mat = this.matrix;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n    }\r\n}\r\n", "import {Color, TransformMode} from '@pixi-spine/base';\r\n\r\n/** Stores the setup pose for a {@link Bone}.\r\n * @public\r\n * */\r\nexport class BoneData {\r\n    /** The index of the bone in {@link Skeleton#getBones()}. */\r\n    index: number = 0;\r\n\r\n    /** The name of the bone, which is unique across all bones in the skeleton. */\r\n    name: string;\r\n\r\n    /** @returns May be null. */\r\n    parent: BoneData | null = null;\r\n\r\n    /** The bone's length. */\r\n    length: number = 0;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearX. */\r\n    shearY = 0;\r\n\r\n    /** The transform mode for how parent world transforms affect this bone. */\r\n    transformMode = TransformMode.Normal;\r\n\r\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\r\n     * bone.\r\n     * @see Skin#bones */\r\n    skinRequired = false;\r\n\r\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\r\n     * rendered at runtime. */\r\n    color = new Color();\r\n\r\n    constructor (index: number, name: string, parent: BoneData | null) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n", "/** The base class for all constraint datas.\r\n * @public\r\n * */\r\nexport abstract class ConstraintData {\r\n    constructor(public name: string, public order: number, public skinRequired: boolean) { }\r\n}\r\n", "import {EventData} from \"./EventData\";\r\nimport {IEvent} from \"@pixi-spine/base\";\r\n\r\n/** Stores the current pose values for an {@link Event}.\r\n *\r\n * See Timeline {@link Timeline#apply()},\r\n * AnimationStateListener {@link AnimationStateListener#event()}, and\r\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class Event implements IEvent {\r\n    data: EventData;\r\n    intValue: number = 0;\r\n    floatValue: number = 0;\r\n    stringValue: string | null = null;\r\n    time: number = 0;\r\n    volume: number = 0;\r\n    balance: number = 0;\r\n\r\n    constructor (time: number, data: EventData) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n", "import {IEventData} from \"@pixi-spine/base\";\r\n\r\n/** Stores the setup pose values for an {@link Event}.\r\n *\r\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class EventData implements IEventData {\r\n    name: string;\r\n    intValue: number = 0;\r\n    floatValue: number = 0;\r\n    stringValue: string | null = null;\r\n    audioPath: string | null = null;\r\n    volume: number = 0;\r\n    balance: number = 0;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n", "import {Updatable} from \"./Updatable\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, settings, TransformMode} from \"@pixi-spine/base\";\r\n\r\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\r\n * the last bone is as close to the target bone as possible.\r\n *\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraint implements Updatable {\r\n    /** The IK constraint's setup pose data. */\r\n    data: IkConstraintData;\r\n\r\n    /** The bones that will be modified by this IK constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The bone that is the IK target. */\r\n    target: Bone;\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 0;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n    active = false;\r\n\r\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.softness = data.softness;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let bone = skeleton.findBone(data.bones[i].name);\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\r\n            this.bones.push(bone);\r\n        }\r\n        let target = skeleton.findBone(data.target.name);\r\n        if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\r\n        this.target = target;\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    update () {\r\n        if (this.mix == 0) return;\r\n        let target = this.target;\r\n        let bones = this.bones;\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\r\n    apply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        let p = bone.parent.matrix;\r\n        if (!p) throw new Error(\"IK bone must have parent.\");\r\n        let pa = p.a, pb = p.c, pc = p.b, pd = p.d;\r\n        let rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n\r\n        let skelX = bone.skeleton.scaleX;\r\n        let skelY = settings.yDown? -bone.skeleton.scaleY : bone.skeleton.scaleY;\r\n\r\n        switch(bone.data.transformMode) {\r\n            case TransformMode.OnlyTranslation:\r\n                tx = targetX - bone.worldX;\r\n                ty = targetY - bone.worldY;\r\n                //TODO: possible bug in spine-ts runtime!\r\n                if (settings.yDown) {\r\n                    ty = -ty;\r\n                }\r\n                break;\r\n            case TransformMode.NoRotationOrReflection:\r\n                let s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                let sa = pa / skelX;\r\n                let sc = pc / skelY;\r\n                pb = -sc * s * skelX;\r\n                pd = sa * s * skelY;\r\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n            // Fall through\r\n            default:\r\n                let x = targetX - p.tx, y = targetY - p.ty;\r\n                let d = pa * pd - pb * pc;\r\n                tx = (x * pd - y * pb) / d - bone.ax;\r\n                ty = (y * pa - x * pc) / d - bone.ay;\r\n        }\r\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180)\r\n            rotationIK += 360;\r\n        let sx = bone.ascaleX, sy = bone.ascaleY;\r\n        if (compress || stretch) {\r\n            switch (bone.data.transformMode) {\r\n                case TransformMode.NoScale:\r\n                case TransformMode.NoScaleOrReflection:\r\n                    tx = targetX - bone.worldX;\r\n                    ty = targetY - bone.worldY;\r\n            }\r\n            let b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                let s = (dd / b - 1) * alpha + 1;\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\r\n            bone.ashearY);\r\n    }\r\n\r\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\r\n        let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;\r\n        let pmat = parent.matrix;\r\n        let os1 = 0, os2 = 0, s2 = 0;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else\r\n            os2 = 0;\r\n        let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n        let u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u || stretch) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        let pp = parent.parent.matrix;\r\n        if (!pp) throw new Error(\"IK parent must itself have a parent.\");\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        let id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\r\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n        if (l1 < 0.0001) {\r\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n            return;\r\n        }\r\n        x = targetX - pp.tx;\r\n        y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n        let dd = tx * tx + ty * ty;\r\n        if (softness != 0) {\r\n            softness *= psx * (csx + 1) * 0.5;\r\n            let td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n            if (sd > 0) {\r\n                let p = Math.min(1, sd / (softness * 2)) - 1;\r\n                p = (sd - softness * (1 - p * p)) / td;\r\n                tx -= p * tx;\r\n                ty -= p * ty;\r\n                dd = tx * tx + ty * ty;\r\n            }\r\n        }\r\n        outer:\r\n            if (u) {\r\n                l2 *= psx;\r\n                let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                if (cos < -1) {\r\n                    cos = -1;\r\n                    a2 = Math.PI * bendDir;\r\n                } else if (cos > 1) {\r\n                    cos = 1;\r\n                    a2 = 0;\r\n                    if (stretch) {\r\n                        a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                        sx *= a;\r\n                        if (uniform) sy *= a;\r\n                    }\r\n                } else\r\n                    a2 = Math.acos(cos) * bendDir;\r\n                a = l1 + l2 * cos;\r\n                b = l2 * Math.sin(a2);\r\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n            } else {\r\n                a = psx * l2;\r\n                b = psy * l2;\r\n                let aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                let c1 = -2 * bb * l1, c2 = bb - aa;\r\n                d = c1 * c1 - 4 * c2 * c;\r\n                if (d >= 0) {\r\n                    let q = Math.sqrt(d);\r\n                    if (c1 < 0) q = -q;\r\n                    q = -(c1 + q) * 0.5;\r\n                    let r0 = q / c2, r1 = c / q;\r\n                    let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                    if (r * r <= dd) {\r\n                        y = Math.sqrt(dd - r * r) * bendDir;\r\n                        a1 = ta - Math.atan2(y, r);\r\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                        break outer;\r\n                    }\r\n                }\r\n                let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                c = -a * l1 / (aa - bb);\r\n                if (c >= -1 && c <= 1) {\r\n                    c = Math.acos(c);\r\n                    x = a * Math.cos(c) + l1;\r\n                    y = b * Math.sin(c);\r\n                    d = x * x + y * y;\r\n                    if (d < minDist) {\r\n                        minAngle = c;\r\n                        minDist = d;\r\n                        minX = x;\r\n                        minY = y;\r\n                    }\r\n                    if (d > maxDist) {\r\n                        maxAngle = c;\r\n                        maxDist = d;\r\n                        maxX = x;\r\n                        maxY = y;\r\n                    }\r\n                }\r\n                if (dd <= (minDist + maxDist) * 0.5) {\r\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                    a2 = minAngle * bendDir;\r\n                } else {\r\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                    a2 = maxAngle * bendDir;\r\n                }\r\n            }\r\n        let os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180) //\r\n            a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180) //\r\n            a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n", "import {ConstraintData} from \"./ConstraintData\";\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/** Stores the setup pose for an {@link IkConstraint}.\r\n * <p>\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraintData extends ConstraintData {\r\n    /** The bones that are constrained by this IK constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The bone that is the IK target. */\r\n    private _target: BoneData | null = null;\r\n    public set target (boneData: BoneData) { this._target = boneData; }\r\n    public get target () {\r\n        if (!this._target) throw new Error(\"BoneData not set.\")\r\n        else return this._target;\r\n    }\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 1;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\r\n     * is scaled on both the X and Y axes. */\r\n    uniform = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n", "import {ConstraintData} from \"./ConstraintData\";\r\nimport type {SlotData} from \"./SlotData\";\r\nimport type {BoneData} from \"./BoneData\";\r\nimport { PositionMode, RotateMode } from \"@pixi-spine/base\";\r\n\r\n/** Stores the setup pose for a {@link PathConstraint}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraintData extends ConstraintData {\r\n\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    private _target: SlotData | null = null;\r\n    public set target (slotData: SlotData) { this._target = slotData; }\r\n    public get target () {\r\n        if (!this._target) throw new Error(\"SlotData not set.\")\r\n        else return this._target;\r\n    }\r\n\r\n    /** The mode for positioning the first bone on the path. */\r\n    positionMode: PositionMode = PositionMode.Fixed;\r\n\r\n    /** The mode for positioning the bones after the first bone on the path. */\r\n    spacingMode: SpacingMode = SpacingMode.Fixed;\r\n\r\n    /** The mode for adjusting the rotation of the bones. */\r\n    rotateMode: RotateMode = RotateMode.Chain;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation: number = 0;\r\n\r\n    /** The position along the path. */\r\n    position: number = 0;\r\n\r\n    /** The spacing between bones. */\r\n    spacing: number = 0;\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n\r\n/** Controls how bones after the first bone are positioned along the path.\r\n *\r\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum SpacingMode {\r\n    Length, Fixed, Percent, Proportional\r\n}\r\n", "import {PathAttachment} from \"./attachments\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {PathConstraintData, SpacingMode} from \"./PathConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, PositionMode, RotateMode, Utils} from \"@pixi-spine/base\";\r\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\r\n * constrained bones so they follow a {@link PathAttachment}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    /** The path constraint's setup pose data. */\r\n    data: PathConstraintData;\r\n\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    target: Slot;\r\n\r\n    /** The position along the path. */\r\n    position = 0;\r\n\r\n    /** The spacing between bones. */\r\n    spacing = 0;\r\n\r\n    mixRotate = 0;\r\n\r\n    mixX = 0;\r\n\r\n    mixY = 0;\r\n\r\n    spaces = new Array<number>(); positions = new Array<number>();\r\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    active = false;\r\n\r\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++) {\r\n            let bone = skeleton.findBone(data.bones[i].name);\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\r\n            this.bones.push(bone);\r\n        }\r\n        let target = skeleton.findSlot(data.target.name);\r\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\r\n        this.target = target;\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.mixRotate = data.mixRotate;\r\n        this.mixX = data.mixX;\r\n        this.mixY = data.mixY;\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    update () {\r\n        let attachment = this.target.getAttachment();\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;\r\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\r\n\r\n        let data = this.data;\r\n        let tangents = data.rotateMode == RotateMode.Tangent, scale = data.rotateMode == RotateMode.ChainScale;\r\n\r\n        let bones = this.bones;\r\n        let boneCount = bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];\r\n        let spacing = this.spacing;\r\n\r\n        switch (data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                if (scale) {\r\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\r\n                        let bone = bones[i];\r\n                        let setupLength = bone.data.length;\r\n                        if (setupLength < PathConstraint.epsilon)\r\n                            lengths[i] = 0;\r\n                        else {\r\n                            let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                            lengths[i] = Math.sqrt(x * x + y * y);\r\n                        }\r\n                    }\r\n                }\r\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                let sum = 0;\r\n                for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                    let bone = bones[i];\r\n                    let setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                        let length = Math.sqrt(x * x + y * y);\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = length;\r\n                        sum += length;\r\n                    }\r\n                }\r\n                if (sum > 0) {\r\n                    sum = spacesCount / sum * spacing;\r\n                    for (let i = 1; i < spacesCount; i++)\r\n                        spaces[i] *= sum;\r\n                }\r\n                break;\r\n            default:\r\n                let lengthSpacing = data.spacingMode == SpacingMode.Length;\r\n                for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                    let bone = bones[i];\r\n                    let setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                        let length = Math.sqrt(x * x + y * y);\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n                    }\r\n                }\r\n        }\r\n\r\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\r\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n        if (offsetRotation == 0)\r\n            tip = data.rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            let p = this.target.bone.matrix;\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            let bone = bones[i];\r\n            let mat = bone.matrix;\r\n            mat.tx += (boneX - mat.tx) * mixX;\r\n            mat.ty += (boneY - mat.ty) * mixY;\r\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n            if (scale) {\r\n                let length = lengths[i];\r\n                if (length != 0) {\r\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (mixRotate > 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                if (tangents)\r\n                    r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0)\r\n                    r = positions[p + 2];\r\n                else\r\n                    r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    let length = bone.data.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean) {\r\n        let target = this.target;\r\n        let position = this.position;\r\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = this.world;\r\n        let closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            let lengths = path.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            let pathLength = lengths[curveCount];\r\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n            let multiplier;\r\n            switch (this.data.spacingMode) {\r\n                case SpacingMode.Percent:\r\n                    multiplier = pathLength;\r\n                    break;\r\n                case SpacingMode.Proportional:\r\n                    multiplier = pathLength / spacesCount;\r\n                    break;\r\n                default:\r\n                    multiplier = 1;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i] * multiplier;\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (; ; curve++) {\r\n                    let length = lengths[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else\r\n                        path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                    tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        let curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n\r\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n        let multiplier;\r\n        switch (this.data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                multiplier = pathLength;\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                multiplier = pathLength / spacesCount;\r\n                break;\r\n            default:\r\n                multiplier = 1;\r\n        }\r\n\r\n        let segments = this.segments;\r\n        let curveLength = 0;\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            let space = spaces[i] * multiplier;\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (; ; curve++) {\r\n                let length = curves[curve];\r\n                if (p > length) continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (; ; segment++) {\r\n                let length = segments[segment];\r\n                if (p > length) continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n                      out: Array<number>, o: number, tangents: boolean) {\r\n        if (p == 0 || isNaN(p)) {\r\n            out[o] = x1;\r\n            out[o + 1] = y1;\r\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n            return;\r\n        }\r\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) {\r\n            if (p < 0.001)\r\n                out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n            else\r\n                out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n        }\r\n    }\r\n}\r\n", "import {Color, ISlot} from '@pixi-spine/base';\r\n\r\nimport {Attachment, VertexAttachment} from './attachments/Attachment';\r\nimport type {Bone} from './Bone';\r\nimport type {SlotData} from './SlotData';\r\nimport type {Skeleton} from './Skeleton';\r\n\r\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\r\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\r\n * across multiple skeletons.\r\n * @public\r\n * */\r\nexport class Slot implements ISlot {\r\n    //this is canon\r\n    blendMode: number;\r\n    /** The slot's setup pose data. */\r\n    data: SlotData;\r\n\r\n    /** The bone this slot belongs to. */\r\n    bone: Bone;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color: Color;\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color | null = null;\r\n\r\n    attachment: Attachment | null = null;\r\n\r\n    attachmentState: number = 0;\r\n\r\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\r\n     * {@link Sequence#getSetupIndex()}. */\r\n    sequenceIndex: number = -1;\r\n\r\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\r\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\r\n     *\r\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\r\n    deform = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!bone) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = !data.darkColor ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** The skeleton this slot belongs to. */\r\n    getSkeleton (): Skeleton {\r\n        return this.bone.skeleton;\r\n    }\r\n\r\n    /** The current attachment for the slot, or null if the slot has no attachment. */\r\n    getAttachment (): Attachment | null {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\r\n     * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\r\n     * specified attachment. */\r\n    setAttachment (attachment: Attachment | null) {\r\n        if (this.attachment == attachment) return;\r\n        if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment)\r\n            || (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment) {\r\n            this.deform.length = 0;\r\n        }\r\n        this.attachment = attachment;\r\n        this.sequenceIndex = -1;\r\n    }\r\n\r\n    /** Sets this slot to the setup pose. */\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor!);\r\n        if (!this.data.attachmentName)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n", "import {Updatable} from \"./Updatable\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\r\n * bones to match that of the target bone.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class TransformConstraint implements Updatable {\r\n\r\n    /** The transform constraint's setup pose data. */\r\n    data: TransformConstraintData;\r\n\r\n    /** The bones that will be modified by this transform constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The target bone whose world transform will be copied to the constrained bones. */\r\n    target: Bone;\r\n\r\n    mixRotate = 0; mixX = 0; mixY = 0; mixScaleX = 0; mixScaleY = 0; mixShearY = 0;\r\n\r\n    temp = new Vector2();\r\n    active = false;\r\n\r\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mixRotate = data.mixRotate;\r\n        this.mixX = data.mixX;\r\n        this.mixY = data.mixY;\r\n        this.mixScaleX = data.mixScaleX;\r\n        this.mixScaleY = data.mixScaleY;\r\n        this.mixShearY = data.mixShearY;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let bone = skeleton.findBone(data.bones[i].name);\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\r\n            this.bones.push(bone);\r\n        }\r\n        let target = skeleton.findBone(data.target.name);\r\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}.`);\r\n        this.target = target;\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    update () {\r\n        if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0) return;\r\n\r\n        if (this.data.local) {\r\n            if (this.data.relative)\r\n                this.applyRelativeLocal();\r\n            else\r\n                this.applyAbsoluteLocal();\r\n        } else {\r\n            if (this.data.relative)\r\n                this.applyRelativeWorld();\r\n            else\r\n                this.applyAbsoluteWorld();\r\n        }\r\n    }\r\n\r\n    applyAbsoluteWorld () {\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\r\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\r\n        let translate = mixX != 0 || mixY != 0;\r\n\r\n        let target = this.target;\r\n        const targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        let offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            if (mixRotate != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n\r\n            if (translate) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += (temp.x - mat.tx) * mixX;\r\n                mat.ty += (temp.y - mat.ty) * mixY;\r\n            }\r\n\r\n            if (mixScaleX != 0) {\r\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n            }\r\n            if (mixScaleY != 0) {\r\n                let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n\r\n            }\r\n\r\n            if (mixShearY > 0) {\r\n                let b = mat.c, d = mat.d;\r\n                let by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r = by + (r + offsetShearY) * mixShearY;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n\r\n            }\r\n\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    applyRelativeWorld () {\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\r\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\r\n        let translate = mixX != 0 || mixY != 0;\r\n\r\n        let target = this.target;\r\n        let targetMat = target.matrix;\r\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        let offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            if (mixRotate != 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                let r = Math.atan2(tc, ta) + offsetRotation;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n\r\n            if (translate) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += temp.x * mixX;\r\n                mat.ty += temp.y * mixY;\r\n            }\r\n\r\n            if (mixScaleX != 0) {\r\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n            }\r\n            if (mixScaleY != 0) {\r\n                let s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n            }\r\n\r\n            if (mixShearY > 0) {\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                let b = mat.c, d = mat.d;\r\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n            }\r\n\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    applyAbsoluteLocal () {\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\r\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\r\n\r\n        let target = this.target;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n\r\n            let rotation = bone.arotation;\r\n            if (mixRotate != 0) {\r\n                let r = target.arotation - rotation + this.data.offsetRotation;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                rotation += r * mixRotate;\r\n            }\r\n\r\n            let x = bone.ax, y = bone.ay;\r\n            x += (target.ax - x + this.data.offsetX) * mixX;\r\n            y += (target.ay - y + this.data.offsetY) * mixY;\r\n\r\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n            if (mixScaleX != 0 && scaleX != 0)\r\n                scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\r\n            if (mixScaleY != 0 && scaleY != 0)\r\n                scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\r\n\r\n            let shearY = bone.ashearY;\r\n            if (mixShearY != 0) {\r\n                let r = target.ashearY - shearY + this.data.offsetShearY;\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                shearY += r * mixShearY;\r\n            }\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    applyRelativeLocal () {\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\r\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\r\n\r\n        let target = this.target;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n\r\n            let rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\r\n            let x = bone.ax + (target.ax + this.data.offsetX) * mixX;\r\n            let y = bone.ay + (target.ay + this.data.offsetY) * mixY;\r\n            let scaleX = bone.ascaleX * (((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX) + 1);\r\n            let scaleY = bone.ascaleY * (((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY) + 1);\r\n            let shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n}\r\n", "import {Attachment, RegionAttachment, MeshAttachment, PathAttachment} from './attachments';\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {SkeletonData} from \"./SkeletonData\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport {Skin} from \"./Skin\";\r\nimport {Color, MathUtils, NumberArrayLike, settings, Utils, Vector2, ISkeleton} from \"@pixi-spine/base\";\r\n\r\n/** Stores the current pose for a skeleton.\r\n *\r\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\r\n    /** The skeleton's setup pose data. */\r\n    data: SkeletonData;\r\n\r\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The skeleton's slots. */\r\n    slots: Array<Slot>;\r\n\r\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\r\n    drawOrder: Array<Slot>;\r\n\r\n    /** The skeleton's IK constraints. */\r\n    ikConstraints: Array<IkConstraint>;\r\n\r\n    /** The skeleton's transform constraints. */\r\n    transformConstraints: Array<TransformConstraint>;\r\n\r\n    /** The skeleton's path constraints. */\r\n    pathConstraints: Array<PathConstraint>;\r\n\r\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\r\n    _updateCache = new Array<Updatable>();\r\n\r\n    /** The skeleton's current skin. May be null. */\r\n    skin: Skin | null = null;\r\n\r\n    /** The color to tint all the skeleton's attachments. */\r\n    color: Color;\r\n\r\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\r\n     * inheritance. */\r\n    scaleX = 1;\r\n\r\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\r\n     * inheritance. */\r\n    scaleY = 1;\r\n\r\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\r\n    x = 0;\r\n\r\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\r\n    y = 0;\r\n\r\n    constructor (data: SkeletonData) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let boneData = data.bones[i];\r\n            let bone: Bone;\r\n            if (!boneData.parent)\r\n                bone = new Bone(boneData, this, null);\r\n            else {\r\n                let parent = this.bones[boneData.parent.index];\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            let slotData = data.slots[i];\r\n            let bone = this.bones[slotData.boneData.index];\r\n            let slot = new Slot(slotData, bone);\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            let ikConstraintData = data.ikConstraints[i];\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            let transformConstraintData = data.transformConstraints[i];\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            let pathConstraintData = data.pathConstraints[i];\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\r\n     * constraints, or weighted path attachments are added or removed. */\r\n    updateCache () {\r\n        let updateCache = this._updateCache;\r\n        updateCache.length = 0;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            bone.sorted = bone.data.skinRequired;\r\n            bone.active = !bone.sorted;\r\n        }\r\n\r\n        if (this.skin) {\r\n            let skinBones = this.skin.bones;\r\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                let bone: Bone | null = this.bones[skinBones[i].index];\r\n                do {\r\n                    bone.sorted = false;\r\n                    bone.active = true;\r\n                    bone = bone.parent;\r\n                } while (bone);\r\n            }\r\n        }\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        let ikConstraints = this.ikConstraints;\r\n        let transformConstraints = this.transformConstraints;\r\n        let pathConstraints = this.pathConstraints;\r\n        let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n        let constraintCount = ikCount + transformCount + pathCount;\r\n\r\n        outer:\r\n            for (let i = 0; i < constraintCount; i++) {\r\n                for (let ii = 0; ii < ikCount; ii++) {\r\n                    let constraint = ikConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortIkConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < transformCount; ii++) {\r\n                    let constraint = transformConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortTransformConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (let ii = 0; ii < pathCount; ii++) {\r\n                    let constraint = pathConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortPathConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n            }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortIkConstraint (constraint: IkConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\r\n        if (!constraint.active) return;\r\n\r\n        let target = constraint.target;\r\n        this.sortBone(target);\r\n\r\n        let constrained = constraint.bones;\r\n        let parent = constrained[0];\r\n        this.sortBone(parent);\r\n\r\n        if (constrained.length == 1) {\r\n            this._updateCache.push(constraint);\r\n            this.sortReset(parent.children);\r\n        } else {\r\n            let child = constrained[constrained.length - 1];\r\n            this.sortBone(child);\r\n\r\n            this._updateCache.push(constraint);\r\n\r\n            this.sortReset(parent.children);\r\n            child.sorted = true;\r\n        }\r\n    }\r\n\r\n    sortPathConstraint (constraint: PathConstraint) {\r\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\r\n        if (!constraint.active) return;\r\n\r\n        let slot = constraint.target;\r\n        let slotIndex = slot.data.index;\r\n        let slotBone = slot.bone;\r\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin)\r\n            this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n        for (let i = 0, n = this.data.skins.length; i < n; i++)\r\n            this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n        let attachment = slot.getAttachment();\r\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortBone(constrained[i]);\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++)\r\n            constrained[i].sorted = true;\r\n    }\r\n\r\n    sortTransformConstraint (constraint: TransformConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\r\n        if (!constraint.active) return;\r\n\r\n        this.sortBone(constraint.target);\r\n\r\n        let constrained = constraint.bones;\r\n        let boneCount = constrained.length;\r\n        if (constraint.data.local) {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                let child = constrained[i];\r\n                this.sortBone(child.parent!);\r\n                this.sortBone(child);\r\n            }\r\n        } else {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                this.sortBone(constrained[i]);\r\n            }\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++)\r\n            this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++)\r\n            constrained[i].sorted = true;\r\n    }\r\n\r\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        let attachments = skin.attachments[slotIndex];\r\n        if (!attachments) return;\r\n        for (let key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        let pathBones = (<PathAttachment>attachment).bones;\r\n        if (!pathBones)\r\n            this.sortBone(slotBone);\r\n        else {\r\n            let bones = this.bones;\r\n            for (let i = 0, n = pathBones.length; i < n;) {\r\n                let nn = pathBones[i++];\r\n                nn += i;\r\n                while (i < nn)\r\n                    this.sortBone(bones[pathBones[i++]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone (bone: Bone) {\r\n        if (!bone) return;\r\n        if (bone.sorted) return;\r\n        let parent = bone.parent;\r\n        if (parent) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset (bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (!bone.active) continue;\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies all constraints.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide. */\r\n    updateWorldTransform () {\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            bone.ax = bone.x;\r\n            bone.ay = bone.y;\r\n            bone.arotation = bone.rotation;\r\n            bone.ascaleX = bone.scaleX;\r\n            bone.ascaleY = bone.scaleY;\r\n            bone.ashearX = bone.shearX;\r\n            bone.ashearY = bone.shearY;\r\n        }\r\n\r\n        let updateCache = this._updateCache;\r\n        for (let i = 0, n = updateCache.length; i < n; i++)\r\n            updateCache[i].update();\r\n    }\r\n\r\n    updateWorldTransformWith (parent: Bone) {\r\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\r\n        let rootBone = this.getRootBone();\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\r\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\r\n\r\n        let rotationY = rootBone.rotation + 90 + rootBone.shearY;\r\n        let la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\r\n        let lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\r\n        let lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\r\n        let ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\r\n\r\n        const sx = this.scaleX;\r\n        const sy = settings.yDown? -this.scaleY : this.scaleY;\r\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\r\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\r\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\r\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\r\n\r\n        // Update everything except root bone.\r\n        let updateCache = this._updateCache;\r\n        for (let i = 0, n = updateCache.length; i < n; i++) {\r\n            let updatable = updateCache[i];\r\n            if (updatable != rootBone) updatable.update();\r\n        }\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose () {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose () {\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            constraint.mix = constraint.data.mix;\r\n            constraint.softness = constraint.data.softness;\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.compress = constraint.data.compress;\r\n            constraint.stretch = constraint.data.stretch;\r\n        }\r\n\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.mixRotate = data.mixRotate;\r\n            constraint.mixX = data.mixX;\r\n            constraint.mixY = data.mixY;\r\n            constraint.mixScaleX = data.mixScaleX;\r\n            constraint.mixScaleY = data.mixScaleY;\r\n            constraint.mixShearY = data.mixShearY;\r\n        }\r\n\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.mixRotate = data.mixRotate;\r\n            constraint.mixX = data.mixX;\r\n            constraint.mixY = data.mixY;\r\n        }\r\n    }\r\n\r\n    /** Sets the slots and draw order to their setup pose values. */\r\n    setSlotsToSetupPose () {\r\n        let slots = this.slots;\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @returns May return null. */\r\n    getRootBone () {\r\n        if (this.bones.length == 0) return null;\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @returns May be null. */\r\n    findBone (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @returns -1 if the bone was not found. */\r\n    findBoneIndex (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n     * repeatedly.\r\n     * @returns May be null. */\r\n    findSlot (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @returns -1 if the bone was not found. */\r\n    findSlotIndex (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     *\r\n     * See {@link #setSkin()}. */\r\n    setSkinByName (skinName: string) {\r\n        let skin = this.data.findSkin(skinName);\r\n        if (!skin) throw new Error(\"Skin not found: \" + skinName);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\r\n     * skin is changed, {@link #updateCache()} is called.\r\n     *\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     *\r\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\r\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\r\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin (newSkin: Skin) {\r\n        if (newSkin == this.skin) return;\r\n        if (newSkin) {\r\n            if (this.skin)\r\n                newSkin.attachAll(this, this.skin);\r\n            else {\r\n                let slots = this.slots;\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    let slot = slots[i];\r\n                    let name = slot.data.attachmentName;\r\n                    if (name) {\r\n                        let attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n        this.updateCache();\r\n    }\r\n\r\n\r\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\r\n     * name.\r\n     *\r\n     * See {@link #getAttachment()}.\r\n     * @returns May be null. */\r\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment | null {\r\n        let slot = this.data.findSlot(slotName);\r\n        if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\r\n        return this.getAttachment(slot.index, attachmentName);\r\n    }\r\n\r\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\r\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\r\n     *\r\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n     * @returns May be null. */\r\n    getAttachment (slotIndex: number, attachmentName: string): Attachment | null {\r\n        if (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\r\n        if (this.skin) {\r\n            let attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    }\r\n\r\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\r\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\r\n     * @param attachmentName May be null to clear the slot's attachment. */\r\n    setAttachment (slotName: string, attachmentName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment | null = null;\r\n                if (attachmentName) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(\"Slot not found: \" + slotName);\r\n    }\r\n\r\n\r\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it repeatedly.\r\n     * @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let ikConstraint = ikConstraints[i];\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n     * this method than to call it repeatedly.\r\n     * @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it repeatedly.\r\n     * @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\r\n     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\r\n    getBoundsRect () {\r\n        let offset = new Vector2();\r\n        let size = new Vector2();\r\n        this.getBounds(offset, size);\r\n        return { x: offset.x, y: offset.y, width: size.x, height: size.y };\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size An output value, the width and height of the AABB.\r\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\r\n    getBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n        if (!offset) throw new Error(\"offset cannot be null.\");\r\n        if (!size) throw new Error(\"size cannot be null.\");\r\n        let drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = drawOrder[i];\r\n            if (!slot.bone.active) continue;\r\n            let verticesLength = 0;\r\n            let vertices: NumberArrayLike | null = null;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof RegionAttachment) {\r\n                verticesLength = 8;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                (<RegionAttachment>attachment).computeWorldVertices(slot, vertices, 0, 2);\r\n            } else if (attachment instanceof MeshAttachment) {\r\n                let mesh = (<MeshAttachment>attachment);\r\n                verticesLength = mesh.worldVerticesLength;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n            }\r\n            if (vertices) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                    let x = vertices[ii], y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    get flipX(): boolean {\r\n        return this.scaleX == -1;\r\n    }\r\n\r\n    set flipX(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleX = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    get flipY(): boolean {\r\n        return this.scaleY == -1;\r\n    }\r\n\r\n    set flipY(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n        }\r\n        this.scaleY = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n}\r\n", "import type {ISkeletonData} from \"@pixi-spine/base\";\r\nimport type {Animation} from \"./Animation\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {EventData} from \"./EventData\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData} from \"./PathConstraintData\";\r\n\r\n/** Stores the setup pose and all of the stateless data for a skeleton.\r\n *\r\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\r\n * Guide.\r\n * @public\r\n * */\r\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\r\n\r\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\r\n    name: string | null = null;\r\n\r\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n\r\n    /** The skeleton's slots. */\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n\r\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\r\n     *\r\n     * See {@link Skeleton#getAttachmentByName()}.\r\n     * May be null. */\r\n    defaultSkin: Skin | null = null;\r\n\r\n    /** The skeleton's events. */\r\n    events = new Array<EventData>();\r\n\r\n    /** The skeleton's animations. */\r\n    animations = new Array<Animation>();\r\n\r\n    /** The skeleton's IK constraints. */\r\n    ikConstraints = new Array<IkConstraintData>();\r\n\r\n    /** The skeleton's transform constraints. */\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n\r\n    /** The skeleton's path constraints. */\r\n    pathConstraints = new Array<PathConstraintData>();\r\n\r\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    x: number = 0;\r\n\r\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    y: number = 0;\r\n\r\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\r\n    width: number = 0;\r\n\r\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\r\n    height: number = 0;\r\n\r\n    /** The Spine version used to export the skeleton data, or null. */\r\n    version: string | null = null;\r\n\r\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\r\n    hash: string | null = null;\r\n\r\n    // Nonessential\r\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\r\n    fps = 0;\r\n\r\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    imagesPath: string | null = null;\r\n\r\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    audioPath: string | null = null;\r\n\r\n    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findBone (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n/** removed from spine-ts runtime **/\r\n    findBoneIndex (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSlot (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n/** removed from spine-ts runtime **/\r\n    findSlotIndex (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSkin (skinName: string) {\r\n        if (!skinName) throw new Error(\"skinName cannot be null.\");\r\n        let skins = this.skins;\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            let skin = skins[i];\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findEvent (eventDataName: string) {\r\n        if (!eventDataName) throw new Error(\"eventDataName cannot be null.\");\r\n        let events = this.events;\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\r\n     * call it multiple times.\r\n     * @returns May be null. */\r\n    findAnimation (animationName: string) {\r\n        if (!animationName) throw new Error(\"animationName cannot be null.\");\r\n        let animations = this.animations;\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            let animation = animations[i];\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n     * this method than to call it multiple times.\r\n     * @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n/** removed from spine-ts runtime **/    findPathConstraintIndex (pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n            if (pathConstraints[i].name == pathConstraintName) return i;\r\n        return -1;\r\n    }\r\n}\r\n", "import {Color} from '@pixi-spine/base';\r\n\r\nimport type {ISlotData} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/** Stores the setup pose for a {@link Slot}.\r\n * @public\r\n * */\r\nexport class SlotData implements ISlotData {\r\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\r\n    index: number = 0;\r\n\r\n    /** The name of the slot, which is unique across all slots in the skeleton. */\r\n    name: string;\r\n\r\n    /** The bone this slot belongs to. */\r\n    boneData: BoneData;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color | null = null;\r\n\r\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\r\n    attachmentName: string | null = null;\r\n\r\n    /** The blend mode for drawing the slot's attachment. */\r\n    blendMode: BLEND_MODES = BLEND_MODES.NORMAL;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        if (!boneData) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n", "import {BoneData} from './BoneData';\r\nimport {ConstraintData} from './ConstraintData';\r\n\r\n/** Stores the setup pose for a {@link TransformConstraint}.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class TransformConstraintData extends ConstraintData {\r\n\r\n    /** The bones that will be modified by this transform constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The target bone whose world transform will be copied to the constrained bones. */\r\n    private _target: BoneData | null = null;\r\n    public set target (boneData: BoneData) { this._target = boneData; }\r\n    public get target () {\r\n        if (!this._target) throw new Error(\"BoneData not set.\")\r\n        else return this._target;\r\n    }\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n    mixScaleX = 0;\r\n    mixScaleY = 0;\r\n    mixShearY = 0;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation = 0;\r\n\r\n    /** An offset added to the constrained bone X translation. */\r\n    offsetX = 0;\r\n\r\n    /** An offset added to the constrained bone Y translation. */\r\n    offsetY = 0;\r\n\r\n    /** An offset added to the constrained bone scaleX. */\r\n    offsetScaleX = 0;\r\n\r\n    /** An offset added to the constrained bone scaleY. */\r\n    offsetScaleY = 0;\r\n\r\n    /** An offset added to the constrained bone shearY. */\r\n    offsetShearY = 0;\r\n\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n", "import {Attachment, MeshAttachment} from './attachments';\r\nimport {BoneData} from \"./BoneData\";\r\nimport {ConstraintData} from \"./ConstraintData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\nimport type {StringMap, ISkin} from '@pixi-spine/base';\r\n\r\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\r\n * @public\r\n * **/\r\nexport class SkinEntry {\r\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) { }\r\n}\r\n\r\n/** Stores attachments by slot index and attachment name.\r\n *\r\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\r\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class Skin implements ISkin {\r\n    /** The skin's name, which is unique across all skins in the skeleton. */\r\n    name: string;\r\n\r\n    attachments = new Array<StringMap<Attachment>>();\r\n    bones = Array<BoneData>();\r\n    constraints = new Array<ConstraintData>();\r\n\r\n    constructor (name: string) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    /** Adds an attachment to the skin for the specified slot index and name. */\r\n    setAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n        if (!attachment) throw new Error(\"attachment cannot be null.\");\r\n        let attachments = this.attachments;\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\r\n    addSkin (skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n        }\r\n    }\r\n\r\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\r\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\r\n    copySkin (skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            if (!attachment.attachment) continue;\r\n            if (attachment.attachment instanceof MeshAttachment) {\r\n                attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            } else {\r\n                attachment.attachment = attachment.attachment.copy();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the attachment for the specified slot index and name, or null. */\r\n    getAttachment (slotIndex: number, name: string): Attachment | null {\r\n        let dictionary = this.attachments[slotIndex];\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\r\n    removeAttachment (slotIndex: number, name: string) {\r\n        let dictionary = this.attachments[slotIndex];\r\n        if (dictionary) delete dictionary[name];\r\n    }\r\n\r\n    /** Returns all attachments in this skin. */\r\n    getAttachments (): Array<SkinEntry> {\r\n        let entries = new Array<SkinEntry>();\r\n        for (var i = 0; i < this.attachments.length; i++) {\r\n            let slotAttachments = this.attachments[i];\r\n            if (slotAttachments) {\r\n                for (let name in slotAttachments) {\r\n                    let attachment = slotAttachments[name];\r\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                }\r\n            }\r\n        }\r\n        return entries;\r\n    }\r\n\r\n    /** Returns all attachments in this skin for the specified slot index. */\r\n    getAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\r\n        let slotAttachments = this.attachments[slotIndex];\r\n        if (slotAttachments) {\r\n            for (let name in slotAttachments) {\r\n                let attachment = slotAttachments[name];\r\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Clears all attachments, bones, and constraints. */\r\n    clear () {\r\n        this.attachments.length = 0;\r\n        this.bones.length = 0;\r\n        this.constraints.length = 0;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            let slot = skeleton.slots[i];\r\n            let slotAttachment = slot.getAttachment();\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                let dictionary = oldSkin.attachments[slotIndex];\r\n                for (let key in dictionary) {\r\n                    let skinAttachment: Attachment = dictionary[key];\r\n                    if (slotAttachment == skinAttachment) {\r\n                        let attachment = this.getAttachment(slotIndex, key);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n", "import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {\r\n    AlphaTimeline, Animation,\r\n    AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline, ScaleXTimeline, ScaleYTimeline, SequenceTimeline,\r\n    ShearTimeline, ShearXTimeline, ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline, TranslateXTimeline, TranslateYTimeline\r\n} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {AttachmentType, BinaryInput, Color, IHasTextureRegion, PositionMode, Utils} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\nimport {Sequence, SequenceModeValues} from \"./attachments\";\r\n\r\n/** Loads skeleton data in the Spine binary format.\r\n *\r\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonBinary {\r\n    ver40 = false;\r\n    static BlendModeValues = [ BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (binary: Uint8Array): SkeletonData {\r\n        let scale = this.scale;\r\n\r\n        let skeletonData = new SkeletonData();\r\n        skeletonData.name = \"\"; // BOZO\r\n\r\n        let input = new BinaryInput(binary);\r\n\r\n        let lowHash = input.readInt32();\r\n        let highHash = input.readInt32();\r\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\r\n        skeletonData.version = input.readString();\r\n        const verShort = skeletonData.version.substr(0, 3);\r\n        if (verShort !== '4.0' && verShort !== '4.1')\r\n        {\r\n            let error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\r\n            console.error(error);\r\n        }\r\n        this.ver40 = verShort === '4.0';\r\n        skeletonData.x = input.readFloat();\r\n        skeletonData.y = input.readFloat();\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        let nonessential = input.readBoolean();\r\n        if (nonessential) {\r\n            skeletonData.fps = input.readFloat();\r\n\r\n            skeletonData.imagesPath = input.readString();\r\n            skeletonData.audioPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n        // Strings.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++) {\r\n            let str = input.readString();\r\n            if (!str) throw new Error(\"String in string table must not be null.\");\r\n            input.strings.push(str);\r\n        }\r\n\r\n        // Bones.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++) {\r\n            let name = input.readString();\r\n            if (!name) throw new Error(\"Bone name must not be null.\");\r\n            let parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            let data = new BoneData(i, name, parent);\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.transformMode = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let slotName = input.readString();\r\n            if (!slotName) throw new Error(\"Slot name must not be null.\");\r\n            let boneData = skeletonData.bones[input.readInt(true)];\r\n            let data = new SlotData(i, slotName, boneData);\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n            let darkColor = input.readInt32();\r\n            if (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\r\n\r\n            data.attachmentName = input.readStringRef();\r\n            data.blendMode = input.readInt(true);\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let name = input.readString();\r\n            if (!name) throw new Error(\"IK constraint data name must not be null.\");\r\n            let data = new IkConstraintData(name);\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.softness = input.readFloat() * scale;\r\n            data.bendDirection = input.readByte();\r\n            data.compress = input.readBoolean();\r\n            data.stretch = input.readBoolean();\r\n            data.uniform = input.readBoolean();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let name = input.readString();\r\n            if (!name) throw new Error(\"Transform constraint data name must not be null.\");\r\n            let data = new TransformConstraintData(name);\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.local = input.readBoolean();\r\n            data.relative = input.readBoolean();\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            data.mixScaleX = input.readFloat();\r\n            data.mixScaleY = input.readFloat();\r\n            data.mixShearY = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let name = input.readString();\r\n            if (!name) throw new Error(\"Path constraint data name must not be null.\");\r\n            let data = new PathConstraintData(name);\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = input.readInt(true);\r\n            data.spacingMode = input.readInt(true);\r\n            data.rotateMode = input.readInt(true);\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        let defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n        if (defaultSkin) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n            Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n            for (; i < n; i++) {\r\n                let skin = this.readSkin(input, skeletonData, false, nonessential);\r\n                if (!skin) throw new Error(\"readSkin() should not have returned null.\");\r\n                skeletonData.skins[i] = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (!skin) throw new Error(\"Not skin found for linked mesh.\");\r\n            if (!linkedMesh.parent) throw new Error(\"Linked mesh parent must not be null\");\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent as VertexAttachment : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let eventName = input.readStringRef();\r\n            if (!eventName) throw new Error\r\n            let data = new EventData(eventName);\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let animationName = input.readString();\r\n            if (!animationName) throw new Error(\"Animatio name must not be null.\");\r\n            skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\r\n        }\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin | null {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true)\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin(\"default\");\r\n        } else {\r\n            let skinName = input.readStringRef();\r\n            if (!skinName) throw new Error(\"Skin name must not be null.\");\r\n            skin = new Skin(skinName);\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++)\r\n                skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let name = input.readStringRef();\r\n                if (!name) throw new Error(\"Attachment name must not be null\");\r\n                let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment (input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment | null {\r\n        let scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n        if (!name) name = attachmentName;\r\n\r\n        switch (input.readByte()) {\r\n            case AttachmentType.Region: {\r\n                let path = input.readStringRef();\r\n                let rotation = input.readFloat();\r\n                let x = input.readFloat();\r\n                let y = input.readFloat();\r\n                let scaleX = input.readFloat();\r\n                let scaleY = input.readFloat();\r\n                let width = input.readFloat();\r\n                let height = input.readFloat();\r\n                let color = input.readInt32();\r\n                let sequence = this.readSequence(input);\r\n\r\n                if (!path) path = name;\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = x * scale;\r\n                region.y = y * scale;\r\n                region.scaleX = scaleX;\r\n                region.scaleY = scaleY;\r\n                region.rotation = rotation;\r\n                region.width = width * scale;\r\n                region.height = height * scale;\r\n                Color.rgba8888ToColor(region.color, color);\r\n                region.sequence = sequence;\r\n                if (sequence == null) region.updateRegion();\r\n                return region;\r\n            }\r\n            case AttachmentType.BoundingBox: {\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (!box) return null;\r\n                box.worldVerticesLength = vertexCount << 1;\r\n                box.vertices = vertices.vertices!;\r\n                box.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n                return box;\r\n            }\r\n            case AttachmentType.Mesh: {\r\n                let path = input.readStringRef();\r\n                let color = input.readInt32();\r\n                let vertexCount = input.readInt(true);\r\n                let uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                let triangles = this.readShortArray(input);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let hullLength = input.readInt(true);\r\n                let sequence = this.readSequence(input);\r\n                let edges: number[] = [];\r\n                let width = 0, height = 0;\r\n                if (nonessential) {\r\n                    edges = this.readShortArray(input);\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.bones = vertices.bones;\r\n                mesh.vertices = vertices.vertices!;\r\n                mesh.worldVerticesLength = vertexCount << 1;\r\n                mesh.triangles = triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // if (sequence == null) mesh.updateRegion();\r\n                mesh.hullLength = hullLength << 1;\r\n                mesh.sequence = sequence;\r\n                if (nonessential) {\r\n                    mesh.edges = edges;\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                return mesh;\r\n            }\r\n            case AttachmentType.LinkedMesh: {\r\n                let path = input.readStringRef();\r\n                let color = input.readInt32();\r\n                let skinName = input.readStringRef();\r\n                let parent = input.readStringRef();\r\n                let inheritTimelines = input.readBoolean();\r\n                let sequence = this.readSequence(input);\r\n                let width = 0, height = 0;\r\n                if (nonessential) {\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.sequence = sequence;\r\n                if (nonessential) {\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\r\n                return mesh;\r\n            }\r\n            case AttachmentType.Path: {\r\n                let closed = input.readBoolean();\r\n                let constantSpeed = input.readBoolean();\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let lengths = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0, n = lengths.length; i < n; i++)\r\n                    lengths[i] = input.readFloat() * scale;\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (!path) return null;\r\n                path.closed = closed;\r\n                path.constantSpeed = constantSpeed;\r\n                path.worldVerticesLength = vertexCount << 1;\r\n                path.vertices = vertices.vertices!;\r\n                path.bones = vertices.bones;\r\n                path.lengths = lengths;\r\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n                return path;\r\n            }\r\n            case AttachmentType.Point: {\r\n                let rotation = input.readFloat();\r\n                let x = input.readFloat();\r\n                let y = input.readFloat();\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (!point) return null;\r\n                point.x = x * scale;\r\n                point.y = y * scale;\r\n                point.rotation = rotation;\r\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n                return point;\r\n            }\r\n            case AttachmentType.Clipping: {\r\n                let endSlotIndex = input.readInt(true);\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (!clip) return null;\r\n                clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                clip.worldVerticesLength = vertexCount << 1;\r\n                clip.vertices = vertices.vertices!;\r\n                clip.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private readSequence (input: BinaryInput) {\r\n        if (this.ver40 || !input.readBoolean()) return null;\r\n        let sequence = new Sequence(input.readInt(true));\r\n        sequence.start = input.readInt(true);\r\n        sequence.digits = input.readInt(true);\r\n        sequence.setupIndex = input.readInt(true);\r\n        return sequence;\r\n    }\r\n\r\n    private readDeformTimelineType(input: BinaryInput) {\r\n        if (this.ver40) return ATTACHMENT_DEFORM;\r\n        return input.readByte();\r\n    }\r\n\r\n    private readVertices (input: BinaryInput, vertexCount: number): Vertices {\r\n        let scale = this.scale;\r\n        let verticesLength = vertexCount << 1;\r\n        let vertices = new Vertices();\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n            return vertices;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bonesArray = new Array<number>();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            let boneCount = input.readInt(true);\r\n            bonesArray.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                bonesArray.push(input.readInt(true));\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat());\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\r\n        let array = new Array<number>(n);\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat() * scale;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    private readShortArray (input: BinaryInput): number[] {\r\n        let n = input.readInt(true);\r\n        let array = new Array<number>(n);\r\n        for (let i = 0; i < n; i++)\r\n            array[i] = input.readShort();\r\n        return array;\r\n    }\r\n\r\n    private readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        input.readInt(true); // Number of timelines.\r\n        let timelines = new Array<Timeline>();\r\n        let scale = this.scale;\r\n        // Slot timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let timelineType = input.readByte();\r\n                let frameCount = input.readInt(true);\r\n                let frameLast = frameCount - 1;\r\n                switch (timelineType) {\r\n                    case SLOT_ATTACHMENT: {\r\n                        let timeline = new AttachmentTimeline(frameCount, slotIndex);\r\n                        for (let frame = 0; frame < frameCount; frame++)\r\n                            timeline.setFrame(frame, input.readFloat(), input.readStringRef());\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a);\r\n                            if (frame == frameLast) break;\r\n\r\n                            let time2 = input.readFloat();\r\n                            let r2 = input.readUnsignedByte() / 255.0;\r\n                            let g2 = input.readUnsignedByte() / 255.0;\r\n                            let b2 = input.readUnsignedByte() / 255.0;\r\n                            let a2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b);\r\n                            if (frame == frameLast) break;\r\n\r\n                            let time2 = input.readFloat();\r\n                            let r2 = input.readUnsignedByte() / 255.0;\r\n                            let g2 = input.readUnsignedByte() / 255.0;\r\n                            let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA2: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let nr = input.readUnsignedByte() / 255.0;\r\n                            let ng = input.readUnsignedByte() / 255.0;\r\n                            let nb = input.readUnsignedByte() / 255.0;\r\n                            let na = input.readUnsignedByte() / 255.0;\r\n                            let nr2 = input.readUnsignedByte() / 255.0;\r\n                            let ng2 = input.readUnsignedByte() / 255.0;\r\n                            let nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            a = na;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB2: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let nr = input.readUnsignedByte() / 255.0;\r\n                            let ng = input.readUnsignedByte() / 255.0;\r\n                            let nb = input.readUnsignedByte() / 255.0;\r\n                            let nr2 = input.readUnsignedByte() / 255.0;\r\n                            let ng2 = input.readUnsignedByte() / 255.0;\r\n                            let nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_ALPHA: {\r\n                        let timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\r\n                        let time = input.readFloat(), a = input.readUnsignedByte() / 255;\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, a);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let a2 = input.readUnsignedByte() / 255;\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let boneIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let type = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);\r\n                switch (type) {\r\n                    case BONE_ROTATE:\r\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_TRANSLATE:\r\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEX:\r\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEY:\r\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_SCALE:\r\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEX:\r\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEY:\r\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEAR:\r\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARX:\r\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARY:\r\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\r\n            let timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat(), mix = input.readFloat(), softness = input.readFloat() * scale;\r\n            for (let frame = 0, bezier = 0; ; frame++) {\r\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                if (frame == frameLast) break;\r\n                let time2 = input.readFloat(), mix2 = input.readFloat(), softness2 = input.readFloat() * scale;\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\r\n                }\r\n                time = time2;\r\n                mix = mix2;\r\n                softness = softness2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\r\n            let timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(),\r\n                mixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();\r\n            for (let frame = 0, bezier = 0; ; frame++) {\r\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                if (frame == frameLast) break;\r\n                let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(),\r\n                    mixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                }\r\n                time = time2;\r\n                mixRotate = mixRotate2;\r\n                mixX = mixX2;\r\n                mixY = mixY2;\r\n                mixScaleX = mixScaleX2;\r\n                mixScaleY = mixScaleY2;\r\n                mixShearY = mixShearY2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true);\r\n            let data = skeletonData.pathConstraints[index];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                switch (input.readByte()) {\r\n                    case PATH_POSITION:\r\n                        timelines\r\n                            .push(readTimeline1(input, new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.positionMode == PositionMode.Fixed ? scale : 1));\r\n                        break;\r\n                    case PATH_SPACING:\r\n                        timelines\r\n                            .push(readTimeline1(input, new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));\r\n                        break;\r\n                    case PATH_MIX:\r\n                        let timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\r\n                        let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();\r\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(),\r\n                                mixY2 = input.readFloat();\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let skin = skeletonData.skins[input.readInt(true)];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let slotIndex = input.readInt(true);\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    let attachmentName = input.readStringRef();\r\n                    if (!attachmentName) throw new Error(\"attachmentName must not be null.\");\r\n                    let attachment = skin.getAttachment(slotIndex, attachmentName);\r\n                    let timelineType = this.readDeformTimelineType(input);\r\n                    let frameCount = input.readInt(true);\r\n                    let frameLast = frameCount - 1;\r\n\r\n                    switch (timelineType) {\r\n                        case ATTACHMENT_DEFORM: {\r\n                            let vertexAttachment = attachment as VertexAttachment;\r\n                            let weighted = vertexAttachment.bones;\r\n                            let vertices = vertexAttachment.vertices;\r\n                            let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n\r\n                            let bezierCount = input.readInt(true);\r\n                            let timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\r\n\r\n                            let time = input.readFloat();\r\n                            for (let frame = 0, bezier = 0; ; frame++) {\r\n                                let deform;\r\n                                let end = input.readInt(true);\r\n                                if (end == 0)\r\n                                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = Utils.newFloatArray(deformLength);\r\n                                    let start = input.readInt(true);\r\n                                    end += start;\r\n                                    if (scale == 1) {\r\n                                        for (let v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat();\r\n                                    } else {\r\n                                        for (let v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat() * scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (let v = 0, vn = deform.length; v < vn; v++)\r\n                                            deform[v] += vertices[v];\r\n                                    }\r\n                                }\r\n\r\n                                timeline.setFrame(frame, time, deform);\r\n                                if (frame == frameLast) break;\r\n                                let time2 = input.readFloat();\r\n                                switch (input.readByte()) {\r\n                                    case CURVE_STEPPED:\r\n                                        timeline.setStepped(frame);\r\n                                        break;\r\n                                    case CURVE_BEZIER:\r\n                                        setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\r\n                                }\r\n                                time = time2;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            break;\r\n                        }\r\n                        case ATTACHMENT_SEQUENCE: {\r\n                            let timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as IHasTextureRegion);\r\n                            for (let frame = 0; frame < frameCount; frame++) {\r\n                                let time = input.readFloat();\r\n                                let modeAndIndex = input.readInt32();\r\n                                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 0xf], modeAndIndex >> 4,\r\n                                    input.readFloat());\r\n                            }\r\n                            timelines.push(timeline);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderCount = input.readInt(true);\r\n        if (drawOrderCount > 0) {\r\n            let timeline = new DrawOrderTimeline(drawOrderCount);\r\n            let slotCount = skeletonData.slots.length;\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                let time = input.readFloat();\r\n                let offsetCount = input.readInt(true);\r\n                let drawOrder = Utils.newArray(slotCount, 0);\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    drawOrder[ii] = -1;\r\n                let unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0, unchangedIndex = 0;\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    let slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n                    while (originalIndex != slotIndex)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount)\r\n                    unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timeline.\r\n        let eventCount = input.readInt(true);\r\n        if (eventCount > 0) {\r\n            let timeline = new EventTimeline(eventCount);\r\n            for (let i = 0; i < eventCount; i++) {\r\n                let time = input.readFloat();\r\n                let eventData = skeletonData.events[input.readInt(true)];\r\n                let event = new Event(time, eventData);\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            duration = Math.max(duration, timelines[i].getDuration());\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string | null; skin: string | null;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritTimeline: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string | null, slotIndex: number, parent: string | null, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritTimeline = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor (public bones: Array<number> | null = null, public vertices: Array<number> | Float32Array | null = null) { }\r\n}\r\n\r\nfunction readTimeline1 (input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\r\n    let time = input.readFloat(), value = input.readFloat() * scale;\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        if (frame == frameLast) break;\r\n        let time2 = input.readFloat(), value2 = input.readFloat() * scale;\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\r\n        }\r\n        time = time2;\r\n        value = value2;\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction readTimeline2 (input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\r\n    let time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        if (frame == frameLast) break;\r\n        let time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\r\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction setBezier (input: BinaryInput, timeline: CurveTimeline, bezier: number, frame: number, value: number,\r\n                    time1: number, time2: number, value1: number, value2: number, scale: number) {\r\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\r\n}\r\n\r\nconst BONE_ROTATE = 0;\r\nconst BONE_TRANSLATE = 1;\r\nconst BONE_TRANSLATEX = 2;\r\nconst BONE_TRANSLATEY = 3;\r\nconst BONE_SCALE = 4;\r\nconst BONE_SCALEX = 5;\r\nconst BONE_SCALEY = 6;\r\nconst BONE_SHEAR = 7;\r\nconst BONE_SHEARX = 8;\r\nconst BONE_SHEARY = 9;\r\n\r\nconst SLOT_ATTACHMENT = 0;\r\nconst SLOT_RGBA = 1;\r\nconst SLOT_RGB = 2;\r\nconst SLOT_RGBA2 = 3;\r\nconst SLOT_RGB2 = 4;\r\nconst SLOT_ALPHA = 5;\r\n\r\nconst ATTACHMENT_DEFORM = 0;\r\nconst ATTACHMENT_SEQUENCE = 1;\r\n\r\nconst PATH_POSITION = 0;\r\nconst PATH_SPACING = 1;\r\nconst PATH_MIX = 2;\r\n\r\n// const CURVE_LINEAR = 0;\r\nconst CURVE_STEPPED = 1;\r\nconst CURVE_BEZIER = 2;\r\n", "import {BoundingBoxAttachment} from \"./attachments\";\r\nimport {SkeletonBoundsBase} from \"@pixi-spine/base\";\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment>{};", "import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {\r\n    AlphaTimeline, Animation,\r\n    AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline, ScaleXTimeline, ScaleYTimeline, SequenceTimeline,\r\n    ShearTimeline, ShearXTimeline, ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline, TranslateXTimeline, TranslateYTimeline\r\n} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {NumberArrayLike, Color, IHasTextureRegion, PositionMode, RotateMode, TransformMode, Utils, settings} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\nimport {Sequence, SequenceMode} from './attachments/Sequence';\r\n\r\n/** Loads skeleton data in the Spine JSON format.\r\n *\r\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (json: string | any): SkeletonData {\r\n        let scale = this.scale;\r\n        let skeletonData = new SkeletonData();\r\n        let root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        let skeletonMap = root.skeleton;\r\n        if (skeletonMap) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            const verShort = skeletonData.version.substr(0, 3);\r\n            if (verShort !== '4.0' && verShort !== '4.1')\r\n            {\r\n                let error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                let boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                let parentName: string = getValue(boneMap, \"parent\", null);\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                }\r\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                data.length = getValue(boneMap, \"length\", 0) * scale;\r\n                data.x = getValue(boneMap, \"x\", 0) * scale;\r\n                data.y = getValue(boneMap, \"y\", 0) * scale;\r\n                data.rotation = getValue(boneMap, \"rotation\", 0);\r\n                data.scaleX = getValue(boneMap, \"scaleX\", 1);\r\n                data.scaleY = getValue(boneMap, \"scaleY\", 1);\r\n                data.shearX = getValue(boneMap, \"shearX\", 0);\r\n                data.shearY = getValue(boneMap, \"shearY\", 0);\r\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, \"transform\", \"Normal\"));\r\n                data.skinRequired = getValue(boneMap, \"skin\", false);\r\n\r\n                let color = getValue(boneMap, \"color\", null);\r\n                if (color) data.color.setFromString(color);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                let slotMap = root.slots[i];\r\n                let boneData = skeletonData.findBone(slotMap.bone);\r\n                if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\r\n                let data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\r\n\r\n                let color: string = getValue(slotMap, \"color\", null);\r\n                if (color) data.color.setFromString(color);\r\n\r\n                let dark: string = getValue(slotMap, \"dark\", null);\r\n                if (dark) data.darkColor = Color.fromString(dark);\r\n\r\n                data.attachmentName = getValue(slotMap, \"attachment\", null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, \"blend\", \"normal\"));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                let constraintMap = root.ik[i];\r\n                let data = new IkConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                data.target = skeletonData.findBone(constraintMap.target);\r\n\r\n                data.mix = getValue(constraintMap, \"mix\", 1);\r\n                data.softness = getValue(constraintMap, \"softness\", 0) * scale;\r\n                data.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                data.compress = getValue(constraintMap, \"compress\", false);\r\n                data.stretch = getValue(constraintMap, \"stretch\", false);\r\n                data.uniform = getValue(constraintMap, \"uniform\", false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                let constraintMap = root.transform[i];\r\n                let data = new TransformConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                let target = skeletonData.findBone(targetName);\r\n                if (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\r\n                data.target = target;\r\n\r\n                data.local = getValue(constraintMap, \"local\", false);\r\n                data.relative = getValue(constraintMap, \"relative\", false);\r\n                data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\r\n                data.offsetX = getValue(constraintMap, \"x\", 0) * scale;\r\n                data.offsetY = getValue(constraintMap, \"y\", 0) * scale;\r\n                data.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\r\n                data.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\r\n                data.offsetShearY = getValue(constraintMap, \"shearY\", 0);\r\n\r\n                data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\r\n                data.mixX = getValue(constraintMap, \"mixX\", 1);\r\n                data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\r\n                data.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\r\n                data.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\r\n                data.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                let constraintMap = root.path[i];\r\n                let data = new PathConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                let target = skeletonData.findSlot(targetName);\r\n                if (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\r\n                data.target = target;\r\n\r\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\r\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\r\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\r\n                data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\r\n                data.position = getValue(constraintMap, \"position\", 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = getValue(constraintMap, \"spacing\", 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\r\n                data.mixX = getValue(constraintMap, \"mixX\", 1);\r\n                data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                let skinMap = root.skins[i]\r\n                let skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        let boneName = skinMap.bones[ii];\r\n                        let bone = skeletonData.findBone(boneName);\r\n                        if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        let constraintName = skinMap.ik[ii];\r\n                        let constraint = skeletonData.findIkConstraint(constraintName);\r\n                        if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        let constraintName = skinMap.transform[ii];\r\n                        let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                        if (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        let constraintName = skinMap.path[ii];\r\n                        let constraint = skeletonData.findPathConstraint(constraintName);\r\n                        if (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (let slotName in skinMap.attachments) {\r\n                    let slot = skeletonData.findSlot(slotName);\r\n                    if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\r\n                    let slotMap = skinMap.attachments[slotName];\r\n                    for (let entryName in slotMap) {\r\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\r\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (let eventName in root.events) {\r\n                let eventMap = root.events[eventName];\r\n                let data = new EventData(eventName);\r\n                data.intValue = getValue(eventMap, \"int\", 0);\r\n                data.floatValue = getValue(eventMap, \"float\", 0);\r\n                data.stringValue = getValue(eventMap, \"string\", \"\");\r\n                data.audioPath = getValue(eventMap, \"audio\", null);\r\n                if (data.audioPath) {\r\n                    data.volume = getValue(eventMap, \"volume\", 1);\r\n                    data.balance = getValue(eventMap, \"balance\", 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (let animationName in root.animations) {\r\n                let animationMap = root.animations[animationName];\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\r\n        let scale = this.scale;\r\n        name = getValue(map, \"name\", name);\r\n\r\n        switch (getValue(map, \"type\", \"region\")) {\r\n            case \"region\": {\r\n                let path = getValue(map, \"path\", name);\r\n                let sequence = this.readSequence(getValue(map, \"sequence\", null));\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = getValue(map, \"x\", 0) * scale;\r\n                region.y = getValue(map, \"y\", 0) * scale;\r\n                region.scaleX = getValue(map, \"scaleX\", 1);\r\n                region.scaleY = getValue(map, \"scaleY\", 1);\r\n                region.rotation = getValue(map, \"rotation\", 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n                region.sequence = sequence;\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) region.color.setFromString(color);\r\n\r\n                // if (region.region != null) region.updateRegion();\r\n                return region;\r\n            }\r\n            case \"boundingbox\": {\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (!box) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) box.color.setFromString(color);\r\n                return box;\r\n            }\r\n            case \"mesh\":\r\n            case \"linkedmesh\": {\r\n                let path = getValue(map, \"path\", name);\r\n                let sequence = this.readSequence(getValue(map, \"sequence\", null));\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n\r\n                let color = getValue(map, \"color\", null);\r\n                if (color) mesh.color.setFromString(color);\r\n\r\n                mesh.width = getValue(map, \"width\", 0) * scale;\r\n                mesh.height = getValue(map, \"height\", 0) * scale;\r\n                mesh.sequence = sequence;\r\n\r\n                let parent: string = getValue(map, \"parent\", null);\r\n                if (parent) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"timelines\", true)));\r\n                    return mesh;\r\n                }\r\n\r\n                let uvs: Array<number> = map.uvs;\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // if (mesh.region != null) mesh.updateRegion();\r\n\r\n                mesh.edges = getValue(map, \"edges\", null);\r\n                mesh.hullLength = getValue(map, \"hull\", 0) * 2;\r\n                return mesh;\r\n            }\r\n            case \"path\": {\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (!path) return null;\r\n                path.closed = getValue(map, \"closed\", false);\r\n                path.constantSpeed = getValue(map, \"constantSpeed\", true);\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0; i < map.lengths.length; i++)\r\n                    lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) path.color.setFromString(color);\r\n                return path;\r\n            }\r\n            case \"point\": {\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (!point) return null;\r\n                point.x = getValue(map, \"x\", 0) * scale;\r\n                point.y = getValue(map, \"y\", 0) * scale;\r\n                point.rotation = getValue(map, \"rotation\", 0);\r\n\r\n                let color = getValue(map, \"color\", null);\r\n                if (color) point.color.setFromString(color);\r\n                return point;\r\n            }\r\n            case \"clipping\": {\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (!clip) return null;\r\n\r\n                let end = getValue(map, \"end\", null);\r\n                if (end != null) {\r\n                    let slot = skeletonData.findSlot(end);\r\n                    if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) clip.color.setFromString(color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    readSequence (map: any) {\r\n        if (map == null) return null;\r\n        let sequence = new Sequence(getValue(map, \"count\", 0));\r\n        sequence.start = getValue(map, \"start\", 1);\r\n        sequence.digits = getValue(map, \"digits\", 0);\r\n        sequence.setupIndex = getValue(map, \"setup\", 0);\r\n        return sequence;\r\n    }\r\n\r\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        let scale = this.scale;\r\n        attachment.worldVerticesLength = verticesLength;\r\n        let vertices: Array<number> = map.vertices;\r\n        if (verticesLength == vertices.length) {\r\n            let scaledVertices = Utils.toFloatArray(vertices);\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++)\r\n                    scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n            return;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bones = new Array<number>();\r\n        for (let i = 0, n = vertices.length; i < n;) {\r\n            let boneCount = vertices[i++];\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n        let scale = this.scale;\r\n        let timelines = new Array<Timeline>();\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (let slotName in map.slots) {\r\n                let slotMap = map.slots[slotName];\r\n                let slot = skeletonData.findSlot(slotName);\r\n                if (!slot) throw new Error(\"Slot not found: \" + slotName);\r\n                let slotIndex = slot.index;\r\n                for (let timelineName in slotMap) {\r\n                    let timelineMap = slotMap[timelineName];\r\n                    if (!timelineMap) continue;\r\n                    let frames = timelineMap.length;\r\n                    if (timelineName == \"attachment\") {\r\n                        let timeline = new AttachmentTimeline(frames, slotIndex);\r\n                        for (let frame = 0; frame < frames; frame++) {\r\n                            let keyMap = timelineMap[frame];\r\n                            timeline.setFrame(frame, getValue(keyMap, \"time\", 0), getValue(keyMap, \"name\", null));\r\n                        }\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgba\") {\r\n                        let timeline = new RGBATimeline(frames, frames << 2, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.color);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgb\") {\r\n                        let timeline = new RGBTimeline(frames, frames * 3, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.color);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"alpha\") {\r\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\r\n                    } else if (timelineName == \"rgba2\") {\r\n                        let timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.light);\r\n                            let newColor2 = Color.fromString(nextMap.dark);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgb2\") {\r\n                        let timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.light);\r\n                            let newColor2 = Color.fromString(nextMap.dark);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (let boneName in map.bones) {\r\n                let boneMap = map.bones[boneName];\r\n                let bone = skeletonData.findBone(boneName);\r\n                if (!bone) throw new Error(\"Bone not found: \" + boneName);\r\n                let boneIndex = bone.index;\r\n                for (let timelineName in boneMap) {\r\n                    let timelineMap = boneMap[timelineName];\r\n                    let frames = timelineMap.length;\r\n                    if (frames == 0) continue;\r\n\r\n                    if (timelineName === \"rotate\") {\r\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\r\n                    } else if (timelineName === \"translate\") {\r\n                        let timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, scale));\r\n                    } else if (timelineName === \"translatex\") {\r\n                        let timeline = new TranslateXTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === \"translatey\") {\r\n                        let timeline = new TranslateYTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === \"scale\") {\r\n                        let timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 1, 1));\r\n                    } else if (timelineName === \"scalex\") {\r\n                        let timeline = new ScaleXTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === \"scaley\") {\r\n                        let timeline = new ScaleYTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === \"shear\") {\r\n                        let timeline = new ShearTimeline(frames, frames << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, 1));\r\n                    } else if (timelineName === \"shearx\") {\r\n                        let timeline = new ShearXTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    } else if (timelineName === \"sheary\") {\r\n                        let timeline = new ShearYTimeline(frames, frames, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (let constraintName in map.ik) {\r\n                let constraintMap = map.ik[constraintName];\r\n                let keyMap = constraintMap[0];\r\n                if (!keyMap) continue;\r\n\r\n                let constraint = skeletonData.findIkConstraint(constraintName);\r\n                if (!constraint) throw new Error(\"IK Constraint not found: \" + constraintName);\r\n                let constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\r\n\r\n                let time = getValue(keyMap, \"time\", 0);\r\n                let mix = getValue(keyMap, \"mix\", 1);\r\n                let softness = getValue(keyMap, \"softness\", 0) * scale;\r\n\r\n                for (let frame = 0, bezier = 0; ; frame++) {\r\n                    timeline.setFrame(frame, time, mix, softness, getValue(keyMap, \"bendPositive\", true) ? 1 : -1, getValue(keyMap, \"compress\", false), getValue(keyMap, \"stretch\", false));\r\n                    let nextMap = constraintMap[frame + 1];\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    let time2 = getValue(nextMap, \"time\", 0);\r\n                    let mix2 = getValue(nextMap, \"mix\", 1);\r\n                    let softness2 = getValue(nextMap, \"softness\", 0) * scale;\r\n                    let curve = keyMap.curve;\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mix = mix2;\r\n                    softness = softness2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (let constraintName in map.transform) {\r\n                let timelineMap = map.transform[constraintName];\r\n                let keyMap = timelineMap[0];\r\n                if (!keyMap) continue;\r\n\r\n                let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                if (!constraint) throw new Error(\"Transform constraint not found: \" + constraintName);\r\n                let constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\r\n\r\n                let time = getValue(keyMap, \"time\", 0);\r\n                let mixRotate = getValue(keyMap, \"mixRotate\", 1);\r\n                let mixX = getValue(keyMap, \"mixX\", 1);\r\n                let mixY = getValue(keyMap, \"mixY\", mixX);\r\n                let mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\r\n                let mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\r\n                let mixShearY = getValue(keyMap, \"mixShearY\", 1);\r\n\r\n                for (let frame = 0, bezier = 0; ; frame++) {\r\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                    let nextMap = timelineMap[frame + 1];\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    let time2 = getValue(nextMap, \"time\", 0);\r\n                    let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\r\n                    let mixX2 = getValue(nextMap, \"mixX\", 1);\r\n                    let mixY2 = getValue(nextMap, \"mixY\", mixX2);\r\n                    let mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\r\n                    let mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\r\n                    let mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\r\n                    let curve = keyMap.curve;\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mixRotate = mixRotate2;\r\n                    mixX = mixX2;\r\n                    mixY = mixY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    mixScaleY = mixScaleY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (let constraintName in map.path) {\r\n                let constraintMap = map.path[constraintName];\r\n                let constraint = skeletonData.findPathConstraint(constraintName);\r\n                if (!constraint) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                let constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\r\n                for (let timelineName in constraintMap) {\r\n                    let timelineMap = constraintMap[timelineName];\r\n                    let keyMap = timelineMap[0];\r\n                    if (!keyMap) continue;\r\n\r\n                    let frames = timelineMap.length;\r\n                    if (timelineName === \"position\") {\r\n                        let timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\r\n                    } else if (timelineName === \"spacing\") {\r\n                        let timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));\r\n                    } else if (timelineName === \"mix\") {\r\n                        let timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let mixRotate = getValue(keyMap, \"mixRotate\", 1);\r\n                        let mixX = getValue(keyMap, \"mixX\", 1);\r\n                        let mixY = getValue(keyMap, \"mixY\", mixX);\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\r\n                            let mixX2 = getValue(nextMap, \"mixX\", 1);\r\n                            let mixY2 = getValue(nextMap, \"mixY\", mixX2);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                            keyMap = nextMap;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // ver40 compatibility\r\n        if (map.deform) {\r\n            map.attachments = { };\r\n            for (let deformName in map.deform) {\r\n                let deformMap = map.deform[deformName];\r\n                let outMap = map.attachments[deformName] = {}\r\n                for (let slotName in deformMap) {\r\n                    let slotMap = deformMap[slotName];\r\n                    let outMap2 = outMap[slotName] = {};\r\n                    for (let innerMapName in slotMap) {\r\n                        outMap2[innerMapName] = {\r\n                            deform: slotMap[innerMapName]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Attachment timelines.\r\n        if (map.attachments) {\r\n            for (let attachmentsName in map.attachments) {\r\n                let attachmentsMap = map.attachments[attachmentsName];\r\n                let skin = skeletonData.findSkin(attachmentsName);\r\n                if (skin == null) {\r\n                   if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                       throw new Error(\"Skin not found: \" + attachmentsName);\r\n                   } else {\r\n                       continue;\r\n                   }\r\n                }\r\n                for (let slotMapName in attachmentsMap) {\r\n                    let slotMap = attachmentsMap[slotMapName];\r\n                    let slot = skeletonData.findSlot(slotMapName);\r\n                    if (!slot) throw new Error(\"Slot not found: \" + slotMapName);\r\n                    let slotIndex = slot.index;\r\n                    for (let attachmentMapName in slotMap) {\r\n                        let attachmentMap = slotMap[attachmentMapName];\r\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\r\n\r\n                        for (let timelineMapName in attachmentMap) {\r\n                            let timelineMap = attachmentMap[timelineMapName];\r\n                            let keyMap = timelineMap[0];\r\n                            if (!keyMap) continue;\r\n\r\n                            if (timelineMapName == \"deform\") {\r\n                                let weighted = attachment.bones;\r\n                                let vertices = attachment.vertices;\r\n                                let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                                let timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\r\n                                let time = getValue(keyMap, \"time\", 0);\r\n                                for (let frame = 0, bezier = 0; ; frame++) {\r\n                                    let deform: NumberArrayLike;\r\n                                    let verticesValue: Array<Number> = getValue(keyMap, \"vertices\", null);\r\n                                    if (!verticesValue)\r\n                                        deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                                    else {\r\n                                        deform = Utils.newFloatArray(deformLength);\r\n                                        let start = <number>getValue(keyMap, \"offset\", 0);\r\n                                        Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                        if (scale != 1) {\r\n                                            for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                                deform[i] *= scale;\r\n                                        }\r\n                                        if (!weighted) {\r\n                                            for (let i = 0; i < deformLength; i++)\r\n                                                deform[i] += vertices[i];\r\n                                        }\r\n                                    }\r\n\r\n                                    timeline.setFrame(frame, time, deform);\r\n                                    let nextMap = timelineMap[frame + 1];\r\n                                    if (!nextMap) {\r\n                                        timeline.shrink(bezier);\r\n                                        break;\r\n                                    }\r\n                                    let time2 = getValue(nextMap, \"time\", 0);\r\n                                    let curve = keyMap.curve;\r\n                                    if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\r\n                                    time = time2;\r\n                                    keyMap = nextMap;\r\n                                }\r\n                                timelines.push(timeline);\r\n                            } else if (timelineMapName == \"sequence\") {\r\n                                let timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment as unknown as IHasTextureRegion);\r\n                                let lastDelay = 0;\r\n                                for (let frame = 0; frame < timelineMap.length; frame++) {\r\n                                    let delay = getValue(keyMap, \"delay\", lastDelay);\r\n                                    let time = getValue(keyMap, \"time\", 0);\r\n                                    let mode = SequenceMode[getValue(keyMap, \"mode\", \"hold\")] as unknown as number;\r\n                                    let index = getValue(keyMap, \"index\", 0);\r\n                                    timeline.setFrame(frame, time, mode, index, delay);\r\n                                    lastDelay = delay;\r\n                                    keyMap = timelineMap[frame + 1];\r\n                                }\r\n                                timelines.push(timeline);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timelines.\r\n        if (map.drawOrder) {\r\n            let timeline = new DrawOrderTimeline(map.drawOrder.length);\r\n            let slotCount = skeletonData.slots.length;\r\n            let frame = 0;\r\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\r\n                let drawOrderMap = map.drawOrder[i];\r\n                let drawOrder: Array<number> | null = null;\r\n                let offsets = getValue(drawOrderMap, \"offsets\", null);\r\n                if (offsets) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0, unchangedIndex = 0;\r\n                    for (let ii = 0; ii < offsets.length; ii++) {\r\n                        let offsetMap = offsets[ii];\r\n                        let slot = skeletonData.findSlot(offsetMap.slot);\r\n                        if (!slot) throw new Error(\"Slot not found: \" + slot);\r\n                        let slotIndex = slot.index;\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timelines.\r\n        if (map.events) {\r\n            let timeline = new EventTimeline(map.events.length);\r\n            let frame = 0;\r\n            for (let i = 0; i < map.events.length; i++, frame++) {\r\n                let eventMap = map.events[i];\r\n                let eventData = skeletonData.findEvent(eventMap.name);\r\n                if (!eventData) throw new Error(\"Event not found: \" + eventMap.name);\r\n                let event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\r\n                event.intValue = getValue(eventMap, \"int\", eventData.intValue);\r\n                event.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\r\n                event.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\r\n                if (event.data.audioPath) {\r\n                    event.volume = getValue(eventMap, \"volume\", 1);\r\n                    event.balance = getValue(eventMap, \"balance\", 0);\r\n                }\r\n                timeline.setFrame(frame, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            duration = Math.max(duration, timelines[i].getDuration());\r\n        if (isNaN(duration)) {\r\n            throw new Error(\"Error while parsing animation, duration is NaN\");\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n    static blendModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return BLEND_MODES.NORMAL;\r\n        if (str == \"additive\") return BLEND_MODES.ADD;\r\n        if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\r\n        if (str == \"screen\") return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritTimeline: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritTimeline = inheritDeform;\r\n    }\r\n}\r\n\r\nfunction readTimeline1 (keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, \"time\", 0);\r\n    let value = getValue(keyMap, \"value\", defaultValue) * scale;\r\n    let bezier = 0;\r\n    for (let frame = 0; ; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        let nextMap = keys[frame + 1];\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n            return timeline;\r\n        }\r\n        let time2 = getValue(nextMap, \"time\", 0);\r\n        let value2 = getValue(nextMap, \"value\", defaultValue) * scale;\r\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\r\n        time = time2;\r\n        value = value2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readTimeline2 (keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, \"time\", 0);\r\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\r\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\r\n    let bezier = 0;\r\n    for (let frame = 0; ; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        let nextMap = keys[frame + 1];\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n            return timeline;\r\n        }\r\n        let time2 = getValue(nextMap, \"time\", 0);\r\n        let nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\r\n        let nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\r\n        let curve = keyMap.curve;\r\n        if (curve) {\r\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\r\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readCurve (curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number,\r\n                    value1: number, value2: number, scale: number) {\r\n    if (curve == \"stepped\") {\r\n        timeline.setStepped(frame);\r\n        return bezier;\r\n    }\r\n    let i = value << 2;\r\n    let cx1 = curve[i];\r\n    let cy1 = curve[i + 1] * scale;\r\n    let cx2 = curve[i + 2];\r\n    let cy2 = curve[i + 3] * scale;\r\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\r\n    return bezier + 1;\r\n}\r\n\r\nfunction getValue (map: any, property: string, defaultValue: any) {\r\n    return map[property] !== undefined ? map[property] : defaultValue;\r\n}\r\n", "import {SpineBase} from '@pixi-spine/base';\r\nimport {Skeleton} from \"./core/Skeleton\";\r\nimport {SkeletonData} from \"./core/SkeletonData\";\r\nimport {AnimationState} from \"./core/AnimationState\";\r\nimport {AnimationStateData} from \"./core/AnimationStateData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "/**\r\n * @public\r\n */\r\nexport enum SPINE_VERSION {\r\n    UNKNOWN = 0,\r\n    VER37 = 37,\r\n    VER38 = 38,\r\n    VER40 = 40,\r\n    VER41 = 41,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function detectSpineVersion(version: string): SPINE_VERSION {\r\n    const ver3 = version.substr(0, 3);\r\n    const verNum = Math.floor(+ver3 * 10 + 1e-3);\r\n\r\n    if (ver3 === '3.7') {\r\n        return SPINE_VERSION.VER37;\r\n    }\r\n    if (ver3 === '3.8') {\r\n        return SPINE_VERSION.VER38;\r\n    }\r\n    if (ver3 === '4.0') {\r\n        return SPINE_VERSION.VER40;\r\n    }\r\n    if (ver3 === '4.1') {\r\n        return SPINE_VERSION.VER41;\r\n    }\r\n    // try parse old versions with 3.7\r\n    if (verNum < SPINE_VERSION.VER37) {\r\n        return SPINE_VERSION.VER37;\r\n    }\r\n    return SPINE_VERSION.UNKNOWN;\r\n}\r\n", "import {AbstractSpineParser} from '@pixi-spine/loader-base';\r\nimport {BinaryInput, ISkeletonData, ISkeletonParser, TextureAtlas} from \"@pixi-spine/base\";\r\nimport {LoaderResource, Loader} from \"@pixi/loaders\";\r\nimport * as spine38 from \"@pixi-spine/runtime-3.8\";\r\nimport * as spine37 from \"@pixi-spine/runtime-3.7\";\r\nimport * as spine41 from \"@pixi-spine/runtime-4.1\";\r\nimport {detectSpineVersion, SPINE_VERSION} from \"./versions\";\r\n\r\nclass UniBinaryParser implements ISkeletonParser {\r\n    scale = 1;\r\n\r\n    readSkeletonData(atlas: TextureAtlas, dataToParse: Uint8Array): ISkeletonData {\r\n        let parser: any = null;\r\n        let version = this.readVersionOldFormat(dataToParse);\r\n        let ver = detectSpineVersion(version);\r\n        if (ver === SPINE_VERSION.VER38) {\r\n            parser = new spine38.SkeletonBinary(new spine38.AtlasAttachmentLoader(atlas));\r\n        }\r\n        version = this.readVersionNewFormat(dataToParse);\r\n        ver = detectSpineVersion(version);\r\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\r\n            parser = new spine41.SkeletonBinary(new spine41.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (!parser) {\r\n            let error = `Unsupported version of spine model ${version}, please update pixi-spine`;\r\n            console.error(error);\r\n        }\r\n\r\n        parser.scale = this.scale;\r\n        return parser.readSkeletonData(dataToParse);\r\n    }\r\n\r\n    readVersionOldFormat(dataToParse: Uint8Array){\r\n        let input = new BinaryInput(dataToParse);\r\n        let version;\r\n        try {\r\n            input.readString();\r\n            version = input.readString();\r\n        }catch (e){\r\n            version = \"\";\r\n        }\r\n        return version || \"\"\r\n    }\r\n\r\n    readVersionNewFormat(dataToParse: Uint8Array){\r\n        let input = new BinaryInput(dataToParse);\r\n        input.readInt32();\r\n        input.readInt32();\r\n        let version;\r\n        try {\r\n            version = input.readString();\r\n        }catch (e){\r\n            version = \"\"\r\n        }\r\n\r\n        return version || \"\"\r\n    }\r\n}\r\n\r\nclass UniJsonParser implements ISkeletonParser {\r\n    scale = 1;\r\n\r\n    readSkeletonData(atlas: TextureAtlas, dataToParse: any): ISkeletonData {\r\n        const version = dataToParse.skeleton.spine;\r\n        const ver = detectSpineVersion(version);\r\n        let parser: any = null;\r\n\r\n        if (ver === SPINE_VERSION.VER37) {\r\n            parser = new spine37.SkeletonJson(new spine37.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (ver === SPINE_VERSION.VER38) {\r\n            parser = new spine38.SkeletonJson(new spine38.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\r\n            parser = new spine41.SkeletonJson(new spine41.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (!parser) {\r\n            let error = `Unsupported version of spine model ${version}, please update pixi-spine`;\r\n            console.error(error);\r\n        }\r\n\r\n        parser.scale = this.scale;\r\n        return parser.readSkeletonData(dataToParse);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineParser extends AbstractSpineParser {\r\n    createBinaryParser(): ISkeletonParser {\r\n        return new UniBinaryParser();\r\n    }\r\n\r\n    createJsonParser(): ISkeletonParser {\r\n        return new UniJsonParser();\r\n    }\r\n\r\n    parseData(resource: LoaderResource, parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): void {\r\n        const parserCast = parser as (UniBinaryParser | UniJsonParser);\r\n        resource.spineData = parserCast.readSkeletonData(atlas, dataToParse);\r\n        resource.spineAtlas = atlas;\r\n    }\r\n\r\n    static use = new SpineParser().genMiddleware().use;\r\n\r\n    static registerLoaderPlugin() {\r\n        Loader.registerPlugin(SpineParser);\r\n    }\r\n}\r\n", "import {IAnimationState, IAnimationStateData, ISkeleton, ISkeletonData, SpineBase} from \"@pixi-spine/base\";\r\nimport * as spine38 from \"@pixi-spine/runtime-3.8\";\r\nimport * as spine37 from \"@pixi-spine/runtime-3.7\";\r\nimport * as spine41 from \"@pixi-spine/runtime-4.1\";\r\nimport {detectSpineVersion, SPINE_VERSION} from \"./versions\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<ISkeleton,\r\n    ISkeletonData,\r\n    IAnimationState,\r\n    IAnimationStateData> {\r\n\r\n    createSkeleton(spineData: ISkeletonData) {\r\n        const ver = detectSpineVersion(spineData.version);\r\n        let spine: any = null;\r\n\r\n        if (ver === SPINE_VERSION.VER37) {\r\n            spine = spine37;\r\n        }\r\n        if (ver === SPINE_VERSION.VER38) {\r\n            spine = spine38;\r\n        }\r\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\r\n            spine = spine41;\r\n        }\r\n        if (!spine) {\r\n            let error = `Cant detect version of spine model ${spineData.version}`;\r\n            console.error(error);\r\n        }\r\n        this.skeleton = new spine.Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new spine.AnimationStateData(spineData);\r\n        this.state = new spine.AnimationState(this.stateData);\r\n    }\r\n}\r\n", "import {Spine, SpineParser} from '@pixi-spine/loader-uni';\r\nexport {Spine, SpineParser};\r\nexport * from '@pixi-spine/base';\r\nexport {SkeletonBounds} from '@pixi-spine/runtime-4.1';\r\n\r\nSpineParser.registerLoaderPlugin();\r\n"],
  "mappings": "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",
  "names": ["AttachmentType", "BinaryInput", "MixBlend", "MixDirection", "PositionMode", "RotateMode", "TransformMode", "d", "b", "TextureFilter", "TextureWrap", "TextureRegion", "RegionFields", "TextureAtlas", "TextureAtlasReader", "TextureAtlasPage", "TextureAtlasRegion", "IntSet", "StringSet", "Color", "MathUtils", "Interpolation", "Pow", "PowOut", "Utils", "DebugUtils", "Pool", "Vector2", "TimeKeeper", "WindowedMean", "SkeletonBoundsBase", "SpineSprite", "SpineMesh", "SpineBase", "SpineDebugRenderer", "i", "len", "AbstractSpineParser", "extendStatics", "d", "b", "__extends", "Attachment", "VertexAttachment", "BoundingBoxAttachment", "ClippingAttachment", "MeshAttachment", "PathAttachment", "PointAttachment", "Slot", "RegionAttachment", "JitterEffect", "SwirlEffect", "Animation", "TimelineType", "CurveTimeline", "RotateTimeline", "TranslateTimeline", "ScaleTimeline", "ShearTimeline", "ColorTimeline", "TwoColorTimeline", "AttachmentTimeline", "DeformTimeline", "EventTimeline", "DrawOrderTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "AnimationState", "TrackEntry", "EventQueue", "EventType", "AnimationStateAdapter", "AnimationStateData", "AtlasAttachmentLoader", "Bone", "BoneData", "ConstraintData", "Event", "EventData", "IkConstraint", "IkConstraintData", "PathConstraintData", "SpacingMode", "PathConstraint", "closed", "TransformConstraint", "Skeleton", "SkeletonData", "SlotData", "TransformConstraintData", "SkinEntry", "Skin", "SkeletonBinary", "LinkedMesh", "Vertices", "SkeletonBounds", "SkeletonJson", "Spine", "extendStatics", "d", "b", "__extends", "Attachment", "VertexAttachment", "BoundingBoxAttachment", "ClippingAttachment", "MeshAttachment", "PathAttachment", "PointAttachment", "Slot", "RegionAttachment", "JitterEffect", "SwirlEffect", "Animation", "TimelineType", "CurveTimeline", "RotateTimeline", "TranslateTimeline", "ScaleTimeline", "ShearTimeline", "ColorTimeline", "TwoColorTimeline", "AttachmentTimeline", "zeros", "DeformTimeline", "EventTimeline", "DrawOrderTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "AnimationState", "EventQueue", "TrackEntry", "EventType", "AnimationStateAdapter2", "AnimationStateData", "AtlasAttachmentLoader", "Bone", "BoneData", "Event", "EventData", "IkConstraint", "IkConstraintData", "PathConstraintData", "SpacingMode", "PathConstraint", "closed", "TransformConstraint", "Skeleton", "SkeletonBounds", "SkeletonData", "SlotData", "TransformConstraintData", "Skin", "SkeletonJson", "LinkedMesh", "Spine", "extendStatics", "d", "b", "__extends", "Attachment", "VertexAttachment", "BoundingBoxAttachment", "ClippingAttachment", "MeshAttachment", "PathAttachment", "PointAttachment", "RegionAttachment", "Sequence", "SequenceMode", "Animation", "Timeline", "CurveTimeline", "CurveTimeline1", "CurveTimeline2", "RotateTimeline", "TranslateTimeline", "TranslateXTimeline", "TranslateYTimeline", "ScaleTimeline", "ScaleXTimeline", "ScaleYTimeline", "ShearTimeline", "ShearXTimeline", "ShearYTimeline", "RGBATimeline", "RGBTimeline", "AlphaTimeline", "RGBA2Timeline", "RGB2Timeline", "AttachmentTimeline", "DeformTimeline", "EventTimeline", "DrawOrderTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "SequenceTimeline", "AnimationState", "EventQueue", "TrackEntry", "EventType", "AnimationStateAdapter", "AnimationStateData", "AtlasAttachmentLoader", "Bone", "BoneData", "ConstraintData", "Event", "EventData", "IkConstraint", "IkConstraintData", "PathConstraintData", "SpacingMode", "PathConstraint", "closed", "Slot", "TransformConstraint", "Skeleton", "SkeletonData", "SlotData", "TransformConstraintData", "SkinEntry", "Skin", "SkeletonBinary", "LinkedMesh", "Vertices", "readTimeline1", "readTimeline2", "SkeletonBounds", "SkeletonJson", "Spine", "extendStatics", "d", "b", "__extends", "SPINE_VERSION", "UniBinaryParser", "SkeletonBinary", "AtlasAttachmentLoader", "UniJsonParser", "SkeletonJson", "SpineParser", "Spine"]
}
